--- /dev/null
+++ b/Documentation/gtp/howto.txt
@@ -0,0 +1,1778 @@
+		Linux Kernel GDB tracepoint module (KGTP)
+		=========================================
+		By Hui Zhu <teawater@gmail.com>
+		https://code.google.com/p/kgtp/wiki/HOWTO
+
+Update in 2013-05-08
+
+What is KGTP
+Get help or report issues about KGTP
+Table of different between GDB debug normal program and KGTP
+Preparatory work before use KGTP
+Linux kernel
+If your system use the Linux kernel that is built by yourself
+If your system use the Linux kernel from distribution
+Ubuntu
+Fedora
+Others
+Make sure current Linux kernel debug image is right
+Where is the current Linux kernel debug image
+Use /proc/kallsyms
+Use linux_banner
+Handle the issue that cannot find any file in "/sys/" or "/sys/kernel/debug/"
+Handle the issue that Linux kernel debug image's address info is not same with Linux kernel when it running
+Get KGTP
+Get KGTP through http
+Get KGTP through svn
+Config KGTP
+Compile KGTP
+Normal compile
+Compile KGTP with some special config
+Install and uninstall KGTP
+Use KGTP with DKMS
+Use KGTP patch for Linux kernel
+Install GDB for KGTP
+Howto use
+Exec it
+Make GDB connect to gtp
+GDB on the current machine
+If GDB on remote machine
+Add module symbols to GDB
+How to use getmod.py
+How to use getmod
+Direct access the current value in normal mode
+The memory of Linux kernel
+the memory of the user space program
+the trace state variables
+GDB tracepoint
+set tracepoint
+Howto handle the function is there but set tracepoint on it got fail
+How to set tracepoint condition
+How to handle error "Unsupported operator (null) (52) in expression."
+actions [num]
+collect expr1, expr2, ...
+teval expr1, expr2, ...
+while-stepping n
+Start and stop the tracepoint
+Enable and disable the tracepoint
+Use tfind select the entry inside the trace frame info
+How to handle error "No such file or directory."
+Save the trace frame info to a file
+Show and save the tracepoint
+Delete tracepoint
+Use tracepoint get register info from a point of kernel
+Use tracepoint get the value of variable from a point of kernel
+Show all the traced data of current frame
+Get status of tracepoint
+Set the trace buffer into a circular buffer
+Do not stop tracepoint when the GDB disconnects
+kprobes-optimization and the execution speed of tracepoint
+How to use trace state variables
+Simple trace state variables
+Per_cpu trace state variables
+How to define
+Example 1
+Example 2
+Special trace state variables $current_task, $current_task_pid, $current_thread_info, $cpu_id, $dump_stack, $printk_level, $printk_format, $printk_tmp ,$clock, $hardirq_count, $softirq_count and $irq_count
+Special trace state variable $self_trace
+Trace the function return with $kret
+Use $ignore_error and $last_errno to ignore the error of tstart
+Use $cooked_clock and $cooked_rdtsc the time without KGTP used
+Use $xtime_sec and $xtime_nsec get the timespec
+Howto backtrace (stack dump)
+Collect stack with $bt and use GDB command "backtrace"
+Collect stack of current function's caller with $_ret
+Use $dump_stack to output stack dump through printk
+Howto let tracepoint output value directly
+Switch collect to output the value directly
+Howto use watch tracepoint control hardware breakpoints to record memory access
+Trace state variables of watch tracepoint
+Static watch tracepoint
+Dynamic watch tracepoint
+Use while-stepping let Linux kernel do single step
+Howto use while-stepping
+Read the traceframe of while-stepping
+Howto show a variable whose value has been optimized away
+Update your GCC
+How to get the function pointer point to
+If the debug info of the function pointer is not optimized out
+If the debug info of the function pointer is optimized out
+/sys/kernel/debug/gtpframe and offline debug
+How to use /sys/kernel/debug/gtpframe_pipe
+Get the frame info with GDB
+Get the frame info with cat
+Get the frame info with getframe
+Use $pipe_trace
+Use KGTP with user space program
+Read memory of user space program directly
+collect stack (for backtrace) of user space program in tracepoint
+How to use add-ons/hotcode.py
+How to add plugin in C
+API
+Example
+How to use
+How to use performance counters
+Define a perf event trace state variable
+Define a per_cpu perf event trace state variable
+The perf event type and config
+Enable and disable all the perf event in a CPU with $p_pe_en
+GDB scripts to help with set and get the perf event trace state variables
+What is KGTP
+KGTP is a flexible , lightweight and realtime Linux debugger and tracer.
+To use it, you don't need patch or rebuild the Linux kernel. Just build KGTP module and insmod it is OK.
+
+It makes Linux Kernel supply a GDB remote debug interface. Then GDB in current machine or remote machine can debug and trace Linux kernel and user space program through GDB tracepoint and some other functions without stopping the Linux Kernel.
+And even if the board doesn't have GDB on it and doesn't have interface for remote debug. It can debug the Linux Kernel using offline debug (See HOWTO#/sys/kernel/debug/gtpframe_and_offline_debug).
+KGTP supports X86-32, X86-64, MIPS and ARM.
+KGTP is tested on Linux kernel 2.6.18 to upstream.
+And it can work with Android (See HowToUseKGTPinAndroid).
+
+For new user of KGTP, please go to see Quickstart.
+
+Please go to UPDATE to get more info about KGTP update.
+
+Get help or report issues about KGTP
+You can post it to http://code.google.com/p/kgtp/issues/list, write Email to kgtp@freelists.org or write Email to teawater@gmail.com .
+The KGTP team will try our best to help you.
+
+Table of different between GDB debug normal program and KGTP
+This table is for the people that have experience using GDB debug normal program. It will help you understand and remember the function of KGTP.
+
+Function	GDB debug normal program	GDB control KGTP debug Linux kernel
+Preparatory work	 Have a GDB installed in your system.
+Program built with "-g".	 KGTP need GDB 7.3 or newer version because it use some new functions of GDB. If your system doesn't supply it，you can get new version GDB built with "-static" that can running is most of Linux system in http://code.google.com/p/gdbt/ and you can get an introduce about howto built new GDB step by step in there.
+You alse need do some preparatory work with Linux kernel and KGTP. Please goto HOWTO#Preparatory_work_before_use_KGTP get howto do it.
+Attach	 Use command "gdb -p pid" or GDB command "attach pid" can attach a program that running in the system.	 Need insmod gtp.ko first, see #Exec_it.
+Then let GDB connect to KGTP, see #Make_GDB_connect_to_gtp.
+Please note that after GDB connect to KGTP, Linux kernel will not stop.
+Breakpoints	 GDB command "b place_will_stop", let program execute after this command. Then programe will stop in the place that setup a breakpoint.	 KGTP doesn't support breakpoints but it support tracepoints. Tracepoints can be considered as a special kind of breakpoints. It can be setup in some place of Linux kernel and define some commands that you want to do in its actions. When tracepoints start, they will execute these commands when Linux kernel execute to these place. When tracepoint stop, you can use some GDB commands parse the data that get by tracepoints like what you do when program stop by breakpoints. Difference is breakpoints will stop the program But the tracepoints of KGTP not. Please goto #GDB_tracepoint get howto use it.
+Memory read	 After GDB stop the program(maybe doesn't need), it can read memory of program with GDB command "print", "x" and so on.	 You can set special actions to collect memory to traceframe in tracepoints, and get the its value when tracepoint stop.#collect_expr1,_expr2,_... #Use_tfind_select_the_entry_inside_the_trace_frame_info 
+Or you can read memory directly when Linux kernel or program is running.#Direct_access_the_current_value_in_normal_mode
+Step and continue	 GDB can continue program execution with command "continue" and stop it with CTRL-C.	 KGTP never stop the Linux kernel. But tracepoint can be start and stop.#Start_and_stop_the_tracepoint 
+Or use while-stepping tracepoint record Linux kernel with some times single step and Let KGTP switch to replay mode. Then it support execution commands (continue, step) and reverse-execute commands (reverse-continue, reverse-step). #Use_while-stepping_let_Linux_kernel_do_single_step
+Backtrace	 GDB can print backtrace of all stack frames with command "backtrace".	 KGTP can do it too.#Howto_backtrace_(stack_dump)
+Watchpoint	 GDB can let programe stop when some memory access happen with watchpoint.	 KGTP can record the memory access with watch tracepoint. #Howto_use_watch_tracepoint_control_hardware_breakpoints_to_recor
+Call function	 GDB can call function of program with command "call function(xx,xx)".	 KGTP can call function of Linux kernel with plugin.#How_to_add_plugin_in_C
+Preparatory work before use KGTP
+Linux kernel
+If your system use the Linux kernel that is built by yourself
+To use KGTP, your Linux kernel need open following options:
+
+General setup  --->
+        [*] Kprobes
+
+[*] Enable loadable module support  --->
+
+Kernel hacking  --->
+        [*] Debug Filesystem
+        [*] Compile the kernel with debug info
+If your system use the Linux kernel from distribution
+You need install some Linux kernel package.
+
+Ubuntu
+Install the Linux kernel debug image
+1) Add debug source to the sources list of Ubuntu.
+
+Create an /etc/apt/sources.list.d/ddebs.list by running the following line at a terminal:
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+Stable releases (not alphas and betas) require three more lines adding to the same file, which is done by the following terminal command:
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-security main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+Import the debug symbol archive signing key:
+sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 428D7C01
+Then run:
+sudo apt-get update
+
+2) Get Linux kernel debug image
+
+sudo apt-get install linux-image-$(uname -r)-dbgsym
+Then you can find Linux kernel debug image in "/usr/lib/debug/boot/vmlinux-$(uname -r)".
+Please note that this step Get Linux kernel debug image need do again when Linux kernel update.
+
+Install the Linux kernel headers
+sudo apt-get install linux-headers-generic
+Install the Linux kernel source
+Install the source package:
+sudo apt-get install linux-source
+Uncompress the source package:
+sudo mkdir -p /build/buildd/
+sudo tar vxjf /usr/src/linux-source-$(uname -r | sed 's/-.*//').tar.bz2 -C /build/buildd/
+sudo rm -rf /build/buildd/linux-$(uname -r | sed 's/-.*//')
+sudo mv /build/buildd/linux-source-$(uname -r | sed 's/-.*//') /build/buildd/linux-$(uname -r | sed 's/-.*//')
+Please note that this step Install the Linux kernel source need do again when Linux kernel update.
+
+Fedora
+Install the Linux kernel debug image
+sudo yum --enablerepo=fedora-debuginfo install kernel-debuginfo
+Then you can find Linux kernel debug image in "/usr/lib/debug/lib/modules/$(uname -r)/vmlinux".
+
+Install the Linux kernel devel package
+sudo yum install kernel-devel-$(uname -r)
+Others
+You need install the Linux kernel debug image package and the Linux Kernel source.
+
+Make sure current Linux kernel debug image is right
+GDB open the right Linux kernel debug image is an very important because GDB will get the debug info and address info from it. So before you use KGTP, please do the check to make sure about it.
+There are 2 ways to do the check, what I suggest is do both of them to make sure Linux kernel debug image is right. 
+
+Please note that if you determine you use the right Linux kernel debug image, but cannot pass these ways. Please see HOWTO#Handle_the_issue_that_Linux_kernel_debug_image's_address_in.
+
+Where is the current Linux kernel debug image
+In UBUNTU, you can find it in "/usr/lib/debug/boot/vmlinux-$(uname -r)".
+In Fedora, you can find it in "/usr/lib/debug/lib/modules/$(uname -r)/vmlinux".
+If you build Linux kernel with yourself, you can find vmlinux file in the Linux kernel build directory.
+
+Use /proc/kallsyms
+In the system that its Linux kernel is what you want to trace, use following command to get the address of sys_read and sys_write:
+
+sudo cat /proc/kallsyms | grep sys_read
+ffffffff8117a520 T sys_read
+sudo cat /proc/kallsyms | grep sys_write
+ffffffff8117a5b0 T sys_write
+Then we can get that the address of sys_read is 0xffffffff8117a520 and the address of sys_write is 0xffffffff8117a5b0.
+After that use GDB get address of sys_read and sys_write from Linux kernel debug image:
+
+gdb ./vmlinux
+(gdb) p sys_read
+$1 = {long int (unsigned int, char *, size_t)} 0xffffffff8117a520 <sys_read>
+(gdb) p sys_write
+$2 = {long int (unsigned int, const char *, size_t)} 0xffffffff8117a5b0 <sys_write>
+The address of sys_read and sys_write is same, so the Linux kernel debug image is right.
+
+Use linux_banner
+sudo gdb ./vmlinux
+(gdb) p linux_banner
+$1 = "Linux version 3.4.0-rc4+ (teawater@teawater-Precision-M4600) (gcc version 4.6.3 (GCC) ) #3 SMP Tue Apr 24 13:29:05 CST 2012\n"
+This linux_banner is the kernel info inside the Linux kernel debug image.
+After that, connect to KGTP following the way in HOWTO#Make_GDB_connect_to_gtp connect to KGTP and print linux_banner again.
+
+(gdb) target remote /sys/kernel/debug/gtp
+Remote debugging using /sys/kernel/debug/gtp
+0x0000000000000000 in irq_stack_union ()
+(gdb) p linux_banner
+$2 = "Linux version 3.4.0-rc4+ (teawater@teawater-Precision-M4600) (gcc version 4.6.3 (GCC) ) #3 SMP Tue Apr 24 13:29:05 CST 2012\n"
+This linux_banner is the kernel info that Linux kernel that KGTP is tracing. If it is same with the prev kernel info, the Linux kernel debug image is right.
+
+Handle the issue that cannot find any file in "/sys/" or "/sys/kernel/debug/"
+Because KGTP interface is "/sys/kernel/debug/gtp", it will cannot be used if cannot find any file in "/sys/" or "/sys/kernel/debug/".
+
+If you got this issue, please make sure "Debug Filesystem" is opened in your kernel config first. If_your_system_use_the_Linux_kernel_that_is_built_by_yourself?
+
+If it is opened, please use following command mount sysfs.
+
+sudo mount -t sysfs none /sys/
+Then you can find files in "/sys/". 
+
+please use following command mount debugfs.
+
+mount -t debugfs none /sys/kernel/debug/
+Then you can find files in "/sys/kernel/debug/".
+
+Handle the issue that Linux kernel debug image's address info is not same with Linux kernel when it running
+In X86_32, you will found that the Linux kernel debug image's address info is not same with Linux kernel when it running through the ways in HOWTO#Make_sure_current_Linux_kernel_debug_image_is_right. And you determine the Linux kernel debug image is right.
+This issue is because:
+
+Processor type and features  --->
+        (0x1000000) Physical address where the kernel is loaded
+        (0x100000) Alignment value to which kernel should be aligned
+The values of these two options are different. Please note that the "Physical address where the kernel is loaded" is not showed in config sometimes. You can get its value through search "PHYSICAL_START".
+
+You can handle this issue through change "Alignment value to which kernel should be aligned" same with "Physical address where the kernel is loaded".
+This issue doesn't affect X86_64.
+
+Get KGTP
+Get KGTP through http
+Please goto http://code.google.com/p/kgtp/downloads/list OR UPDATE to download the package.
+
+Get KGTP through svn
+Some people have trouble with access to KGTP website. You can access kgtp through svn:
+
+svn checkout http://kgtp.googlecode.com/svn/ kgtp-read-only
+kgtp-read-only/tags/ Present for each release of KGTP.
+kgtp-read-only/trunk/ Present for the main trunk of KGTP.
+
+Config KGTP
+Following part is the default config of KGTP inside the Makefile. With this config, KGTP will build together with current kernel that running on this machine.
+
+KERNELDIR := /lib/modules/`uname -r`/build
+CROSS_COMPILE :=
+KERELDIR is set to the directory which holds the kernel you want to build for. By default, it is set to the kernel that you are running.
+Please note that this directory should be Linux kernel build directory or linux-headers directory but not the source directory but not the Linux kernel source directory. And the Linux kernel build directory should be used after build successful.
+CROSS_COMPILE is set to the prefix name of compiler that you want to build KGTP. Empty to compile with your default compiler.
+ARCH is the architecture.
+
+Or you can choose which kernel you want build with and which compiler you want use by change Makefile.
+For example:
+
+KERNELDIR := /home/teawater/kernel/bamd64
+CROSS_COMPILE :=x86_64-glibc_std-
+ARCH := x86_64
+KERNELDIR is set to /home/teawater/kernel/bamd64. Compiler will use x86_64-glibc_std-gcc.
+
+Compile KGTP
+Normal compile
+cd kgtp/
+make
+In some build environment (for example Android) will get some error with user space program getmod or getframe. Please ignore this error and use the gtp.ko in this directory.
+
+Compile KGTP with some special config
+Most of time, KGTP can auto select right options to build with Various versions of Linux kernel.
+But if you want config special options with yourself, you can read following part:
+With this option, KGTP will not auto select any build options.
+
+make AUTO=0
+With this option, KGTP will use simple frame instead of KGTP ring buffer.
+The simple frame doesn't support gtpframe_pipe. It just for debug KGTP.
+
+make AUTO=0 FRAME_SIMPLE=1
+With this option, $clock will return rdtsc value instead of local_clock.
+
+make AUTO=0 CLOCK_CYCLE=1
+With this option, KGTP will use procfs instead of debugfs.
+
+make AUTO=0 USE_PROC=1
+The options can use together, for example:
+
+make AUTO=0 FRAME_SIMPLE=1 CLOCK_CYCLE=1
+Install and uninstall KGTP
+KGTP don't need to be install because it can insmod directly inside its directory (See HOWTO#Exec_it). But if you need, you can install it to your system.
+Install:
+
+cd kgtp/
+sudo make install
+Uninstall:
+
+cd kgtp/
+sudo make uninstall
+Use KGTP with DKMS
+You can use KGTP with DKMS if you want it.
+Following commands will copy the files of KGTP to the directory that DKMS need.
+
+cd kgtp/
+sudo make dkms
+Then you can use DKMS commands to control KGTP. Please goto http://linux.dell.com/dkms/manpage.html to see how to use DKMS.
+
+Use KGTP patch for Linux kernel
+Most of time, you don't need KGTP patch because KGTP can build as a LKM and very easy to use. But to help some people include KGTP to them special Linux Kernel tree, KGTP supply patches for Linux kernel.
+In the KGTP directory:
+gtp_3.7_to_upstream.patch is the patch for Linux kernel from 3.7 to upstream.
+gtp_3.0_to_3.6.patch is the patch for Linux kernel from 3.0 to 3.6.
+gtp_2.6.39.patch is the patch for Linux kernel 2.6.39.
+gtp_2.6.33_to_2.6.38.patch is the patch for Linux kernel from 2.6.33 to 2.6.38.
+gtp_2.6.20_to_2.6.32.patch is the patch for Linux kernel from 2.6.20 to 2.6.32.
+gtp_older_to_2.6.19.patch is the patch for Linux kernel 2.6.19 and older version.
+Install GDB for KGTP
+The GDB that older than 7.3 have some bugs of tracepoint. And some functions of GDB are not very well.
+So if your GDB is older than 7.3 please go to https://code.google.com/p/gdbt/ to get howto install GDB for KGTP.
+If you have issue about GDB please get help according to HOWTO#Report_issues_about_KGTP.
+
+Howto use
+Exec it
+If you have installed KGTP in your system, you can:
+
+sudo modprobe gtp
+Or you can use the kgtp module in the directory.
+
+cd kgtp/
+sudo insmod gtp.ko
+Make GDB connect to gtp
+Please note that let GDB open a right vmlinux file is very important. Please goto #Make_sure_current_Linux_kernel_debug_image_is_right get how to do it.
+
+GDB on the current machine
+sudo gdb ./vmlinux
+(gdb) target remote /sys/kernel/debug/gtp
+Remote debugging using /sys/kernel/debug/gtp
+0x0000000000000000 in ?? ()
+After that, you can begin to use GDB command trace and debug the Linux Kernel.
+
+If GDB on remote machine
+#Open the KGTP interface in current machine.
+sudo su
+nc -l 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp
+(nc -l -p 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp for old version netcat.)
+#Let gdb connect to the port 1234
+gdb ./vmlinux
+(gdb) target remote xxx.xxx.xxx.xxx:1234
+After that, you can begin to use GDB command trace and debug the Linux Kernel.
+
+Add module symbols to GDB
+Sometimes you need to add a Linux kernel module's symbols to GDB to debug it.
+Add symbols with hand is not very easy, so KGTP package include an GDB python script "getmod.py" and a program "getmod" can help you.
+
+How to use getmod.py
+Connect to KGTP before use the getmod.py.
+
+(gdb) source ~/kgtp/getmod.py
+Then this script will auto load the Linux kernel module's symbols to GDB.
+
+How to use getmod
+"getmod" is written by C so you can use it anywhere even if in an embedded environment.
+For example:
+
+#Following command save Linux Kernel module info to the file ~/tmp/mi in GDB
+#command format.
+sudo getmod >~/tmp/mi
+#in gdb part:
+(gdb) source ~/tmp/mi
+add symbol table from file "/lib/modules/2.6.39-rc5+/kernel/fs/nls/nls_iso8859-1.ko" at
+        .text_addr = 0xf80de000
+        .note.gnu.build-id_addr = 0xf80de088
+        .exit.text_addr = 0xf80de074
+        .init.text_addr = 0xf8118000
+        .rodata.str1.1_addr = 0xf80de0ac
+        .rodata_addr = 0xf80de0c0
+        __mcount_loc_addr = 0xf80de9c0
+        .data_addr = 0xf80de9e0
+        .gnu.linkonce.this_module_addr = 0xf80dea00
+#After this GDB command, all the Linux Kernel module info is loaded into GDB.
+If you use remote debug or offline debug, maybe you need change the base directory. Following example is for it.
+
+#/lib/modules/2.6.39-rc5+/kernel is replaced to sudo ./getmod -r /home/teawater/kernel/b26
+sudo ./getmod -r /home/teawater/kernel/b26 >~/tmp/mi
+Direct access the current value in normal mode
+After GDB connect to KGTP, if it doesn't select any a entry of trace frame bufffer with GDB command "tfind", GDB in the normal mode. Then you can direct access the current value of memory (Linux kernel or the user space program) and the trace state variables without stop anything.
+If you have selected a trace frame entry, use GDB command "tfind -1" to return to normal mode. Please goto #Use_tfind_select_the_entry_inside_the_trace_frame_info get more info about GDB command "tfind".
+
+The memory of Linux kernel
+For example, you can access to "jiffies_64" with following command:
+
+(gdb) p jiffies_64
+Or you can access to the first entry of "static LIST_HEAD(modules)" with following command:
+
+(gdb) p *((struct module *)((char *)modules->next - ((size_t) &(((struct module *)0)->list))))
+Or you can access to the CPU0 memory info of "DEFINE_PER_CPU(struct device *, mce_device);":`
+
+p *(struct device *)(__per_cpu_offset[0]+(uint64_t)(&mce_device))
+If you want show more than one variables with one GDB command, please use following example:
+
+(gdb) printf "%4d %4d %4d %4d %4d %4d %18d %lu\n", this_rq->cpu, this_rq->nr_running, this_rq->nr_uninterruptible, nr_active, calc_load_tasks->counter, this_rq->calc_load_active, delta, this_rq->calc_load_update
+2 1 0 0 0 0 673538312 717077240
+the memory of the user space program
+KGTP can read memory directly without stop this user space program. For example:
+
+#Connect to KGTP(it is different with the way that is introduced in before)
+(gdb) target extended-remote /sys/kernel/debug/gtp
+#Add a new inferior to parse info of the user space program.
+(gdb) add-inferior
+Added inferior 2
+#Switch to this inferior
+(gdb) inferior 2
+[Switching to inferior 2 [<null>] (<noexec>)]
+#Load the symbol of the program this you want to read
+(gdb) file ~/kernel/svn/bak/a.out
+Reading symbols from /home/teawater/kernel/svn/bak/a.out...done.
+#Attach to the program (it will not stop the program).
+(gdb) attach 10039
+Attaching to program: /home/teawater/kernel/svn/bak/a.out, Remote target
+Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...(no debugging symbols found)...done.
+Loaded symbols for /lib/x86_64-linux-gnu/libc.so.6
+Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
+Loaded symbols for /lib64/ld-linux-x86-64.so.2
+0x0000000000000000 in ?? ()
+#Then you can read the value of this program.
+(gdb) p c
+$3 = -1222013392
+(gdb) p c
+$4 = -590910451
+In this example, I used some multiple Inferiors commands. Please goto http://sourceware.org/gdb/current/onlinedocs/gdb/Inferiors-and-Programs.html get more info about it.
+
+the trace state variables
+You can access value of TSV with the command that same with access memory.
+Please goto HOWTO#How_to_use_trace_state_variables get more info about TSV.
+
+GDB tracepoint
+Tracepoint is that GDB define some addresses and some actions and put them to the target (KGTP). After tracepoint start, , KGTP will do these actions (Some of them will collect data and save them to tracepoint frame buffer) when Linux kernel execution to there addresses. After that, Linux kernel will keep execution.
+KGTP supply some interfaces that GDB or other programe can take the data of tracepoint frame buffer out to parse.
+About these interfaces, this doc have introduced "/sys/kernel/debug/gtp". And will introduce "/sys/kernel/debug/gtpframe" and "/sys/kernel/debug/gtpframe_pipe" later.
+
+Doc of GDB tracepoint in http://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoints.html.
+
+set tracepoint
+The trace command is very similar to the break command. Its argument location can be a source line, a function name, or an address in the target program. The trace command defines a tracepoint, which is a address or some addresses that KGTP do some actions in it.
+Here are some examples of using the trace command:
+
+(gdb) trace foo.c:121    // a source file and line number
+
+(gdb) trace +2           // 2 lines forward
+
+(gdb) trace my_function  // first source line of function
+
+(gdb) trace *my_function // EXACT start address of function
+
+(gdb) trace *0x2117c4    // an address
+Howto handle the function is there but set tracepoint on it got fail
+GCC will inline some static function to increase the performance. You cannot set tracepoint on the function name because object file doesn't have symbol of inline function.
+You can use "trace filename:line" to set tracepoint on it.
+
+How to set tracepoint condition
+http://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Conditions.html
+Like breakpoints, we can set conditions on tracepoints. The speed of tracepoints is faster than breakpoints because KGTP can do all the condition checks.
+For example:
+
+(gdb) trace handle_irq if (irq == 47)
+This action of tracepoint 1 will work only when irq number is 47.
+
+And you can use GDB command "condition" to specify the condition of a tracepoint. GDB command "condition N COND" will specify tracepoint number N to trace only if COND is true.
+For example:
+
+(gdb) trace handle_irq
+(gdb) condition 1 (irq == 47)
+GDB command "info tracepoint" will show the ID of the tracepoint.
+
+Value of $bpnum is the last ID of GDB tracepoint. Then you can use GDB command "condtion" set the condition of last tracepoint without get its ID. For example:
+
+(gdb) trace handle_irq
+(gdb) condition $bpnum (irq == 47)
+How to handle error "Unsupported operator (null) (52) in expression."
+If you use condition about string, you will got this error when you call "tstart".
+To handle it, you can convent the char to int to handle this issue, for example:
+
+(gdb) p/x 'A'
+$4 = 0x41
+(gdb) condition 1 (buf[0] == 0x41)
+actions [num]
+This command will prompt for a list of actions to be taken when the tracepoint is hit. If the tracepoint number num is not specified, this command sets the actions for the one that was most recently defined (so that you can define a tracepoint and then say actions without bothering about its number). You specify the actions themselves on the following lines, one action at a time, and terminate the actions list with a line containing just end. So far, the only defined actions are collect, teval, and while-stepping.
+
+collect expr1, expr2, ...
+Collect values of the given expressions when the tracepoint is hit. This command accepts a comma-separated list of any valid expressions. In addition to global, static, or local variables, the following special arguments are supported:
+
+$regs   Collect all registers. 
+$args   Collect all function arguments. 
+$locals Collect all local variables. 
+Please note that collect an pointer (collect ptr) will just collect the address of this pointer. Add a * before ptr will make action collect the data that pointer point to(collect *ptr).
+
+teval expr1, expr2, ...
+Evaluate the given expressions when the tracepoint is hit. This command accepts a comma-separated list of expressions. The results are discarded, so this is mainly useful for assigning values to trace state variables (see HOWTO#Simple_trace_state_variables) without adding those values to the trace buffer, as would be the case if the collect action were used.
+
+while-stepping n
+Please goto #Use_while-stepping_let_Linux_kernel_do_single_step see howto use it.
+
+Start and stop the tracepoint
+Tracepoint will exec actions only when it is starting use this GDB command:
+
+(gdb) tstart
+It will stop by this GDB command:
+
+(gdb) tstop
+Enable and disable the tracepoint
+Like breakpoint, tracepoint can be control by GDB commands "enable" and "disable". But please note that it only useful when tracepoint stop.
+
+Use tfind select the entry inside the trace frame info
+GDB command "tfind" is used to select a entry of trace frame bufffer when tracepoint stop.
+When GDB inside "tfind" mode, it will just show the values of this entry that the tracepoint action collect. So it will output some error when print some values that action doesn't collect for example the argument of function. That is not a bug, please don't worry about it.
+Use "tfind" again will select next entry. "tfind id" will select entry id.
+To return to normal mode(HOWTO#Direct_access_the_current_value_in_normal_mode), please use GDB command "tfind -1". Please goto http://sourceware.org/gdb/current/onlinedocs/gdb/tfind.html get more info about it.
+
+How to handle error "No such file or directory."
+When GDB cannot find the source code of Linux kernel, it will show this error message. For example:
+
+(gdb) tfind 
+Found trace frame 1, tracepoint 1
+#0  vfs_read (file=0xffff8801c36e6400, buf=0x7fff51a8f110 <Address 0x7fff51a8f110 out of bounds>, count=16, 
+    pos=0xffff8801761dff48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     /build/buildd/linux-3.2.0/fs/read_write.c: No such file or directory.
+You can use GDB command "set substitute-path" to handle it. The prev example, the Linux kernel source is in "/build/buildd/test/linux-3.2.0/". But vmlinux let GDB find Linux kernel source in "/build/buildd/linux-3.2.0/". You can handle it with:
+
+(gdb) set substitute-path /build/buildd/linux-3.2.0/ /build/buildd/test/linux-3.2.0/
+(gdb) tfind 
+Found trace frame 1, tracepoint 1
+#0  vfs_read (file=0xffff8801c36e6400, buf=0x7fff51a8f110 <Address 0x7fff51a8f110 out of bounds>, count=16, 
+    pos=0xffff8801761dff48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+GDB have some other commands to handle the source code issue. Please goto http://sourceware.org/gdb/current/onlinedocs/gdb/Source-Path.html get the introduce about them.
+
+Save the trace frame info to a file
+/sys/kernel/debug/gtpframe supplies trace frame in tfile format (GDB can parse it) when KGTP is stop.
+Please note that some "cp" cannot handle it very well, please use "cat /sys/kernel/debug/gtpframe > ./gtpframe" to copy it.
+You can open file gtpframe when you want:
+
+(gdb) target tfile ./gtpframe
+Tracepoint 1 at 0xffffffff8114f3dc: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+Created tracepoint 1 for target's tracepoint 1 at 0xffffffff8114f3c0.
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880036e8f300, filler=0xffffffff8114f240 <filldir>, buf=0xffff880001e5bf38)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+Show and save the tracepoint
+You can use GDB command "info tracepoints" to show all the tracepoints.
+You can use GDB command "save tracepoints filename" to save the commands that setup the tracepoints and actions into file filename. Then you use use GDB commands "source filename" to setup this tracepints again.
+
+Delete tracepoint
+GDB command "delete id" will delete tracepoint id. If "delete" without argument, it will delete all the tracepoint.
+
+Use tracepoint get register info from a point of kernel
+The following is an example that records the value of all registers when "vfs_readdir" is called.
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xc01a1ac0: file
+/home/teawater/kernel/linux-2.6/fs/readdir.c, line 23.
+(gdb) actions
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $reg
+>end
+(gdb) tstart
+(gdb) shell ls
+(gdb) tstop
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  0xc01a1ac1 in vfs_readdir (file=0xc5528d00, filler=0xc01a1900 <filldir64>,
+   buf=0xc0d09f90) at /home/teawater/kernel/linux-2.6/fs/readdir.c:23
+23      /home/teawater/kernel/linux-2.6/fs/readdir.c: No such file or directory.
+       in /home/teawater/kernel/linux-2.6/fs/readdir.c
+(gdb) info reg
+eax            0xc5528d00       -984445696
+ecx            0xc0d09f90       -1060069488
+edx            0xc01a1900       -1072031488
+ebx            0xfffffff7       -9
+esp            0xc0d09f8c       0xc0d09f8c
+ebp            0x0      0x0
+esi            0x8061480        134616192
+edi            0xc5528d00       -984445696
+eip            0xc01a1ac1       0xc01a1ac1 <vfs_readdir+1>
+eflags         0x286    [ PF SF IF ]
+cs             0x60     96
+ss             0x8061480        134616192
+ds             0x7b     123
+es             0x7b     123
+fs             0x0      0
+gs             0x0      0
+(gdb) tfind
+Found trace frame 1, tracepoint 1
+0xc01a1ac1      23      in /home/teawater/kernel/linux-2.6/fs/readdir.c
+(gdb) info reg
+eax            0xc5528d00       -984445696
+ecx            0xc0d09f90       -1060069488
+edx            0xc01a1900       -1072031488
+ebx            0xfffffff7       -9
+esp            0xc0d09f8c       0xc0d09f8c
+ebp            0x0      0x0
+esi            0x8061480        134616192
+edi            0xc5528d00       -984445696
+eip            0xc01a1ac1       0xc01a1ac1 <vfs_readdir+1>
+eflags         0x286    [ PF SF IF ]
+cs             0x60     96
+ss             0x8061480        134616192
+ds             0x7b     123
+es             0x7b     123
+fs             0x0      0
+gs             0x0      0
+Use tracepoint get the value of variable from a point of kernel
+The following is an example that records the value of "jiffies_64" when the function "vfs_readdir" is called:
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir 
+Tracepoint 1 at 0xc01ed740: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect jiffies_64
+>collect file->f_path.dentry->d_iname
+>end
+(gdb) tstart 
+(gdb) shell ls
+arch    drivers   include  kernel    mm               Module.symvers  security  System.map  virt
+block   firmware  init     lib       modules.builtin  net             sound     t           vmlinux
+crypto  fs        ipc      Makefile  modules.order    scripts         source    usr         vmlinux.o
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  0xc01ed741 in vfs_readdir (file=0xf4063000, filler=0xc01ed580 <filldir64>, buf=0xd6dfdf90)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+(gdb) p jiffies_64
+$1 = 4297248706
+(gdb) p file->f_path.dentry->d_iname
+$1 = "b26", '\000' <repeats 28 times>
+Show all the traced data of current frame
+After use "tfind" select an entry, you can use "tdump" to do it.
+
+(gdb) tdump 
+Data collected at tracepoint 1, trace frame 0:
+$cr = void
+file->f_path.dentry->d_iname = "gtp\000.google.chrome.g05ZYO\000\235\337\000\000\000\000\200\067k\364\200\067", <incomplete sequence \364>
+jiffies_64 = 4319751455
+Get status of tracepoint
+Please use GDB command "tstatus".
+
+Set the trace buffer into a circular buffer
+http://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html
+The frame buffer is not a circular buffer by default. When the buffer is full, the tracepoint will stop.
+Following command will set frame buffer to a circular buffer. When the buffer is full, it will auto discard traceframes (oldest first) and keep trace.
+
+(gdb) set circular-trace-buffer on
+Do not stop tracepoint when the GDB disconnects
+http://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html
+KGTP will stop tracepoint and delete the trace frame when GDB disconnects with it by default.
+Following command will open the KGTP disconnect-trace. After that, when GDB disconnects with KGTP, KGTP will not stop tracepoint. And after GDB reconnects to KGTP, it can keep control of KGTP like nothing happened.
+
+(gdb) set disconnected-tracing on
+kprobes-optimization and the execution speed of tracepoint
+The tracepoint is execution together with Linux kernel. So it speed will affect the speed the system.
+The KGTP tracepoint base on Linux kernel kprobe. Because the normal kprobe base on breakpoint instruction, so it is not very fast.
+
+But if arch of kernel is X86_64 or X86_32 and kernel config didn't open "Preemptible Kernel" (PREEMPT), the kprobe is speed up by kprobes-optimization (CONFIG_OPTPROBES) that make kprobe very fast.
+To make sure about that, you can use following command in terminal:
+
+sysctl -A | grep kprobe
+debug.kprobes-optimization = 1
+That means that your kernel support kprobes-optimization.
+Please note that some KGTP functions will make this tracepoint use simple kprobe even if this Kernel support kprobes-optimization. This doc will add note when introduce these functions. Please avoid using them when you really care about the tracepoint speed.
+
+How to use trace state variables
+http://sourceware.org/gdb/current/onlinedocs/gdb/Trace-State-Variables.html
+Trace state variable is referred to as the TSV.
+TSV can be accessed in tracepoint action and condition or direct access by GDB command.
+Please note that just GDB 7.2.1 and later versions support use trace state variables directly, the old version of GDB can show the value of trace state variables through command "info tvariables".
+
+Simple trace state variables
+Define a trace state variable $c.
+
+(gdb) tvariable $c
+Trace state variable $c is created with initial value 0. The following action uses $c to count how many irqs happened in the kernel.
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace handle_irq
+(gdb) actions 
+Enter actions for tracepoint 3, one per line.
+End with a line saying just "end".
+>collect $c     #Save current value of $c to the trace frame buffer.
+>teval $c=$c+1  #Increase the $c.
+>end
+Also, you can set a value of variable to trace state variable, but don't forget covert variable to "uint64_t".
+
+>teval $c=(uint64_t)a
+You can get the current value of $c while the trace is running or stopped.
+
+(gdb) tstart
+(gdb) info tvariables
+$c              0           31554
+(gdb) p $c
+$5 = 33652
+(gdb) tstop
+(gdb) p $c
+$9 = 105559
+When using tfind, you can parse the trace frame buffer. If the value of a trace state variable is collected, you can parse it out.
+
+(gdb) tstop 
+(gdb) tfind 
+(gdb) info tvariables
+$c              0           0
+(gdb) p $c
+$6 = 0
+(gdb) tfind 100
+(gdb) p $c
+$7 = 100
+If need, the tracepoint action that access the simple trace state variables will auto lock a spin lock for trace state variables. So it can handle race condition issue about trace state variables.
+The following example is OK even if it running a machine that have more than one CPU.
+
+>teval $c=$c+1
+Per_cpu trace state variables
+Per_cpu trace state variables are special simple trace state variables.
+When tracepoint action access to it, it will access to this CPU special trace state variables.
+It have 2 advantages:
+1. The tracepoint actions that access to per_cpu trace state variables don't have the race conditon issue. So it don't need lock the spin lock for trace state variables. It is faster than simple trace state variables on multi-core machine. 
+2. Write the action that count some CPU special thing with it is easier than simple trace state variables.
+
+How to define
+Per_cpu trace state variables have two types:
+
+Local CPU variables
+"per_cpu_"+string
+or
+
+"p_"+string
+For example:
+
+(gdb) tvariable $p_count
+When access this trace state variable in tracepoint actions, it will return the variable's value of CPU that this tracepoint actions running on.
+
+CPU id variables
+"per_cpu_"+string+CPU_id
+or
+
+"p_"+string+CPU_id
+For example:
+
+(gdb) tvariable $p_count0
+(gdb) tvariable $p_count1
+(gdb) tvariable $p_count2
+(gdb) tvariable $p_count3
+When access this trace state variable in tracepoint actions or GDB command line, it will return the variable's value of CPU CPU_id. 
+Follow example can auto define a CPU id variables for each CPU of this machine. (Please note that need let GDB connect to KGTP before use these commands.)
+
+(gdb) set $tmp=0
+(gdb) while $tmp<$cpu_number
+ >eval "tvariable $p_count%d",$tmp
+ >set $tmp=$tmp+1
+ >end
+Example 1
+This example define a tracepoint that count the times that call vfs_read of each CPU.
+
+tvariable $p_count
+set $tmp=0
+while $tmp<$cpu_number
+  eval "tvariable $p_count%d",$tmp
+  set $tmp=$tmp+1
+  end
+trace vfs_read
+actions
+  teval $p_count=$p_count+1
+  end
+Then you can show how many vfs_read in each CPU after "tstart":
+
+(gdb) p $p_count0
+$3 = 44802
+(gdb) p $p_count1
+$4 = 55272
+(gdb) p $p_count2
+$5 = 102085
+(gdb) p $p_count3
+Example 2
+This example record stack dump of the function that close IRQ longest time of each CPU.
+
+set pagination off
+
+tvariable $bt=1024
+tvariable $p_count
+tvariable $p_cc
+set $tmp=0
+while $tmp<$cpu_number
+eval "tvariable $p_cc%d",$tmp
+set $tmp=$tmp+1
+end
+
+tvariable $ignore_error=1
+
+trace arch_local_irq_disable
+  commands
+    teval $p_count=$clock
+  end
+trace arch_local_irq_enable if ($p_count && $p_cc < $clock - $p_count)
+  commands
+    teval $p_cc = $clock - $p_count
+    collect $bt
+    collect $p_cc
+    teval $p_count=0
+  end
+
+enable
+set pagination on
+Special trace state variables $current_task, $current_task_pid, $current_thread_info, $cpu_id, $dump_stack, $printk_level, $printk_format, $printk_tmp ,$clock, $hardirq_count, $softirq_count and $irq_count
+KGTP special trace state variables $current_task, $current_thread_info, $cpu_id and $clock can very easy to access to some special value. You can see them when GDB connects to the KGTP. You can use them in tracepoint conditions or actions. 
+Access $current_task in tracepoint condition and action will get that returns of get_current().
+Access $current_task_pid in tracepoint condition and action will get that returns of get_current()->pid.
+Access $current_thread_info in tracepoint condition and action will get that returns of current_thread_info().
+Access $cpu_id in tracepoint condition and action will get that returns of smp_processor_id().
+Access $clock in tracepoint condition and action will get that returns of local_clock() that return the timestamp in nanoseconds.
+$rdtsc is only available on X86 and X86_64 architecture. Access it in anytime will get current value of TSC with instruction RDTSC.
+Access $hardirq_count in tracepoint condition and action will get that returns of hardirq_count().
+Access $softirq_count in tracepoint condition and action will get that returns of softirq_count().
+Access $irq_count in tracepoint condition and action will get that returns of irq_count().
+And KGTP has other special trace state variables $dump_stack, $printk_level, $printk_format and $printk_tmp. All of them output their values directly, as can be seen in HOWTO#Howto_let_tracepoint_output_value_directly.
+The following example counts in $c how many vfs_read calls that process 16663 does and collects the struct thread_info of current task:
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_read if (((struct task_struct *)$current_task)->pid == 16663)
+(gdb) tvariable $c
+(gdb) actions
+Enter actions for tracepoint 4, one per line.
+End with a line saying just "end".
+>teval $c=$c+1
+>collect (*(struct thread_info *)$current_thread_info)
+>end
+(gdb) tstart 
+(gdb) info tvariables 
+Name            Initial     Current     
+$c              0           184         
+$current_task   0           <unknown>   
+$current_thread_info 0           <unknown>   
+$cpu_id         0           <unknown>   
+(gdb) tstop
+(gdb) tfind
+(gdb) p *(struct thread_info *)$current_thread_info
+$10 = {task = 0xf0ac6580, exec_domain = 0xc07b1400, flags = 0, status = 0, cpu = 1, preempt_count = 2, addr_limit = {
+    seg = 4294967295}, restart_block = {fn = 0xc0159fb0 <do_no_restart_syscall>, {{arg0 = 138300720, arg1 = 11, 
+        arg2 = 1, arg3 = 78}, futex = {uaddr = 0x83e4d30, val = 11, flags = 1, bitset = 78, time = 977063750, 
+        uaddr2 = 0x0}, nanosleep = {index = 138300720, rmtp = 0xb, expires = 335007449089}, poll = {
+        ufds = 0x83e4d30, nfds = 11, has_timeout = 1, tv_sec = 78, tv_nsec = 977063750}}}, 
+  sysenter_return = 0xb77ce424, previous_esp = 0, supervisor_stack = 0xef340044 "", uaccess_err = 0}
+Another example shows how much sys_read() executes in each CPU.
+
+(gdb) tvariable $c0
+(gdb) tvariable $c1
+(gdb) trace sys_read 
+(gdb) condition $bpnum ($cpu_id == 0)
+(gdb) actions
+>teval $c0=$c0+1
+>end
+(gdb) trace sys_read 
+(gdb) condition $bpnum ($cpu_id == 1)
+(gdb) actions
+>teval $c1=$c1+1
+>end
+(gdb) info tvariables 
+Name            Initial     Current     
+$current_task   0           <unknown>   
+$cpu_id         0           <unknown>   
+$c0             0           3255        
+$c1             0           1904     
+sys_read() execute 3255 times in cpu0 and 1904 times in cpu1. Please note that this example just to howto use $cpu_id. Actially, this example use per_cpu trace state variables is better.
+
+Special trace state variable $self_trace
+$self_trace is different with the special trace state variables in the previous section. It is used to control the behavior of tracepoint.
+In default, when tracepoint is triggered, the actions will not execute if the current_task is the a KGTP self process (GDB, netcat, getframe or some others process that access to the interface of KGTP).
+If you want tracepoint actions execute with any task, please include a command access to the $self_trace in the actions i.e. add following command to the actions:
+
+>teval $self_trace=0
+Trace the function return with $kret
+Sometime, set the tracepoint to the end of function is hard because the Kernel is compiled with optimization. At this time, you can get help from $kret.
+$kret is a special trace state variable like $self_trace. When you set value of it inside the action of tracepoint, this tracepoint be set with kretprobe instead of kprobe. Then it can trace the end of this function.
+Please note that this tracepoint must set in the first address of the function in format "function_name".
+
+Following part is an example:
+
+#"*(function_name)" format can make certain that GDB send the first address of function to KGTP.
+(gdb) trace *vfs_read
+(gdb) actions
+>teval $kret=0
+#Following part you can set commands that you want.
+Use $ignore_error and $last_errno to ignore the error of tstart
+If KGTP got any error of tstart, this command will get fail.
+But sometime we need ignore this error and let KGTP keep work. For example: If you set tracepoint on the inline function spin_lock. This tracepoint will be set to a lot of addresses that some of them cannot be set kprobe. It will make tstart get fail. You can use "$ignore_error" ignore this error.
+And the last error number will available in "$last_errno".
+
+(gdb) tvariable $ignore_error=1
+This command will open ignore.
+
+(gdb) tvariable $ignore_error=0
+This command will close ignore.
+
+Use $cooked_clock and $cooked_rdtsc the time without KGTP used
+Access these two trace state variables can get the time without KGTP used. Then we can get more close to really time that a part of code used even if the actions of tracepoint is very complex. They will be introduce in Cookbook (coming soon).
+
+Use $xtime_sec and $xtime_nsec get the timespec
+Access these two trace state variables will return the time of day in a timespec that use getnstimeofday.
+$xtime_sec will access to the second part of a timespec.
+$xtime_nsec will access to the nanosecond part of a timespec.
+
+Howto backtrace (stack dump)
+Each time your program performs a function call, information about the call is generated. That information includes the location of the call in your program, the arguments of the call, and the local variables of the function being called. The information is saved in a block of data called a stack frame. The stack frames are allocated in a region of memory called the call stack.
+
+Collect stack with $bt and use GDB command "backtrace"
+Because this way is faster (just collect the stack when trace) and parse out most of info inside the call stack (it can show all the stack info that I introduce). So I suggest you use this way to do the stack dump.
+First we need add the collect the stack command to the tracepoint action.
+The general collect the stack command in GDB tracepoint is: In x86_32, following command will collect 512 bytes of stack.
+>collect *(unsigned char *)$esp@512
+In x86_64, following command will collect 512 bytes of stack.
+>collect *(unsigned char *)$rsp@512
+In MIPS or ARM, following command will collect 512 bytes of stack.
+>collect *(unsigned char *)$sp@512
+These commands is so hard to remember, and the different arch need different command.
+KGTP have an special tracepoint trace state variable $bt. If tracepoint action access it, KGTP will auto collect the $bt size (default value is 512) stack. For example, this command will collect 512 bytes stack memory:
+
+>collect $bt
+If you want to change size of $bt, you can use following GDB command before "tstart":
+
+(gdb) tvariable $bt=1024
+Following part is an example about howto collect stack and howto use GDB parse it:
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8118c300: file /home/teawater/kernel2/linux/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $bt
+>end
+(gdb) tstart 
+(gdb) shell ls
+1      crypto    fs             include  kernel    mm               Module.symvers  security  System.map  vmlinux
+arch   drivers   hotcode.html   init     lib       modules.builtin  net             sound     usr         vmlinux.o
+block  firmware  hotcode.html~  ipc      Makefile  modules.order    scripts         source    virt
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+24      {
+(gdb) bt
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+#1  0xffffffff8118c689 in sys_getdents (fd=<optimized out>, dirent=0x1398c58, count=32768) at /home/teawater/kernel2/linux/fs/readdir.c:214
+#2  <signal handler called>
+#3  0x00007f00253848a5 in ?? ()
+#4  0x00003efd32cddfc9 in ?? ()
+#5  0x00002c15b7d04101 in ?? ()
+#6  0x000019c0c5704bf1 in ?? ()
+#7  0x0000000900000000 in ?? ()
+#8  0x000009988cc8d269 in ?? ()
+#9  0x000009988cc9b8d1 in ?? ()
+#10 0x0000000000000000 in ?? ()
+(gdb) up
+#1  0xffffffff8118c689 in sys_getdents (fd=<optimized out>, dirent=0x1398c58, count=32768) at /home/teawater/kernel2/linux/fs/readdir.c:214
+214             error = vfs_readdir(file, filldir, &buf);
+(gdb) p buf
+$1 = {current_dir = 0x1398c58, previous = 0x0, count = 32768, error = 0}
+(gdb) p error
+$3 = -9
+(gdb) frame 0
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+24      {
+From this example, we can see some GDB commands that parse the the call stack:
+bt is the alias of GDB commands backtrace that print a backtrace of the entire stack: one line per frame for all frames in the stack.
+up n is move n frames up the stack. For positive numbers n, this advances toward the outermost frame, to higher frame numbers, to frames that have existed longer. n defaults to one.
+down n is move n frames down the stack. For positive numbers n, this advances toward the innermost frame, to lower frame numbers, to frames that were created more recently. n defaults to one. You may abbreviate down as do. 
+frame n is select frame number n. Recall that frame zero is the innermost (currently executing) frame, frame one is the frame that called the innermost one, and so on. The highest-numbered frame is the one for main. 
+You can see that when you use up, down or frame to the different calll stack frame, you can output the value of the arguments and local variables of different call stack frame.
+To get the more info about howto use GDB parse the call stack, please see http://sourceware.org/gdb/current/onlinedocs/gdb/Stack.html
+Collect stack of current function's caller with $_ret
+If you just want to collect stack of current function's caller, please use $_ret.
+Please note that set the tracepoint that collect $_ret cannot in the first address of function.
+For example:
+
+(gdb) list vfs_read
+360     }
+361     
+362     EXPORT_SYMBOL(do_sync_read);
+363     
+364     ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
+365     {
+366             ssize_t ret;
+367     
+368             if (!(file->f_mode & FMODE_READ))
+369                     return -EBADF;
+(gdb) trace 368
+Tracepoint 2 at 0xffffffff8117a244: file /home/teawater/kernel2/linux/fs/read_write.c, line 368.
+(gdb) actions 
+Enter actions for tracepoint 2, one per line.
+End with a line saying just "end".
+>collect $_ret
+>end
+(gdb) tstart 
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 2
+#0  vfs_read (file=0xffff880141c46000, buf=0x359bda0 <Address 0x359bda0 out of bounds>, count=8192, pos=0xffff88012fa49f48)
+    at /home/teawater/kernel2/linux/fs/read_write.c:368
+368             if (!(file->f_mode & FMODE_READ))
+(gdb) bt
+#0  vfs_read (file=0xffff880141c46000, buf=0x359bda0 <Address 0x359bda0 out of bounds>, count=8192, pos=0xffff88012fa49f48)
+    at /home/teawater/kernel2/linux/fs/read_write.c:368
+#1  0xffffffff8117a3ea in sys_read (fd=<optimized out>, buf=<unavailable>, count=<unavailable>)
+    at /home/teawater/kernel2/linux/fs/read_write.c:469
+Backtrace stopped: not enough registers or memory available to unwind further
+(gdb) up
+#1  0xffffffff8117a3ea in sys_read (fd=<optimized out>, buf=<unavailable>, count=<unavailable>)
+    at /home/teawater/kernel2/linux/fs/read_write.c:469
+469                     ret = vfs_read(file, buf, count, &pos);
+(gdb) p ret
+$2 = -9
+You see that the caller of function vfs_read is sys_read. And the local variable ret of sys_read is -9.
+
+Use $dump_stack to output stack dump through printk
+Because this way need parse the stack when tracing and call printk inside, so it will be slow, unsafe, unclear and cannot access a lot of info of call stack. So I suggest you use the prev way to do stack dump.
+KGTP has special trace state variable $dump_stack, "collect" it will let Linux Kernel output stack dump through printk.
+Following example lets Linux Kernel show the stack dump of vfs_readdir:
+
+target remote /sys/kernel/debug/gtp
+trace vfs_readdir
+  commands
+    collect $dump_stack
+  end
+Then your kernel will printk like:
+
+[22779.208064] gtp 1:Pid: 441, comm: python Not tainted 2.6.39-rc3+ #46
+[22779.208068] Call Trace:
+[22779.208072]  [<fe653cca>] gtp_get_var+0x4a/0xa0 [gtp]
+[22779.208076]  [<fe653d79>] gtp_collect_var+0x59/0xa0 [gtp]
+[22779.208080]  [<fe655974>] gtp_action_x+0x1bb4/0x1dc0 [gtp]
+[22779.208084]  [<c05b6408>] ? _raw_spin_unlock+0x18/0x40
+[22779.208088]  [<c023f152>] ? __find_get_block_slow+0xd2/0x160
+[22779.208091]  [<c01a8c56>] ? delayacct_end+0x96/0xb0
+[22779.208100]  [<c023f404>] ? __find_get_block+0x84/0x1d0
+[22779.208103]  [<c05b6408>] ? _raw_spin_unlock+0x18/0x40
+[22779.208106]  [<c02e0838>] ? find_revoke_record+0xa8/0xc0
+[22779.208109]  [<c02e0c45>] ? jbd2_journal_cancel_revoke+0xd5/0xe0
+[22779.208112]  [<c02db51f>] ? __jbd2_journal_temp_unlink_buffer+0x2f/0x110
+[22779.208115]  [<fe655c4c>] gtp_kp_pre_handler+0xcc/0x1c0 [gtp]
+[22779.208118]  [<c05b8a88>] kprobe_exceptions_notify+0x3d8/0x440
+[22779.208121]  [<c05b7d54>] ? hw_breakpoint_exceptions_notify+0x14/0x180
+[22779.208124]  [<c05b95eb>] ? sub_preempt_count+0x7b/0xb0
+[22779.208126]  [<c0227ac5>] ? vfs_readdir+0x15/0xb0
+[22779.208128]  [<c0227ac4>] ? vfs_readdir+0x14/0xb0
+[22779.208131]  [<c05b9743>] notifier_call_chain+0x43/0x60
+[22779.208134]  [<c05b9798>] __atomic_notifier_call_chain+0x38/0x50
+[22779.208137]  [<c05b97cf>] atomic_notifier_call_chain+0x1f/0x30
+[22779.208140]  [<c05b980d>] notify_die+0x2d/0x30
+[22779.208142]  [<c05b71c5>] do_int3+0x35/0xa0
+Howto let tracepoint output value directly
+In the previous parts, you may understand that to get a value from Linux kernel, you need to use a tracepoint "collect" action to save the value to the tracepoint frame and use the GDB command "tfind" to parse the value from the frame data.
+But we want get the value directly sometimes, so KGTP supports two ways to output values directly.
+
+Switch collect to output the value directly
+KGTP has special trace state variables $printk_level, $printk_format and $printk_tmp to support this function.
+$printk_level: if its value is 8 (this is the default value), "collect" action will save value to the tracepoint frame in the simple behavior.
+If its value is 0-7, "collect" will output the value through "printk" directly, and value will be the level of printk. The level is:
+
+0       KERN_EMERG      system is unusable
+1       KERN_ALERT      action must be taken immediately
+2       KERN_CRIT       critical conditions
+3       KERN_ERR        error conditions
+4       KERN_WARNING    warning conditions
+5       KERN_NOTICE     normal but significant condition
+6       KERN_INFO       informational
+7       KERN_DEBUG      debug-level messages
+$printk_format, collect printk will output value in the format that is set by it. The format is:
+
+0       This is the default value.
+        If the size of collect value is 1, 2, 4 or 8, it will be output as an unsigned decimal.
+        If not, it will be output as a hexadecimal string.
+1       Output value in signed decimal.
+2       Output value in unsigned decimal.
+3       Output value in unsigned hexadecimal.
+4       Output value as a string.
+5       Output value as a hexadecimal string.
+$printk_tmp, to output the value of global variable need set to it first.
+
+Following example shows a count number, pid, jiffies_64 and the file name that call vfs_readdir:
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) tvariable $c
+(gdb) trace vfs_readdir
+(gdb) actions
+>teval $printk_level=0
+>collect $c=$c+1
+>collect ((struct task_struct *)$current_task)->pid
+>collect $printk_tmp=jiffies_64
+>teval $printk_format=4
+>collect file->f_path.dentry->d_iname
+>end
+Then your kernel will printk like:
+
+gtp 1:$c=$c+1=41
+gtp 1:((struct task_struct *)$current_task)->pid=12085
+gtp 1:$printk_tmp=jiffies_64=4322021438
+gtp 1:file->f_path.dentry->d_iname=b26
+gtp 1:$c=$c+1=42
+gtp 1:((struct task_struct *)$current_task)->pid=12085
+gtp 1:$printk_tmp=jiffies_64=4322021438
+gtp 1:file->f_path.dentry->d_iname=b26
+"gtp 1" means that it was output by tracepoint 1.
+
+Howto use watch tracepoint control hardware breakpoints to record memory access
+Watch tracepoint can control hardware breakpoints to record the memory access through set some special trace state variables in its action.
+Please note that watch tracepoint is just support by X86 and X86_64 now. And dynamic watch tracepoint just can work OK in Linux 2.6.27 and newer version because Linux 2.6.26 and older version have some IPI issues on smp support.
+
+Trace state variables of watch tracepoint
+Name	Written by normal tracepoint	Read by normal tracepoint	Written by static watch tracepoint	Read by static watch tracepoint	Written by dynamic watch tracepoint	Read by dynamic watch tracepoint
+$watch_static	 Not support	 Not support	 If "teval $watch_static=1", then this tracepoint is static watch tracepoint.	 Not support	 If "teval $watch_static=1", then this tracepoint is static watch tracepoint.	 Not support
+$watch_set_id	 When this tracepoint want to setup a dynamic watch tracepoint, set a id of a dynamic watch tracepoint to $watch_set_id to point out which dynamic watch tracepoint you wan to setup.	 Not support	 Not support	 Not support	 Not support	 Not support
+$watch_set_addr	 When this tracepoint want to setup a dynamic watch tracepoint, set the address of a dynamic watch tracepoint to $watch_set_addr to point out which dynamic watch tracepoint you wan to setup.	 Not support	 Not support	 Not support	 Not support	 Not support
+$watch_type	 When this tracepoint want to setup a dynamic watch tracepoint, set the watch type of this dynamic watch tracepoint to $watch_type.
+0 is exec. 1 is write. 2 is read or write.	 Get the value that this tracepoint set to $watch_type.	 Set the type of this watch tracepoint.	 Get the type of this watch tracepoint.	 Set the default type of this watch tracepoint.	 Get the type of this watch tracepoint when it really exec.
+$watch_size	 When this tracepoint want to setup a dynamic watch tracepoint, set the watch size of this dynamic watch tracepoint to $watch_size.
+The size should be 1, 2, 4, 8.	 Get the value that this tracepoint set to $watch_size.	 Set the size of this watch tracepoint.	 Get the size of this watch tracepoint.	 Set the default size of this watch tracepoint.	 Get the size of this watch tracepoint when it really exec.
+$watch_start	 Set the address to a dynamic watch tracepoint(set by $watch_set_addr or $watch_set_id) and let it try to start work.	 Get the result of this start. (It will fail becasue X86 just have 4 hardware breakpoints.)
+Get 0 if success. If < 0 is the error id.	 Not support	 Not support	 Not support	 Not support
+$watch_stop	 Set a address to $watch_stop will let a dynamic watch tracepoint that watch in this address stop.	 Get the result of this stop.	 Not support	 Not support	 Not support	 Not support
+$watch_trace_num	 Not support	 Not support	 Not support	 Not support	 Not support	 The tracepoint number that setup this dynamic watch tracepoint.
+$watch_trace_addr	 Not support	 Not support	 Not support	 Not support	 Not support	 The tracepoint address that setup this dynamic watch tracepoint.
+$watch_addr	 Not support	 Not support	 Not support	 The address that this watch tracepoint is watching.	 Not support	 The address that this watch tracepoint is watching.
+$watch_val	 Not support	 Not support	 Not support	 The value of the memory that this watch tracepoint is watching.	 Not support	 The value of the memory that this watch tracepoint is watching.
+$watch_count	 Not support	 Not support	 Not support	 Not support	 Not support	 A special count for this watch tracepoint session.
+Static watch tracepoint
+You can use static watch tracepoint when you want watch value of a global variable or some memory that you can get its address directly. Following example is watch jiffies_64's write:
+
+#Static watch tracepoint get watch address from tracepoint address.
+trace *&jiffies_64
+  actions
+    #Set this watch tracepoint to static
+    teval $watch_static=1
+    #Watch memory write
+    teval $watch_type=1
+    teval $watch_size=8
+    collect $watch_val
+    collect $bt
+  end
+Dynamic watch tracepoint
+If you want to watch value of a local variable or some memory that you just get get its address inside the function, you can use dynamic watch tracepoint. Following example is watch write of f->f_pos and f->f_op inside function get_empty_filp:
+
+trace *1
+  commands
+    teval $watch_static=0
+    teval $watch_type=1
+    teval $watch_size=8
+    collect $bt
+    collect $watch_addr
+    collect $watch_val
+  end
+Define a dynamic watch tracepoint. The address "1" of it is not the address of memory that it will watch. It just help tracepoint that setup this dynamic watch tracepoint can find it.
+
+list get_empty_filp
+trace 133
+  commands
+    teval $watch_set_addr=1
+    teval $watch_size=4
+    teval $watch_start=&(f->f_pos)
+    teval $watch_size=8
+    teval $watch_start=&(f->f_op)
+  end
+Define a normal tracepoint that start to watch f->f_pos and f->f_op inside function get_empty_filp.
+
+trace file_sb_list_del
+  commands
+    teval $watch_stop=&(file->f_pos)
+    teval $watch_stop=&(file->f_op)
+  end
+Define a normal tracepoint that stop the tracepoint that watch file->f_pos and file->f_op.
+
+Use while-stepping let Linux kernel do single step
+Please note that while-stepping is just support by X86 and X86_64 now.
+
+Howto use while-stepping
+while-stepping is a special tracepoint action that include some actions with it.
+When tracepoints that its actions include "while-stepping n" execute, it will do n times single steps and executes the actions of while-stepping. For example:
+
+trace vfs_read
+#Because single step will make system slow, so use passcount or condition to limit the execution times of tracepoint is better.
+passcount 1
+  commands
+    collect $bt
+    collect $step_count
+    #do 2000 times single steps.
+    while-stepping 2000
+      #Following part is actions of "while-stepping 2000".
+      #Because step maybe execute to other functions, so does not access local variables is better.
+      collect $bt
+      collect $step_count
+    end
+  end
+Please note that tracepoint will disable the interrupt of current CPU when it do single step. Access $step_count in actions will get the count of this step that begin with 1.
+
+Read the traceframe of while-stepping
+The data of different step that is recorded by while-stepping actions will be saved in different traceframe that you can use tfind (#Use_tfind_select_the_entry_inside_the_trace_frame_info) to select them.
+Or you can switch KGTP to replay mode to select all the traceframe of a while-stepping tracepoint with GDB execution and reverse-execution commands. For example:
+Use tfind select one the traceframe of a while-stepping tracepoint.
+
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+Following commands will swith KGTP to replay mode.
+
+(gdb) monitor replay
+(gdb) tfind -1
+No longer looking at any trace frame
+#0  vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+Then you can use execution commands.
+
+(gdb) n
+368             if (!(file->f_mode & FMODE_READ))
+(gdb) p file->f_mode
+$5 = 3
+Set breakpoints (Just valid in replay mode, will not affect Linux kernel execution).
+
+(gdb) b 375
+Breakpoint 2 at 0xffffffff81179b75: file /build/buildd/linux-3.2.0/fs/read_write.c, line 375.
+(gdb) c
+Continuing.
+
+Breakpoint 2, vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:375
+375             ret = rw_verify_area(READ, file, pos, count);
+(gdb) s
+rw_verify_area (read_write=0, file=0xffff8801f7bd4c00, ppos=0xffff8801f4b45f48, count=16)
+    at /build/buildd/linux-3.2.0/fs/read_write.c:300
+300             inode = file->f_path.dentry->d_inode;
+Use reverse-execution commands.
+
+(gdb) rs
+
+Breakpoint 2, vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:375
+375             ret = rw_verify_area(READ, file, pos, count);
+(gdb) rn
+372             if (unlikely(!access_ok(VERIFY_WRITE, buf, count)))
+GDB commands tstart, tfind or quit can auto close the replay mode.
+
+Howto show a variable whose value has been optimized away
+Sometimes, GDB will output some value like:
+
+inode has been optimized out of existence.
+res has been optimized out of existence.
+That is because value of inode and res is optimized. Linux Kernel is built with -O2 so you will get this trouble sometimes.
+There are 2 ways to handle it:
+
+Update your GCC
+The VTA branch http://gcc.gnu.org/wiki/Var_Tracking_Assignments was merged for GCC 4.5. This helps a lot with generating dwarf for previously "optimized out" values.
+
+How to get the function pointer point to
+If the debug info of the function pointer is not optimized out
+You can collect it directly and print what it point to. For example:
+
+377                     count = ret;
+378                     if (file->f_op->read)
+379                             ret = file->f_op->read(file, buf, count, pos);
+(gdb) 
+(gdb) trace 379
+Tracepoint 1 at 0xffffffff81173ba5: file /home/teawater/kernel/linux/fs/read_write.c, line 379.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect file->f_op->read
+>end
+(gdb) tstart
+(gdb) tstop
+(gdb) tfind
+(gdb) p file->f_op->read
+$5 = (ssize_t (*)(struct file *, char *, size_t, loff_t *)) 0xffffffff81173190 <do_sync_read>
+#Then you know file->f_op->read point to do_sync_read.
+If the debug info of the function pointer is optimized out
+You can use tracepoint step to handle it. For example:
+
+#Find out which instrunction that it is called.
+(gdb) disassemble /rm vfs_read
+379                             ret = file->f_op->read(file, buf, count, pos);
+   0xffffffff81173ba5 <+181>:   48 89 da        mov    %rbx,%rdx
+   0xffffffff81173ba8 <+184>:   4c 89 e9        mov    %r13,%rcx
+   0xffffffff81173bab <+187>:   4c 89 e6        mov    %r12,%rsi
+   0xffffffff81173bae <+190>:   4c 89 f7        mov    %r14,%rdi
+   0xffffffff81173bb1 <+193>:   ff d0   callq  *%rax
+   0xffffffff81173bb3 <+195>:   48 89 c3        mov    %rax,%rbx
+(gdb) trace *0xffffffff81173bb1
+Tracepoint 1 at 0xffffffff81173bb1: file /home/teawater/kernel/linux/fs/read_write.c, line 379.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>while-stepping 1
+ >collect $reg
+ >end
+>end
+(gdb) tstart 
+(gdb) tstop 
+(gdb) tfind 
+#0  tty_read (file=0xffff88006ca74900, buf=0xb6b7dc <Address 0xb6b7dc out of bounds>, count=8176, 
+    ppos=0xffff88006e197f48) at /home/teawater/kernel/linux/drivers/tty/tty_io.c:960
+960     {
+#Then you know file->f_op->read point to tty_read.
+Please note that while-stepping will make tracepoint cannot use kprobes-optimization.
+
+/sys/kernel/debug/gtpframe and offline debug
+/sys/kernel/debug/gtpframe supplies trace frame in tfile format (GDB can parse it) when KGTP is stop.
+In the PC that can run the GDB:
+Change the "target remote XXXX" to
+
+(gdb) target remote | perl ./getgtprsp.pl
+After that, set tracepoint and start it as usual:
+
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8114f3c0: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+#If your GDB support tracepoint "printf" (see "Howto use tracepoint printf"), use it to show the value directly is better.
+>collect $reg
+>end
+(gdb) tstart 
+(gdb) stop 
+(gdb) quit
+Then you can find files gtpstart and gtpstop in current directory. Copy it to the machine that you want to debug.
+
+In the debugged machine, copy the program "putgtprsp" and "gtp.ko" in the KGTP directory to this machine first. After insmod the gtp.ko:
+Start the tracepoint:
+
+./putgtprsp ./gtpstart
+Stop the tracepoint:
+
+./putgtprsp ./gtpstop
+You can let Linux Kernel show the value directly, please see HOWTO#Howto_let_tracepoint_output_value_directly.
+
+If you want to save the value to the trace frame and parse later, you can use file "/sys/kernel/debug/gtpframe" that has the trace frame. Copy it to the PC that has GDB. 
+Please note that some "cp" cannot handle it very well, please use "cat /sys/kernel/debug/gtpframe > ./gtpframe" to copy it.
+In the PC that can run the GDB:
+(gdb) target tfile ./gtpframe
+Tracepoint 1 at 0xffffffff8114f3dc: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+Created tracepoint 1 for target's tracepoint 1 at 0xffffffff8114f3c0.
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880036e8f300, filler=0xffffffff8114f240 <filldir>, buf=0xffff880001e5bf38)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+Please note that if you want connect KGTP from GDB in remote machine after use offline debug, you need "rmmod gtp" and "insmod gtp.ko" before call "nc".
+
+How to use /sys/kernel/debug/gtpframe_pipe
+This interface supplies same format trace frame with "gtpframe". But it can work when KGTP is running. After data is read, it will auto deleted from trace frame like "trace_pipe" of ftrace.
+
+Get the frame info with GDB
+#connect to the interface
+(gdb) target tfile /sys/kernel/debug/gtpframe_pipe
+#Get one trace frame entry
+(gdb) tfind 0
+Found trace frame 0, tracepoint 1
+#Get the next one
+(gdb) tfind 
+Target failed to find requested trace frame.
+(gdb) tfind 0
+Found trace frame 0, tracepoint 1
+This way is better to work with python to parse Kernel. add-ons/hotcode.py is an example of python script.
+
+Get the frame info with cat
+sudo cat /sys/kernel/debug/gtpframe_pipe > g
+Then all the trace frame will be saved in file "g".
+
+Get the frame info with getframe
+KGTP package include a program "getframe" can help you save the trace frame to files.
+Following part is the help of it:
+
+getframe -h
+Get the trace frame of KGTP and save them in current 
+directory with tfile format.
+Usage: ./getframe [option]
+
+  -g n    Set the minimum free size limit to n G.
+          When free size of current disk is smaller than n G,
+          ./getframe will exit (-q) or wait some seconds (-w).
+          The default value of it is 2 G.
+
+  -q      Quit when current disk is smaller than
+          minimum free size limit (-g).
+
+  -w n    Wait n seconds when current disk is smaller
+          than minimum free size limit (-g).
+
+  -e n    Set the entry number of each tfile to n.
+          The default value of it is 1000.
+
+  -h      Display this information.
+Use $pipe_trace
+For the lock safe, KGTP will ignore the task that read the /sys/kernel/debug/gtpframe_pipe in default.
+If you really need trace this task, and be sure that is safe. You can use following command before call "tstart":
+
+(gdb) tvariable $pipe_trace=1
+Then KGTP will not ignore the task that read /sys/kernel/debug/gtpframe_pipe.
+
+Use KGTP with user space program
+Read memory of user space program directly
+KGTP can read memory directly without stop this user space program. Please goto HOWTO#the_memory_of_the_user_space_program get how to do it.
+
+collect stack (for backtrace) of user space program in tracepoint
+$current_task_user is a special trace state variable that it is value will be true when current task is in user mode.
+$current is a special trace state variable that if the action of an tracepoint collect it, this tracepint will collect the values of the registers and the memory of current task.
+With these two trace state variables, you can use KGTP collect the stack(backtrace) of current task.
+Following example show how we do backtrace(stack dump) from user space to Linux kernel:
+
+#Connect to KGTP(same with prev section)
+(gdb) target extended-remote /sys/kernel/debug/gtp
+#Setup an tracepoint that collect the user space stack of task 18776.
+(gdb) trace vfs_read
+Tracepoint 1 at 0xffffffff8117a3d0: file /home/teawater/kernel/linux/fs/read_write.c, line 365.
+(gdb) condition 1 ($current_task_user && $current_task_pid == 18776)
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $current
+>collect $bt
+>end
+#Setup a tracepoint that collect kernel space stack of task 18776.
+(gdb) trace vfs_read
+Note: breakpoint 1 also set at pc 0xffffffff8117a3d0.
+Tracepoint 2 at 0xffffffff8117a3d0: file /home/teawater/kernel/linux/fs/read_write.c, line 365.
+(gdb) condition 2 ($current_task_user && $current_task_pid == 18776)
+(gdb) actions 
+Enter actions for tracepoint 2, one per line.
+End with a line saying just "end".
+>collect $bt
+>end
+(gdb) tstart
+(gdb) tstop
+#Following part is same with prev section, add a new inferior to parse info of the user space program.
+(gdb) add-inferior
+Added inferior 2
+(gdb) inferior 2
+[Switching to inferior 2 [<null>] (<noexec>)]
+(gdb) file gdb
+Reading symbols from /usr/local/bin/gdb...done.
+(gdb) attach 18776
+#tracepoint 1 collect the user space stack. 
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  0x00007f77331d7d0f in __read_nocancel () from /lib/x86_64-linux-gnu/libpthread.so.0
+#This is the user space backtrace of task 18776.
+(gdb) bt
+#0  0x00007f77331d7d0f in __read_nocancel () from /lib/x86_64-linux-gnu/libpthread.so.0
+#1  0x000000000078e145 in rl_callback_read_char () at ../../src/readline/callback.c:201
+#2  0x000000000069de79 in rl_callback_read_char_wrapper (client_data=<optimized out>) at ../../src/gdb/event-top.c:169
+#3  0x000000000069ccf8 in process_event () at ../../src/gdb/event-loop.c:401
+#4  process_event () at ../../src/gdb/event-loop.c:351
+#5  0x000000000069d448 in gdb_do_one_event () at ../../src/gdb/event-loop.c:465
+#6  0x000000000069d5d5 in start_event_loop () at ../../src/gdb/event-loop.c:490
+#7  0x0000000000697083 in captured_command_loop (data=<optimized out>) at ../../src/gdb/main.c:226
+#8  0x0000000000695d8b in catch_errors (func=0x697070 <captured_command_loop>, func_args=0x0, errstring=0x14df99e "", 
+    mask=6) at ../../src/gdb/exceptions.c:546
+#9  0x00000000006979e6 in captured_main (data=<optimized out>) at ../../src/gdb/main.c:1001
+#10 0x0000000000695d8b in catch_errors (func=0x697360 <captured_main>, 
+    func@entry=<error reading variable: PC not available>, func_args=0x7fff08afd5b0, 
+    func_args@entry=<error reading variable: PC not available>, errstring=<unavailable>, 
+    errstring@entry=<error reading variable: PC not available>, mask=<unavailable>, 
+    mask@entry=<error reading variable: PC not available>) at ../../src/gdb/exceptions.c:546
+#11 <unavailable> in ?? ()
+Backtrace stopped: not enough registers or memory available to unwind further
+#The tracepoint 2 collect the kernel space stack.  So swith to inferior 1 that load the kernel debug info.
+(gdb) tfind
+Found trace frame 1, tracepoint 2
+#0  0xffffffff8117a3d0 in ?? ()
+(gdb) inferior 1
+[Switching to inferior 1 [Remote target] (/home/teawater/kernel/b/vmlinux)]
+[Switching to thread 1 (Remote target)] 
+#0  vfs_read (file=0xffff88021a559500, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, count=1, 
+    pos=0xffff8800c47e1f48) at /home/teawater/kernel/linux/fs/read_write.c:365
+365     {
+#This is the backtrace of kernel stack.
+(gdb) bt
+#0  vfs_read (file=0xffff88021a559500, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, count=1, 
+    pos=0xffff8800c47e1f48) at /home/teawater/kernel/linux/fs/read_write.c:365
+#1  0xffffffff8117a59a in sys_read (fd=<optimized out>, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, 
+    count=1) at /home/teawater/kernel/linux/fs/read_write.c:469
+#2  <signal handler called>
+#3  0x00007f77331d7d10 in ?? ()
+#4  0x0000000000000000 in ?? ()
+How to use add-ons/hotcode.py
+This script can show the hottest code line in the Linux kernel or user space program through parse and record the pc address in the interrupt handler.
+Please goto http://code.google.com/p/kgtp/wiki/hotcode see howto use it.
+
+How to add plugin in C
+KGTP support plugin that write in C. The plugin will be built as LKM
+
+API
+#include "gtp.h"
+This header file include the API that plugin need. 
+
+extern int gtp_plugin_mod_register(struct module *mod);
+extern int gtp_plugin_mod_unregister(struct module *mod);
+These two functions register and unregister the plugin module. Then when KGTP will add module usage count when it access the resource of the plugin module. 
+
+extern struct gtp_var *gtp_plugin_var_add(char *name, int64_t val,
+                                          struct gtp_var_hooks *hooks);
+This function add special trace state variable to the KGTP.
+
+name is the name of special trace state variable.
+val is initialization value of special trace state variable.
+hooks is the function pointers. The function pointers can be set to NULL if this function doesn't support.
+Return the gtp_var pointer if success. Get error will return error code that IS_ERR and PTR_ERR can handle.
+
+
+struct gtp_var_hooks {
+        int     (*gdb_set_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+                               int64_t val);
+        int     (*gdb_get_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+                               int64_t *val);
+        int     (*agent_set_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+                                 int64_t val);
+        int     (*agent_get_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+                                 int64_t *val);
+};
+gdb_set_val will be called when GDB set the value of TSV. Please note that TSV just can be set by GDB command "tvariable $xxx=1" and the value just be sent to KGTP when GDB command "tstart".
+unused is unused. Just to make this pointer can share function with agent_set_val.
+var is the pointer that point to the gtp_var pointer. Then function of plugin can use it to figure out which TSV is accessed when TSVs share the function.
+val is the value that GDB set.
+Return return -1 if error. return 0 if success.
+gdb_get_val will be called when GDB get the value of TSV. Please note that TSV get is different with TSV set. It can be gotten from KGTP anytime. And get its value just like get the value of GDB internal value. For example: "p $xxx".
+unused is same with gdb_set_val.
+var is same with gdb_set_val.
+val is the pointer that use to return value.
+Return is same with gdb_set_val.
+agent_set_val will be called when tracepoint action(HOWTO#teval_expr1,_expr2,_...) set the value of TSV.
+gts is pointer to the tracepoint session struct.
+var is same with gdb_set_val.
+val is the value the action set.
+Return is same with gdb_set_val.
+agent_get_val will be called when tracepoint action(HOWTO#collect_expr1,_expr2,_... or HOWTO#teval_expr1,_expr2,_...) get the value of TSV.
+gts is same with agent_set_val.
+var is same with gdb_set_val.
+val is same with gdb_get_val.
+Return is same with gdb_set_val.
+
+
+extern int gtp_plugin_var_del(struct gtp_var *var);
+When rmmod the plugin module, use this function remove the TSV that gtp_plugin_var_add add. 
+
+Example
+plugin_example.c that in the KGTP directory is the example for KGTP plugin. You can use "make P=1" build it. It add 4 TSV to KGTP.
+
+$test1 support nothing.
+$test2 support be get and set by GDB or tracepoint action.
+$test3 just support tracepoint action set. When set a value to it, it will look up a kernel symbol of this value and print it. For example "teval $test3=(int64_t)$rip".
+$test4 just support tracepoint action set. When set a value to it, it will look up a kernel symbol of current tracepoint address and print it.
+How to use
+insmod KGTP module according to HOWTO#Exec_it.
+insmod plugin_example.ko
+Use GDB connect to KGTP and use it.
+Disconnect GDB. If option in HOWTO#Do_not_stop_tracepoint_when_the_GDB_disconnects set to on, set it to off.
+rmmod plugin_example.ko
+Please note that KGTP support add more than one plugin.
+
+How to use performance counters
+Performance counters are special hardware registers available on most modern CPUs. These registers count the number of certain types of hw events: such as instructions executed, cachemisses suffered, or branches mis-predicted - without slowing down the kernel or applications. These registers can also trigger interrupts when a threshold number of events have passed - and can thus be used to profile the code that runs on that CPU.
+The Linux Performance Counter subsystem called perf event can get the value of performance counter. You can access it through KGTP perf event trace state variables.
+Please goto read the file tools/perf/design.txt in Linux Kernel to get more info about perf event.
+
+Define a perf event trace state variable
+Access an performance counter need define following trace state variable:
+
+"pe_cpu_"+tv_name       Define the the CPU id of the performance counter.
+"pe_type_"+tv_name      Define the the type of the performance counter.
+"pe_config_"+tv_name    Define the the config of the performance counter.
+"pe_en_"+tv_name        This the switch to enable or disable the performance counter.
+                        The performance counter is disable in default.
+"pe_val_"+tv_name       Access this variable can get the value of the performance counter.
+Define a per_cpu perf event trace state variable
+Define a per_cpu perf event trace state variable is same with define HOWTO#Per_cpu_trace_state_variables.
+
+"p_pe_"+perf_event type+string+CPU_id
+Please note that if you define a per_cpu perf event trace state variable, you will not need define the cpu id("pe_cpu") because KGTP already get it.
+
+The perf event type and config
+The type of perf event can be:
+
+0       PERF_TYPE_HARDWARE
+1       PERF_TYPE_SOFTWARE
+2       PERF_TYPE_TRACEPOINT
+3       PERF_TYPE_HW_CACHE
+4       PERF_TYPE_RAW
+5       PERF_TYPE_BREAKPOINT
+If the type is 0(PERF_TYPE_HARDWARE), the config can be:
+
+0       PERF_COUNT_HW_CPU_CYCLES
+1       PERF_COUNT_HW_INSTRUCTIONS
+2       PERF_COUNT_HW_CACHE_REFERENCES
+3       PERF_COUNT_HW_CACHE_MISSES
+4       PERF_COUNT_HW_BRANCH_INSTRUCTIONS
+5       PERF_COUNT_HW_BRANCH_MISSES
+6       PERF_COUNT_HW_BUS_CYCLES
+7       PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
+8       PERF_COUNT_HW_STALLED_CYCLES_BACKEND
+
+If the type is 3(PERF_TYPE_HW_CACHE), the config need to divide to 3 parts: First one is cache id, it need be << 0 before set to config:
+
+0       PERF_COUNT_HW_CACHE_L1D
+1       PERF_COUNT_HW_CACHE_L1I
+2       PERF_COUNT_HW_CACHE_LL
+3       PERF_COUNT_HW_CACHE_DTLB
+4       PERF_COUNT_HW_CACHE_ITLB
+5       PERF_COUNT_HW_CACHE_BPU
+Second one is cache op id, it need be << 8 before set to config:
+
+0       PERF_COUNT_HW_CACHE_OP_READ
+1       PERF_COUNT_HW_CACHE_OP_WRITE
+2       PERF_COUNT_HW_CACHE_OP_PREFETCH
+Last one is cache op result id, it need be << 16 before set to config:
+
+0       PERF_COUNT_HW_CACHE_RESULT_ACCESS
+1       PERF_COUNT_HW_CACHE_RESULT_MISS
+If you want get the perf count of PERF_COUNT_HW_CACHE_L1I(1), PERF_COUNT_HW_CACHE_OP_WRITE(1) and PERF_COUNT_HW_CACHE_RESULT_MISS(1), you can use:
+
+(gdb) tvariable $pe_config_cache=1 | (1 << 8) | (1 << 16)
+tools/perf/design.txt in Linux Kernel have more info about type and config of perf event.
+
+Enable and disable all the perf event in a CPU with $p_pe_en
+I think the best way that count a part of code with performance counters is enable all the count in the begin of the code and disable all of them in the end. You can do it with "pe_en". But if you have a lot of perf event trace state variables. That will make the tracepoint action very big. $p_pe_en is for this issue. You can enable all the perf event trace state variables in current CPU with following action:
+
+>teval $p_pe_en=1
+Disable them with set $p_pe_en to 0.
+
+>teval $p_pe_en=0
+GDB scripts to help with set and get the perf event trace state variables
+Following is a GDB script define two commands dpe and spe to help define and show the perf event trace state variables.
+You can put it to the ~/.gdbinit or your tracepoint script. Then you can use this two commands in GDB directly.
+
+define dpe
+  if ($argc < 2)
+    printf "Usage: dpe pe_type pe_config [enable]\n"
+  end
+  if ($argc >= 2)
+    eval "tvariable $p_pe_val_%d%d_c",$arg0, $arg1
+    eval "tvariable $p_pe_en_%d%d_c",$arg0, $arg1
+    set $tmp=0
+    while $tmp<$cpu_number
+      eval "tvariable $p_pe_type_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg0
+      eval "tvariable $p_pe_config_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg1
+      eval "tvariable $p_pe_val_%d%d_c%d=0",$arg0, $arg1, $tmp
+      if ($argc >= 3)
+        eval "tvariable $p_pe_en_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg2
+      end
+      set $tmp=$tmp+1
+    end
+  end
+end
+
+document dpe
+Usage: dpe pe_type pe_config [enable]
+end
+
+define spe
+  if ($argc != 2 && $argc != 3)
+    printf "Usage: spe pe_type pe_config [cpu_id]\n"
+  end
+  if ($argc == 2)
+    set $tmp=0
+    while $tmp<$cpu_number
+      eval "printf \"$p_pe_val_%%d%%d_c%%d=%%ld\\n\",$arg0, $arg1, $tmp, $p_pe_val_%d%d_c%d", $arg0, $arg1, $tmp
+      set $tmp=$tmp+1
+    end
+  end
+  if ($argc == 3)
+    eval "printf \"$p_pe_val_%%d%%d_c%%d=%%ld\\n\",$arg0, $arg1, $tmp, $p_pe_val_%d%d_c%d", $arg0, $arg1, $arg2
+  end
+end
+
+document spe
+Usage: spe pe_type pe_config [cpu_id]
+end
+Following is an example to use it get the performance counters of function tcp_v4_rcv:
+
+#Connect to KGTP
+(gdb) target remote /sys/kernel/debug/gtp
+#Define 3 pe tvs for PERF_COUNT_HW_CPU_CYCLES, PERF_COUNT_HW_CACHE_MISSES and PERF_COUNT_HW_BRANCH_MISSES.
+(gdb) dpe 0 0
+(gdb) dpe 0 3
+(gdb) dpe 0 5
+#enable the performance counters of this CPU in the begin of this function.
+(gdb) trace tcp_v4_rcv
+(gdb) action
+>teval $p_pe_en=1
+>end
+#$kret make this hanler the end of function tcp_v4_rcv.
+(gdb) trace *(tcp_v4_rcv)
+(gdb) action
+>teval $kret=0
+#disable all performance counters of this CPU
+>teval $p_pe_en=0
+#Access the per cpu perf event tv will access to the current cpu pe tv.
+>collect $p_pe_val_00_0
+>collect $p_pe_val_03_0
+>collect $p_pe_val_05_0
+#Set all the pe tv to 0
+>teval $p_pe_val_00_0=0
+>teval $p_pe_val_03_0=0
+>teval $p_pe_val_05_0=0
+>end
+tstart
+#Wait some time that current pc receive some tcp package.
+(gdb) tstop
+(gdb) tfind
+(gdb) spe 0 0 $cpu_id
+$p_pe_val_00_2=12676
+(gdb) spe 0 3 $cpu_id
+$p_pe_val_03_2=7
+(gdb) spe 0 5 $cpu_id
+$p_pe_val_05_2=97
--- /dev/null
+++ b/Documentation/gtp/howtocn.txt
@@ -0,0 +1,1775 @@
+		Linux Kernel GDB tracepoint module (KGTP)
+		=========================================
+		By Hui Zhu <teawater@gmail.com>
+		https://code.google.com/p/kgtp/wiki/HOWTOCN
+
+Update in 2013-05-08
+
+什么是KGTP
+需要帮助或者汇报问题
+GDB调试普通程序和KGTP的区别表
+使用KGTP前的准备工作
+Linux内核
+如果你的系统内核是自己编译的
+如果你的系统内核是发行版自带的
+Ubuntu
+Fedora
+其他系统
+确定Linux内核调试镜像是正确的
+当前Linux内核调试镜像在哪
+使用/proc/kallsyms
+使用linux_banner
+处理不能在"/sys/"或者"/sys/kernel/debug/"找到任何文件的问题
+处理Linux内核调试镜像地址信息和Linux内核执行时不同的问题
+取得KGTP
+通过http下载KGTP
+通过svn下载KGTP
+配置KGTP
+编译KGTP
+普通编译
+用一些特殊选项编译KGTP
+安装和卸载 KGTP
+和DKMS一起使用KGTP
+使用KGTP Linux内核patch
+安装可以和KGTP一起使用的GDB
+如何使用
+执行
+让GDB连接到KGTP
+GDB在本地主机上
+如果GDB在远程主机上
+增加模块的符号信息到GDB
+如何使用getmod.py
+如何使用getmod
+在普通模式直接访问当前值
+Linux内核的内存
+用户程序的内存
+trace状态变量
+GDB tracepoint
+设置tracepint
+这个函数确实存在但是设置tracepoint到上面会失败如何处理
+如何设置条件tracepoint
+如何处理错误 "Unsupported operator (null) (52) in expression."
+actions [num]
+collect expr1, expr2, ...
+teval expr1, expr2, ...
+while-stepping n
+启动和停止 tracepoint
+Enable 和 disable tracepoint
+用tfind选择trace帧缓存里面的条目
+如何处理错误 "No such file or directory." 或者 "没有那个文件或目录."
+保存trace帧信息到一个文件中
+显示和存储tracepoint
+删除tracepoint
+用tracepoint从内核中某点取得寄存器信息
+用tracepoint从内核中某点取得变量的值
+显示当前这一条trace缓存里存储的所有信息
+取得 tracepoint 的状态
+设置trace缓存为循环缓存
+GDB断开的时候不要停止tracepoint
+kprobes-optimization和tracepoint的执行速度
+如果使用trace状态变量
+普通trace状态变量
+Per_cpu trace状态变量
+如何定义
+例子1
+例子2
+特殊trace状态变量 $current_task，$current_task_pid，$current_thread_info，$cpu_id，$dump_stack，$printk_level，$printk_format，$printk_tmp，$clock，$hardirq_count，$softirq_count 和 $irq_count
+特殊trace状态变量 $self_trace
+用$kret trace函数的结尾
+用 $ignore_error 和 $last_errno 忽略tstart的错误
+使用 $cooked_clock 和 $cooked_rdtsc 取得不包含KGTP运行时间的时间信息
+使用 $xtime_sec 和 $xtime_nsec 取得 timespec
+如何 backtrace (stack dump)
+通过$bt收集栈并用GDB命令backtrace进行分析
+用 $_ret 来取得当前函数的调用函数的栈
+用 $dump_stack 输出栈分析到printk里
+如何让tracepoint直接输出信息
+切换collect为直接输出数据
+如何用watch tracepoint控制硬件断点记录内存访问
+watch tracepoint的trace状态变量
+静态watch tracepoint
+动态watch tracepoint
+使用while-stepping让Linux内核做单步
+如何使用 while-stepping
+读while-stepping的traceframe
+如何显示被优化掉的变量值
+升级你的GCC
+如何取得函数指针指向的函数
+如果函数指针没有被优化掉
+如果函数指针被优化掉了
+/sys/kernel/debug/gtpframe和离线调试
+如何使用 /sys/kernel/debug/gtpframe_pipe
+用GDB读帧信息
+用cat读帧信息
+用getframe读帧信息
+使用 $pipe_trace
+和用户层程序一起使用KGTP
+直接读用户层程序的内存
+在tracepoint收集用户层程序的栈信息(可用来做backtrace)
+如何使用 add-ons/hotcode.py
+如何增加用C写的插件
+API
+例子
+如何使用
+如何使用性能计数器
+定义一个perf event trace状态变量
+定义一个per_cpu perf event trace状态变量
+perf event的类型和配置
+用$p_pe_en打开和关闭一个CPU上所有的perf event
+用来帮助设置和取得perf event trace状态变量的GDB脚本
+什么是KGTP
+KGTP 是一个 灵活 轻量级 实时 Linux 调试器 和 跟踪器 。
+使用KGTP 不需要 在Linux内核上打PATCH或者重新编译，只要编译KGTP模块并insmod就可以。
+
+其让Linux内核提供一个远程GDB调试接口，于是在本地或者远程的主机上的GDB可以在不需要停止内核的情况下用GDB tracepoint和其他一些功能 调试 和 跟踪 Linux内核和应用程序。
+即使板子上没有GDB而且其没有可用的远程接口，KGTP也可以用离线调试的功能调试内核（见http://code.google.com/p/kgtp/wiki/HOWTOCN#/sys/kernel/debug/gtpframe和离线调试）。
+
+KGTP支持 X86-32 ， X86-64 ， MIPS 和 ARM 。
+KGTP在Linux内核 2.6.18到upstream 上都被测试过。
+而且还可以用在 Android 上 （见 HowToUseKGTPinAndroid）。
+
+KGTP新用户可以去看一下 Quickstart 。
+
+请到 UPDATE 去看KGTP的更新信息。
+
+需要帮助或者汇报问题
+你可以把问题发到 http://code.google.com/p/kgtp/issues/list 或者写信到 kgtp@freelists.org 或者写信到 teawater@gmail.com 。
+KGTP小组将尽全力帮助你。
+
+GDB调试普通程序和KGTP的区别表
+这个表是给在使用过GDB调试程序的人准备的，他可以帮助你理解和记住KGTP的功能。
+
+功能	GDB调试普通程序	GDB控制KGTP调试Linux内核
+准备工作	 系统里安装了GDB。
+程序用 "-g"选项编译。	 因为使用了一些GDB中的新功能，所以KGTP需要和GDB 7.3或者更新的版本。如果你的系统不提供这么新版本的GDB，你可以到http://code.google.com/p/gdbt/取得新版本GDB的静态编译版本，它可以在大部分Linux上使用。同时你可以在这里取得一步一步编译新版本GDB的介绍。
+你还需要做一些Linux内核和KGTP的准备工作，请到 http://code.google.com/p/kgtp/wiki/HOWTOCN#使用KGTP前的准备工作 取得如果做的介绍。
+Attach	 使用命令"gdb -p pid"或者GDB命令"attach pid"可以attach系统中的某个程序.	 需要先insmod gtp.ko，请看 https://code.google.com/p/kgtp/wiki/HOWTOCN#执行。
+然后让GDB连接KGTP,请看https://code.google.com/p/kgtp/wiki/HOWTOCN#让GDB连接到KGTP。
+请 注意 GDB连接到KGTP以后，Linux内核不会停止。
+Breakpoints	 GDB命令"b place_will_stop"，让程序在执行这个命令后执行，则程序将停止在设置这个断点的地方。	 KGTP不支持断点但是支持tracepoint。Tracepoints可以被看作一种特殊的断点。其可以设置在Linux kernel中的一些地方然后定义一些命令到它的action中。当tracepoint开始的时候，他们将会在内核执行到这些地方的时候执行这些命令。当tracepoint停止的时候，你可以像断点停止程序后你做的那样用GDB命令分析tracepoint得到的数据。 区别 是断点会停止程序但是KGTP中的tracepoint不会。 请到 https://code.google.com/p/kgtp/wiki/HOWTOCN#GDB_tracepoint 看如何使用它。
+读Memory	 GDB停止程序后(也许不需要)，它可以用GDB命令"print"或者"x"等应用程序的内存。	 你可以在tracepoint中设置特殊的action收集内存到traceframe中，在tracepoint停止后取得他们的值。https://code.google.com/p/kgtp/wiki/HOWTOCN#collect_expr1,_expr2,_... http://code.google.com/p/kgtp/wiki/HOWTOCN#用tfind选择trace帧缓存里面的条目 
+或者你可以在内核或者应用程序执行的时候直接读他们的内存。https://code.google.com/p/kgtp/wiki/HOWTOCN#在普通模式直接访问当前值
+Step 和 continue	 GDB可以用命令"continue"继续程序的执行，用CTRL-C停止其。	 KGTP不会停止Linux内核，但是tracepoint可以开始和停止。https://code.google.com/p/kgtp/wiki/HOWTOCN#启动和停止_tracepoint 
+或者用 while-stepping tracepoint记录一定次数的single-stepping然后让KGTP切换到回放模式。这样其就支持执行和方向执行命令了。 https://code.google.com/p/kgtp/wiki/HOWTOCN#使用while-stepping让Linux内核做单步
+Backtrace	 GDB可以用命令"backtrace"打印全部调用栈。	 KGTP也可以。https://code.google.com/p/kgtp/wiki/HOWTOCN#如何_backtrace_(stack_dump)
+Watchpoint	 GDB可以用watchpoint让程序在某些内存访问发生的时候停止。	 KGTP可以用watch tracepoint记录内存访问。 https://code.google.com/p/kgtp/wiki/HOWTOCN#如何用watch_tracepoint控制硬件断点记录内存访问
+调用函数	 GDB可以用命令"call function(xx,xx)"调用程序中的函数。	 KGTP可以用插件调用内核中的函数。https://code.google.com/p/kgtp/wiki/HOWTOCN#如何增加用C写的插件
+使用KGTP前的准备工作
+Linux内核
+如果你的系统内核是自己编译的
+要使用KGTP，你需要打开下面这些内核选项：
+
+General setup  --->
+        [*] Kprobes
+
+[*] Enable loadable module support  --->
+
+Kernel hacking  --->
+        [*] Debug Filesystem
+        [*] Compile the kernel with debug info
+如果你的系统内核是发行版自带的
+你需要安装一些Linux内核软件包。
+
+Ubuntu
+安装Linux内核调试镜像
+1) 增加调试源到Ubuntu源列表。
+
+在命令行按照下面的命令创建文件 /etc/apt/sources.list.d/ddebs.list：
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+稳定版本（不能是alpha或者betas）需要用命令行增加下面几行：
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-security main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+导入调试符号签名key：
+sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 428D7C01
+运行：
+sudo apt-get update
+
+2) 安装Linux内核调试镜像
+
+sudo apt-get install linux-image-$(uname -r)-dbgsym
+于是你可以在"/usr/lib/debug/boot/vmlinux-$(uname -r)"找到内核调试镜像。
+请 注意 当内核更新的时候这一步 安装Linux内核调试镜像 需要再做一次。
+
+安装内核头文件包
+sudo apt-get install linux-headers-generic
+安装内核源码
+安装源码包：
+sudo apt-get install linux-source
+解压缩源码：
+sudo mkdir -p /build/buildd/
+sudo tar vxjf /usr/src/linux-source-$(uname -r | sed 's/-.*//').tar.bz2 -C /build/buildd/
+sudo rm -rf /build/buildd/linux-$(uname -r | sed 's/-.*//')
+sudo mv /build/buildd/linux-source-$(uname -r | sed 's/-.*//') /build/buildd/linux-$(uname -r | sed 's/-.*//')
+请 注意 当内核更新的时候这一步 安装内核源码 需要再做一次。
+
+Fedora
+安装Linux内核调试镜像
+sudo yum --enablerepo=fedora-debuginfo install kernel-debuginfo
+于是你可以在"/usr/lib/debug/lib/modules/$(uname -r)/vmlinux"找到内核调试镜像。
+
+安装Linux内核开发包
+sudo yum install kernel-devel-$(uname -r)
+其他系统
+需要安装Linux内核调试镜像和Linux内核源码包。
+
+确定Linux内核调试镜像是正确的
+因为GDB从Linux内核调试镜像里取得地址信息和调试信息，所以使用正确的Linux内核调试镜像是非常重要的。所以在使用KGTP前，请先做检查。
+有2个方法进行检查，我建议2个方法都做一次来确保Linux内核调试镜像是正确的。 
+
+请 注意 如果你确定使用了正确的Linux内核调试镜像但是不能通过这个两个方法。请看 http://code.google.com/p/kgtp/wiki/HOWTOCN#处理Linux内核调试镜像地址信息和Linux内核执行时 。
+
+当前Linux内核调试镜像在哪
+在UBUNTU中，你可以在"/usr/lib/debug/boot/vmlinux-$(uname -r)"找到它。
+在Fedora中，你可以在"/usr/lib/debug/lib/modules/$(uname -r)/vmlinux"找到它。
+如果你自己编译的内核，你可以在内核编译目录找到vmlinux文件。
+
+使用/proc/kallsyms
+在运行着要trace的内核的系统上，用下面的命令取得sys_read和sys_write的地址：
+
+sudo cat /proc/kallsyms | grep sys_read
+ffffffff8117a520 T sys_read
+sudo cat /proc/kallsyms | grep sys_write
+ffffffff8117a5b0 T sys_write
+于是我们就可以得到sys_read的地址是0xffffffff8117a520，sys_write的地址是0xffffffff8117a5b0。
+之后我们用GDB从Linux内核调试镜像中取得sys_read和sys_write的地址：
+
+gdb ./vmlinux
+(gdb) p sys_read
+$1 = {long int (unsigned int, char *, size_t)} 0xffffffff8117a520 <sys_read>
+(gdb) p sys_write
+$2 = {long int (unsigned int, const char *, size_t)} 0xffffffff8117a5b0 <sys_write>
+sys_read和sys_write的地址一样，所以Linux内核调试镜像是正确的。
+
+使用linux_banner
+sudo gdb ./vmlinux
+(gdb) p linux_banner
+$1 = "Linux version 3.4.0-rc4+ (teawater@teawater-Precision-M4600) (gcc version 4.6.3 (GCC) ) #3 SMP Tue Apr 24 13:29:05 CST 2012\n"
+linux_banner是Linux内核调试镜像里的内核信息。
+之后，根据 http://code.google.com/p/kgtp/wiki/HOWTOCN#让GDB连接到KGTP 里的方法连接到KGTP上并再次打印linux_banner。
+
+(gdb) target remote /sys/kernel/debug/gtp
+Remote debugging using /sys/kernel/debug/gtp
+0x0000000000000000 in irq_stack_union ()
+(gdb) p linux_banner
+$2 = "Linux version 3.4.0-rc4+ (teawater@teawater-Precision-M4600) (gcc version 4.6.3 (GCC) ) #3 SMP Tue Apr 24 13:29:05 CST 2012\n"
+这个linux_banner是KGTP正在trace的内核的内核信息，如果相同，则Linux内核调试镜像是正确的。
+
+处理不能在"/sys/"或者"/sys/kernel/debug/"找到任何文件的问题
+因为KGTP的接口是"/sys/kernel/debug/gtp"，所以如果"/sys/"或者"/sys/kernel/debug/"中找不到任何文件则KGTP将不能使用。
+
+如果你有这个问题，请先确定你的内核config打开了"Debug Filesystem"。http://code.google.com/p/kgtp/wiki/HOWTOCN#如果你的系统内核是自己编译的
+
+如果它以及被打开了，请用下面命令mount sysfs。
+
+sudo mount -t sysfs none /sys/
+然后你就能在"/sys/"找到文件。 
+
+请用下面命令mount debugfs。
+
+mount -t debugfs none /sys/kernel/debug/
+然后你就能在"/sys/kernel/debug/"找到文件。 
+
+处理Linux内核调试镜像地址信息和Linux内核执行时不同的问题
+在X86_32上，用 http://code.google.com/p/kgtp/wiki/HOWTOCN#确定Linux内核调试镜像是正确的 介绍的方法发现Linux内核调试镜像地址信息和Linux内核执行时不同，而且确定使用的Linux内核调试镜像是正确的。
+这个问题是因为：
+
+Processor type and features  --->
+        (0x1000000) Physical address where the kernel is loaded
+        (0x100000) Alignment value to which kernel should be aligned
+这个两个参数的值不同。请 注意 "Physical address where the kernel is loaded" 有时不会在配置的时候显示，你可以通过搜索 "PHYSICAL_START" 取得它的值。
+
+你可以通过修改 "Alignment value to which kernel should be aligned" 的值和 "Physical address where the kernel is loaded" 来处理这个问题。
+这个问题不影响X86_64。
+
+取得KGTP
+通过http下载KGTP
+请到 http://code.google.com/p/kgtp/downloads/list 或者 UPDATE 去下载源码包。
+
+通过svn下载KGTP
+有些人访问KGTP站点有问题，你可以通过svn访问KGTP。
+
+svn checkout http://kgtp.googlecode.com/svn/ kgtp-read-only
+kgtp-read-only/tags/ 这里是KGTP每个发布的版本。
+kgtp-read-only/trunk/ 这里是KGTP的主干。
+
+配置KGTP
+下面这部分是在KGTP Makefile里的配置。用这个配置，KGTP将自动和当前系统的内核一起编译。
+
+KERNELDIR := /lib/modules/`uname -r`/build
+CROSS_COMPILE :=
+KERELDIR 设置了你要一起编译的内核，默认情况下，KGTP会和当前的内核一起编译。
+请 注意 这个目录应该是内核编译目录或者linux-headers目录，而不是内核源码目录。内核编译目录只有在编译成功后才能使用。
+CROSS_COMPILE 设置编译KGTP的编译器前缀名。留空则使用默认编译器。
+ARCH 是体系结构。
+
+或者你可以通过修改KGTP目录里的Makefile选择你要和哪个内核一起编译以及你用什么编译器编译KGTP。
+例如：
+
+KERNELDIR := /home/teawater/kernel/bamd64
+CROSS_COMPILE :=x86_64-glibc_std-
+ARCH := x86_64
+KERNELDIR 设置为 /home/teawater/kernel/bamd64。 Compiler 设置为 x86_64-glibc_std-gcc。
+
+编译KGTP
+普通编译
+cd kgtp/
+make
+在一些编译环境中(例如Android)将出现一些编译应用程序getmod或者getframe的错误。请忽略这些错误并使用目录中的gtp.ko。
+
+用一些特殊选项编译KGTP
+大部分时候，KGTP可以自动选择正确的参数和和各种版本的Linux内核一起编译。
+但是如果你想配置一些特殊选项，可以按照下面的介绍来做：
+用这个选项，KGTP将不自动选择任何编译选项。
+
+make AUTO=0
+用这个选项，KGTP将使用简单frame替代KGTP ring buffer。
+简单frame不支持gtpframe_pipe，它现在只用来调试KGTP。
+
+make AUTO=0 FRAME_SIMPLE=1
+用这个选项，$clock将返回rdtsc的值而不是local_clock。
+
+make AUTO=0 CLOCK_CYCLE=1
+用这个选项，KGTP可以用procfs替代debugfs。
+
+make AUTO=0 USE_PROC=1
+这些选线可以一起使用，例如：
+
+make AUTO=0 FRAME_SIMPLE=1 CLOCK_CYCLE=1
+安装和卸载 KGTP
+因为KGTP可以直接在编译目录里insmod，所以不编译后不安装也可以直接使用（见 http://code.google.com/p/kgtp/wiki/HOWTOCN#执行）。但是如果需要也可以将其安装到系统中。 安装：
+
+cd kgtp/
+sudo make install
+卸载：
+
+cd kgtp/
+sudo make uninstall
+和DKMS一起使用KGTP
+如果你需要的话，你还可以让DKMS来使用KGTP。
+下面的命令将拷贝KGTP的文件到DKMS需要的目录中。
+
+cd kgtp/
+sudo make dkms
+于是你可以用DKMS命令控制KGTP。请到 http://linux.dell.com/dkms/manpage.html 去看如何使用DKMS。
+
+使用KGTP Linux内核patch
+大多数时候，你不需要KGTP patch，因为KGTP以一个LKM的形式编译安装更为方便。但是为了帮助人们集成KGTP到他们自己的内核树，KGTP也提供了patch. 在KGTP目录中：
+gtp_3.7_to_upstream.patch 是给Linux kernel 从3.7到upstream的patch。
+gtp_3.0_to_3.6.patch 是给Linux kernel 从3.0到3.6的patch。
+gtp_2.6.39.patch 是给Linux kernel 2.6.39的patch。
+gtp_2.6.33_to_2.6.38.patch 是给Linux kernel 从2.6.33到2.6.38的patch。
+gtp_2.6.20_to_2.6.32.patch 是给Linux kernel 从2.6.20到2.6.32的patch。
+gtp_older_to_2.6.19.patch 是给Linux kernel 2.6.19以及更早版本的patch。
+安装可以和KGTP一起使用的GDB
+早于7.3版本的GDB的tracepoint功能有一些bug，而且还有一些功能做的不是很好。
+所以如果你的GDB小于7.3请到 https://code.google.com/p/gdbt/ 去安装可以和KGTP一起使用的GDB。 如果你有GDB的问题，请根据这里的信息http://code.google.com/p/kgtp/wiki/HOWTOCN#需要帮助或者汇报问题取得帮助。
+
+如何使用
+执行
+如果你已经安装了KGTP在你的系统中，你可以：
+
+sudo modprobe gtp
+或者你可以直接使用KGTP目录里的文件：
+
+cd kgtp/
+sudo insmod gtp.ko
+让GDB连接到KGTP
+请 注意 让GDB打开正确的vmlinux文件非常重要。请到 http://code.google.com/p/kgtp/wiki/HOWTOCN#确定Linux内核调试镜像是正确的 去看下如何做。
+
+GDB在本地主机上
+sudo gdb ./vmlinux
+(gdb) target remote /sys/kernel/debug/gtp
+Remote debugging using /sys/kernel/debug/gtp
+0x0000000000000000 in ?? ()
+然后你就可以用GDB命令调试和跟踪Linux内核了。
+
+如果GDB在远程主机上
+#在当前主机打开KGTP
+sudo su
+nc -l 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp
+(nc -l -p 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp for old version netcat.)
+#让GDB连接1234端口
+gdb ./vmlinux
+(gdb) target remote xxx.xxx.xxx.xxx:1234
+然后你就可以用GDB命令调试和跟踪Linux内核了。
+
+增加模块的符号信息到GDB
+有时你需要添加一个Linux内核模块的符号信息到GDB好调试其。
+手动增加符号信息不太容易，所以KGTP包里包含了GDB Python脚本"getmod.py"和程序"getmod"可以帮到你。
+
+如何使用getmod.py
+在使用getmod.py前连接到KGTP。
+
+(gdb) source ~/kgtp/getmod.py
+于是这个脚本将自动装载Linux内核模块到GDB中。
+
+如何使用getmod
+"getmod" 是用C写的所以你可以把它用在任何地方即使是一个嵌入式环境。
+例如：
+
+#下面的命令将把Linux内核模块信息以GDB命令的格式保存到文件~/tmp/mi。
+sudo getmod >~/tmp/mi
+#在GDB那边：
+(gdb) source ~/tmp/mi
+add symbol table from file "/lib/modules/2.6.39-rc5+/kernel/fs/nls/nls_iso8859-1.ko" at
+        .text_addr = 0xf80de000
+        .note.gnu.build-id_addr = 0xf80de088
+        .exit.text_addr = 0xf80de074
+        .init.text_addr = 0xf8118000
+        .rodata.str1.1_addr = 0xf80de0ac
+        .rodata_addr = 0xf80de0c0
+        __mcount_loc_addr = 0xf80de9c0
+        .data_addr = 0xf80de9e0
+        .gnu.linkonce.this_module_addr = 0xf80dea00
+#这条GDB命令后，所有Linux内核模块信息都被装载进GDB了。
+#After this GDB command, all the Linux Kernel module info is loaded into GDB.
+如果你使用远程调试或者离线调试，你可以需要修改基本目录。下面是一个例子：
+
+#/home/teawater/kernel/b26是GDB所在主机上内核模块所在的路径
+sudo ./getmod -r /home/teawater/kernel/b26 >~/tmp/mi
+在普通模式直接访问当前值
+在GDB连到KGTP上以后，如果没有用GDB命令"tfind"选择一条trace帧缓存里面的条目，GDB就处于 普通模式。于是你可以直接访问内存(Linux内核或者用户程序)的值和trace状态变量的值。
+如果你选择了一个trace帧条目，可以用GDB命令"tfind -1"返回到普通模式。请到http://code.google.com/p/kgtp/wiki/HOWTOCN#用tfind选择trace帧缓存里面的条目取得GDB命令"tfind"的更多信息。
+
+Linux内核的内存
+例如你可以用下面的命令访问"jiffies_64"：
+
+(gdb) p jiffies_64
+或者你可以用下面的命令访问"static LIST_HEAD(modules)"的第一条记录：
+
+(gdb) p *((struct module *)((char *)modules->next - ((size_t) &(((struct module *)0)->list))))
+或者你可以访问"DEFINE_PER_CPU(struct device *, mce_device);"CPU0的数据：
+
+p *(struct device *)(__per_cpu_offset[0]+(uint64_t)(&mce_device))
+如果想在用一个GDB命令显示多个变量，请使用下面的例子：
+
+(gdb) printf "%4d %4d %4d %4d %4d %4d %18d %lu\n", this_rq->cpu, this_rq->nr_running, this_rq->nr_uninterruptible, nr_active, calc_load_tasks->counter, this_rq->calc_load_active, delta, this_rq->calc_load_update
+2 1 0 0 0 0 673538312 717077240
+用户程序的内存
+KGTP可以不同停止应用层程序的情况下直接读取其内存，例如：
+
+#连接KGTP(这里和前面介绍的连接方法不同)
+(gdb) target extended-remote /sys/kernel/debug/gtp
+#增加一个新的inferior用来分析应用程序的信息。
+(gdb) add-inferior
+Added inferior 2
+#切换到这个inferior
+(gdb) inferior 2
+[Switching to inferior 2 [<null>] (<noexec>)]
+#转载这个程序的符号文件
+(gdb) file ~/kernel/svn/bak/a.out
+Reading symbols from /home/teawater/kernel/svn/bak/a.out...done.
+#attach到这个进程上(这不会停止这个程序)。
+(gdb) attach 10039
+Attaching to program: /home/teawater/kernel/svn/bak/a.out, Remote target
+Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...(no debugging symbols found)...done.
+Loaded symbols for /lib/x86_64-linux-gnu/libc.so.6
+Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
+Loaded symbols for /lib64/ld-linux-x86-64.so.2
+0x0000000000000000 in ?? ()
+#于是可以读这个程序的内存
+(gdb) p c
+$3 = -1222013392
+(gdb) p c
+$4 = -590910451
+在这个例子中，我使用了一个多inferior命令。请到 http://sourceware.org/gdb/current/onlinedocs/gdb/Inferiors-and-Programs.html 去取得其更多相关信息。
+
+trace状态变量
+你可以使用和访问内存一样的命令访问TSV。 请到 http://code.google.com/p/kgtp/wiki/HOWTOCN#如果使用trace状态变量 取得更多TSV的信息。
+
+GDB tracepoint
+tracepoint就是GDB定义一些地址和一些动作。在tracepoint启动之后，当Linux内核执行到那些地址的时候，KGTP将执行这些动作(它们中的有些会收集数据并存入tracepoint帧缓冲)并把它们发给调试目标(KGTP)。而后，Linux内核将继续执行。
+KGTP提供了一些接口可以让GDB或者其他程序取出tracepoint帧缓冲的数据做分析。
+关于这些接口，文档前面已经介绍了"/sys/kernel/debug/gtp"，将在后面介绍"/sys/kernel/debug/gtpframe" 和 "/sys/kernel/debug/gtpframe_pipe"。
+
+GDB tracepoint文档在 http://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoints.html。
+
+设置tracepint
+trace命令非常类似break命令，它的参数可以是文件行，函数名或者一个地址。trace将定义一个或者多个地址定义一个tracepoint，KGTP将在这个点做一些动作。
+这是一些使用trace命令的例子：
+
+(gdb) trace foo.c:121    // 一个文件和行号
+
+(gdb) trace +2           // 2行以后
+
+(gdb) trace my_function  // 函数的第一行
+
+(gdb) trace *my_function // 函数的第一个地址
+
+(gdb) trace *0x2117c4    // 一个地址
+这个函数确实存在但是设置tracepoint到上面会失败如何处理
+GCC为了提高程序执行效率会inline一些static函数。因为目标文件没有inline函数的符号，所以你不能设置tracepoint在函数名上。
+你可以用"trace 文件:行号"在其上设置断点。
+
+如何设置条件tracepoint
+http://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Conditions.html
+和breakpoint一样，我们可以设置tracepoint的触发条件。而且因为条件检查是在KGTP执行的，所以速度比breakpoint的条件检查快很多。
+例如：
+
+(gdb) trace handle_irq if (irq == 47)
+tracepoint 1的动作将只在irq是47的时候才被执行。
+
+你还可以用GDB命令"condition"设置tracepoint的触发条件。GDB命令"condition N COND"将设置tracepoint N只有条件COND为真的时候执行。
+例如：
+
+(gdb) trace handle_irq
+(gdb) condition 1 (irq == 47)
+GDB命令"info tracepoint"将显示tracepoint的ID。
+
+$bpnum的值是最后一个GDB tracepoint的ID，所以你可以不取得tracepoint的ID就用condition来设置最后设置的tracepoint的条件，例如：
+
+(gdb) trace handle_irq
+(gdb) condition $bpnum (irq == 47)
+如何处理错误 "Unsupported operator (null) (52) in expression."
+如果你使用关于字符串的条件tracepoint，你在调用"tstart"的时候可能得到这个出错信息。
+你可以转化char为int来处理这个问题，例如：
+
+(gdb) p/x 'A'
+$4 = 0x41
+(gdb) condition 1 (buf[0] == 0x41)
+actions [num]
+这个命令将设置一组action当tracepoint num触发的时候执行。如果没有设置num则将设置action到最近创建的tracepoint上(因此你可以定义一个tracepoint然后直接输入actions而不需要参数)。然后就要在后面输入action，最后以end为结束。到目前为止，支持的action有collect，teval和while-stepping。
+
+collect expr1, expr2, ...
+当tracepoint触发的时候，收集表达式的值。这个命令可接受用逗号分割的一组列表，这些列表除了可以是全局，局部或者本地变量，还可以是下面的这些参数：
+
+$regs   收集全部寄存器。
+$args   收集函数参数。
+$locals 收集全部局部变量。
+请 注意 collect 一个指针(collect ptr)将只能collect这个指针的地址. 在指针前面增加一个 * 将会让action collect指针指向的数据(collect *ptr)。
+
+teval expr1, expr2, ...
+当tracepoint触发的时候，执行指定的表达式。这个命令可接受用逗号分割的一组列表。表达式的结果将被删除，所以最主要的作用是把值设置到trace状态变量中 (see http://code.google.com/p/kgtp/wiki/HOWTOCN#普通trace状态变量)，而不用想collect一样把这些值存到trace帧中。
+
+while-stepping n
+请到 https://code.google.com/p/kgtp/wiki/HOWTOCN#使用while-stepping让Linux内核做单步 去看如何使用它。
+
+启动和停止 tracepoint
+tracepoint只有在用下面的GDB命令启动后才可以执行action：
+
+(gdb) tstart
+它可以用下面的命令停止：
+
+(gdb) tstop
+Enable 和 disable tracepoint
+和breakpoint一样，tracepoint可以使用GDB命令 "enable" 和 "disable"。但是请 注意 它们只在tracepoint停止的时候有效。
+
+用tfind选择trace帧缓存里面的条目
+tracepoint停止的时候，GDB命令"tfind"可以用来选择trace帧缓存里面的条目。
+当GDB在"tfind"模式的时候，其只能显示tracepoint action collect的存在于这个条目中的数据。所以GDB将输出一些错误信息如果想打印没有collect的数据例如函数的参数。这不是bug，不用担心。
+如果想选择下一个条目，可以再次使用命令"tfind"。还可以用"tfind 条目ID"去选择某个条目。
+要回到普通模式(http://code.google.com/p/kgtp/wiki/HOWTOCN#在普通模式直接访问当前值)，请使用GDB命令"tfind -1"。 请到 http://sourceware.org/gdb/current/onlinedocs/gdb/tfind.html 取得它的详细信息。
+
+如何处理错误 "No such file or directory." 或者 "没有那个文件或目录."
+当GDB不能找到Linux内核源码的时候，其就会显示这个错误信息。 例如：
+
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_read (file=0xffff8801b6c3a500, buf=0x3f588b8 <Address 0x3f588b8 out of bounds>, count=8192, 
+    pos=0xffff8801eee49f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     /build/buildd/linux-3.2.0/fs/read_write.c: 没有那个文件或目录.
+你可以用GDB命令 "set substitute-path" 处理它。前面这个例子Linux内核源码在"/build/buildd/test/linux-3.2.0/"但是vmlinux让GDB在"/build/buildd/linux-3.2.0/"找内核远啊，你可以处理他们：
+
+(gdb) set substitute-path /build/buildd/linux-3.2.0/ /build/buildd/test/linux-3.2.0/
+(gdb) tfind 
+Found trace frame 1, tracepoint 1
+#0  vfs_read (file=0xffff8801c36e6400, buf=0x7fff51a8f110 <Address 0x7fff51a8f110 out of bounds>, count=16, 
+    pos=0xffff8801761dff48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+GDB还提供其他的命令处理源码问题，请到http://sourceware.org/gdb/current/onlinedocs/gdb/Source-Path.html取得他们的介绍。
+
+保存trace帧信息到一个文件中
+/sys/kernel/debug/gtpframe是一个当KGTP停止时的tfine格式（GDB可以读取它）的接口。
+请 注意 有些"cp"不能很好的处理这个问题，可以用"cat /sys/kernel/debug/gtpframe > ./gtpframe"拷贝它。
+你可以在需要的时候打开文件gtpframe:
+
+(gdb) target tfile ./gtpframe
+Tracepoint 1 at 0xffffffff8114f3dc: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+Created tracepoint 1 for target's tracepoint 1 at 0xffffffff8114f3c0.
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880036e8f300, filler=0xffffffff8114f240 <filldir>, buf=0xffff880001e5bf38)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+显示和存储tracepoint
+你可以用GDB命令"info tracepoints"显示所有的tracepoint。
+你可以用GDB命令"save tracepoints filename"保存所有的设置tracepoint的命令到文件filename里。于是你可以在之后用GDB命令"source filename"设置重新这些tracepoint。
+
+删除tracepoint
+GDB命令"delete id"将删除tracepoint id。如果"delete"没有参数，则删除所有tracepoint。
+
+用tracepoint从内核中某点取得寄存器信息
+下面是记录内核调用函数"vfs_readdir"时的寄存器信息的例子：
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xc01a1ac0: file
+/home/teawater/kernel/linux-2.6/fs/readdir.c, line 23.
+(gdb) actions
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $reg
+>end
+(gdb) tstart
+(gdb) shell ls
+(gdb) tstop
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  0xc01a1ac1 in vfs_readdir (file=0xc5528d00, filler=0xc01a1900 <filldir64>,
+   buf=0xc0d09f90) at /home/teawater/kernel/linux-2.6/fs/readdir.c:23
+23      /home/teawater/kernel/linux-2.6/fs/readdir.c: No such file or directory.
+       in /home/teawater/kernel/linux-2.6/fs/readdir.c
+(gdb) info reg
+eax            0xc5528d00       -984445696
+ecx            0xc0d09f90       -1060069488
+edx            0xc01a1900       -1072031488
+ebx            0xfffffff7       -9
+esp            0xc0d09f8c       0xc0d09f8c
+ebp            0x0      0x0
+esi            0x8061480        134616192
+edi            0xc5528d00       -984445696
+eip            0xc01a1ac1       0xc01a1ac1 <vfs_readdir+1>
+eflags         0x286    [ PF SF IF ]
+cs             0x60     96
+ss             0x8061480        134616192
+ds             0x7b     123
+es             0x7b     123
+fs             0x0      0
+gs             0x0      0
+(gdb) tfind
+Found trace frame 1, tracepoint 1
+0xc01a1ac1      23      in /home/teawater/kernel/linux-2.6/fs/readdir.c
+(gdb) info reg
+eax            0xc5528d00       -984445696
+ecx            0xc0d09f90       -1060069488
+edx            0xc01a1900       -1072031488
+ebx            0xfffffff7       -9
+esp            0xc0d09f8c       0xc0d09f8c
+ebp            0x0      0x0
+esi            0x8061480        134616192
+edi            0xc5528d00       -984445696
+eip            0xc01a1ac1       0xc01a1ac1 <vfs_readdir+1>
+eflags         0x286    [ PF SF IF ]
+cs             0x60     96
+ss             0x8061480        134616192
+ds             0x7b     123
+es             0x7b     123
+fs             0x0      0
+gs             0x0      0
+用tracepoint从内核中某点取得变量的值
+下面是记录内核调用函数"vfs_readdir"时"jiffies_64"的值的例子：
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir 
+Tracepoint 1 at 0xc01ed740: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect jiffies_64
+>collect file->f_path.dentry->d_iname
+>end
+(gdb) tstart 
+(gdb) shell ls
+arch    drivers   include  kernel    mm               Module.symvers  security  System.map  virt
+block   firmware  init     lib       modules.builtin  net             sound     t           vmlinux
+crypto  fs        ipc      Makefile  modules.order    scripts         source    usr         vmlinux.o
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  0xc01ed741 in vfs_readdir (file=0xf4063000, filler=0xc01ed580 <filldir64>, buf=0xd6dfdf90)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+(gdb) p jiffies_64
+$1 = 4297248706
+(gdb) p file->f_path.dentry->d_iname
+$1 = "b26", '\000' <repeats 28 times>
+显示当前这一条trace缓存里存储的所有信息
+在用"tfind"选择好一个条目后，你可以用"tdump"。
+
+(gdb) tdump 
+Data collected at tracepoint 1, trace frame 0:
+$cr = void
+file->f_path.dentry->d_iname = "gtp\000.google.chrome.g05ZYO\000\235\337\000\000\000\000\200\067k\364\200\067", <incomplete sequence \364>
+jiffies_64 = 4319751455
+取得 tracepoint 的状态
+请用GDB命令"tstatus"。
+
+设置trace缓存为循环缓存
+http://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html
+帧缓存默认情况下不是循环缓存。当缓存满了的时候，tracepoint将停止。
+下面的命令将设置trace缓存为循环缓存，当缓存满了的时候，其将自动删除最早的数据并继续trace。
+
+(gdb) set circular-trace-buffer on
+GDB断开的时候不要停止tracepoint
+http://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html
+默认情况下，当GDB断开KGTP的时候将自动停止tracepoint并删除trace帧。
+下面的命令将打开KGTP disconnect-trace。在设置之后，当GDB断开KGTP的时候，KGTP将不停止tracepoint。GDB重新连到KGTP的时候，其可以继续控制KGTP。
+
+(gdb) set disconnected-tracing on
+kprobes-optimization和tracepoint的执行速度
+因为tracepoint是和Linux内核一起执行，所以它的速度将影响到系统执行的速度。
+KGTP tracepoint是基于Linux内核kprobe。因为普通kprobe是基于断点指令，所以它的速度不是很快。
+
+但是如果你的arch是X86_64 或者 X86_32 而且内核配置没有打开"Preemptible Kernel" (PREEMPT)，kprobe的速度将被kprobes-optimization (CONFIG_OPTPROBES)提高很多。
+可以用下面的命令来确认：
+
+sysctl -A | grep kprobe
+debug.kprobes-optimization = 1
+这个的意思就是你的系统支持kprobes-optimization。
+请 注意 一些KGTP的功能会导致tracepoint只能使用普通kprobe即使系统支持kprobes-optimization。文档将在介绍这些功能的时候增加提醒，如果你很介意tracepoint的速度就请避免使用这些功能。
+
+如果使用trace状态变量
+http://sourceware.org/gdb/current/onlinedocs/gdb/Trace-State-Variables.html
+trace状态变量简称TSV。
+TSV可以在tracepoint action和condition中被访问，并且可以直接被GDB命令访问。
+请 注意 GDB 7.2.1和更晚的版本直接访问trace状态变量，比他们老的GDB只能通过命令"info tvariables"取得trace状态变量的值。
+
+普通trace状态变量
+定义trace状态变量$c.
+
+(gdb) tvariable $c
+trace状态变量 $c 被创建并初始化0。 下面的action将使用$c记录内核里发生了多少次IRQ。
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace handle_irq
+(gdb) actions 
+Enter actions for tracepoint 3, one per line.
+End with a line saying just "end".
+>collect $c     #Save current value of $c to the trace frame buffer.
+>teval $c=$c+1  #Increase the $c.
+>end
+你还可以将某个变量的值传到状态变量里，但是别忘记转化这个值为"uint64_t"。
+
+>teval $c=(uint64_t)a
+你可以取得$c的值当trace在运行或者停止的时候。
+
+(gdb) tstart
+(gdb) info tvariables
+$c              0           31554
+(gdb) p $c
+$5 = 33652
+(gdb) tstop
+(gdb) p $c
+$9 = 105559
+当使用tfind的时候，你可以分析trace frame buffer。如果trace状态变量被收集了，你可以把它取出来。
+
+(gdb) tstop 
+(gdb) tfind 
+(gdb) info tvariables
+$c              0           0
+(gdb) p $c
+$6 = 0
+(gdb) tfind 100
+(gdb) p $c
+$7 = 100
+如果需要的时候，访问trace状态变量的tracepoint action将自动加锁，所以其可以很好的处理trace状态变量的竞态条件问题。
+下面这个例子即使在一个多CPU的环境也可以正常使用。
+
+>teval $c=$c+1
+Per_cpu trace状态变量
+Per_cpu trace状态变量是一种特殊的普通trace状态变量。 当一个tracepoint action访问到其的时候，其将自动访问这个CPU的Per_cpu trace状态变量。
+它有两个优点：
+1. 访问Per_cpu trace状态变量的tracepoint actions不存在竞态条件问题，所以其不需要对trace状态变量加锁。所以其在多核的机器上速度更快。 
+2. 写针对记录某个CPU的tracepoint actions比普通trace状态变量更容易。
+
+如何定义
+Per_cpu trace状态变量有两种类型：
+
+本地CPU变量
+"per_cpu_"+string
+或者
+
+"p_"+string
+例如：
+
+(gdb) tvariable $p_count
+在tracepoint action中访问这个trace状态变量的时候，其将返回这个变量在这个action运行的CPU上的值。
+
+CPU id变量
+"per_cpu_"+string+CPU_id
+或者
+
+"p_"+string+CPU_id
+例如：
+
+(gdb) tvariable $p_count0
+(gdb) tvariable $p_count1
+(gdb) tvariable $p_count2
+(gdb) tvariable $p_count3
+在tracepoint action或者GDB命令行中访问这个变量的时候，其将返回这个变量在CPU CPI_id 上的值。 
+下面这个例子可以自动这个这台主机上的每个CPU定义CPU id变量。(请 注意 用这些命令之前需要让GDB连上KGTP。)
+
+(gdb) set $tmp=0
+(gdb) while $tmp<$cpu_number
+ >eval "tvariable $p_count%d",$tmp
+ >set $tmp=$tmp+1
+ >end
+例子1
+这个例子定义了一个记录每个CPU调用多少次vfs_read的tracepoint。
+
+tvariable $p_count
+set $tmp=0
+while $tmp<$cpu_number
+  eval "tvariable $p_count%d",$tmp
+  set $tmp=$tmp+1
+  end
+trace vfs_read
+actions
+  teval $p_count=$p_count+1
+  end
+于是你可以在"tstart"后显示每个CPU调用了多少次vfs_read：
+
+(gdb) p $p_count0
+$3 = 44802
+(gdb) p $p_count1
+$4 = 55272
+(gdb) p $p_count2
+$5 = 102085
+(gdb) p $p_count3
+例子2
+这个例子记录了每个CPU上关闭IRQ时间最长的函数的stack dump。
+
+set pagination off
+
+tvariable $bt=1024
+tvariable $p_count
+tvariable $p_cc
+set $tmp=0
+while $tmp<$cpu_number
+eval "tvariable $p_cc%d",$tmp
+set $tmp=$tmp+1
+end
+
+tvariable $ignore_error=1
+
+trace arch_local_irq_disable
+  commands
+    teval $p_count=$clock
+  end
+trace arch_local_irq_enable if ($p_count && $p_cc < $clock - $p_count)
+  commands
+    teval $p_cc = $clock - $p_count
+    collect $bt
+    collect $p_cc
+    teval $p_count=0
+  end
+
+enable
+set pagination on
+特殊trace状态变量 $current_task，$current_task_pid，$current_thread_info，$cpu_id，$dump_stack，$printk_level，$printk_format，$printk_tmp，$clock，$hardirq_count，$softirq_count 和 $irq_count
+KGTP特殊trace状态变量$current_task，$current_thread_info，$cpu_id 和 $clock可以很容易的访问各种特殊的值，当你用GDB连到KGTP后就可以访问到他们。 你可以在tracepoint条件和actions里使用他们。
+在tracepoint条件和actions里访问$current_task可以取得get_current()的返回值。
+在tracepoint条件和actions里访问$current_task_pid可以取得get_current()->pid的值。
+在tracepoint条件和actions里访问$current_thread_info可以取得current_thread_info()的返回值。
+在tracepoint条件和actions里访问$cpu_id可以取得smp_processor_id()的返回值。
+在tracepoint条件和actions里访问$clock可以取得local_clock()的返回值，也就是取得纳秒为单位的时间戳。
+$rdtsc只在体系结构是X86或者X86_64的时候访问的到，任何时候访问它可以取得用指令RDTSC取得的TSC的值。
+在tracepoint条件和actions里访问$hardirq_count可以取得hardirq_count()的返回值。
+在tracepoint条件和actions里访问$softirq_count可以取得softirq_count()的返回值。
+在tracepoint条件和actions里访问$irq_count可以取得irq_count()的返回值。
+KGTP还有一些特殊trace状态变量$dump_stack，$printk_level，$printk_format 和 $printk_tmp。他们可以用来直接显示值，请看http://code.google.com/p/kgtp/wiki/HOWTOCN#如何让tracepoint直接输出信息。
+下面是一个用$c记录进程16663调用多少次vfs_read并收集thread_info结构的例子：
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_read if (((struct task_struct *)$current_task)->pid == 16663)
+(gdb) tvariable $c
+(gdb) actions
+Enter actions for tracepoint 4, one per line.
+End with a line saying just "end".
+>teval $c=$c+1
+>collect (*(struct thread_info *)$current_thread_info)
+>end
+(gdb) tstart 
+(gdb) info tvariables 
+Name            Initial     Current     
+$c              0           184         
+$current_task   0           <unknown>   
+$current_thread_info 0           <unknown>   
+$cpu_id         0           <unknown>   
+(gdb) tstop
+(gdb) tfind
+(gdb) p *(struct thread_info *)$current_thread_info
+$10 = {task = 0xf0ac6580, exec_domain = 0xc07b1400, flags = 0, status = 0, cpu = 1, preempt_count = 2, addr_limit = {
+    seg = 4294967295}, restart_block = {fn = 0xc0159fb0 <do_no_restart_syscall>, {{arg0 = 138300720, arg1 = 11, 
+        arg2 = 1, arg3 = 78}, futex = {uaddr = 0x83e4d30, val = 11, flags = 1, bitset = 78, time = 977063750, 
+        uaddr2 = 0x0}, nanosleep = {index = 138300720, rmtp = 0xb, expires = 335007449089}, poll = {
+        ufds = 0x83e4d30, nfds = 11, has_timeout = 1, tv_sec = 78, tv_nsec = 977063750}}}, 
+  sysenter_return = 0xb77ce424, previous_esp = 0, supervisor_stack = 0xef340044 "", uaccess_err = 0}
+这是一个记录每个CPU调用了多少次sys_read()的例子。
+
+(gdb) tvariable $c0
+(gdb) tvariable $c1
+(gdb) trace sys_read 
+(gdb) condition $bpnum ($cpu_id == 0)
+(gdb) actions
+>teval $c0=$c0+1
+>end
+(gdb) trace sys_read 
+(gdb) condition $bpnum ($cpu_id == 1)
+(gdb) actions
+>teval $c1=$c1+1
+>end
+(gdb) info tvariables 
+Name            Initial     Current     
+$current_task   0           <unknown>   
+$cpu_id         0           <unknown>   
+$c0             0           3255        
+$c1             0           1904     
+sys_read() 在CPU0上被执行了3255次，CPU1上执行了1904次。请 注意 这个例子只是为了显示如何使用$cpu_id，实际上用per_cpu trace状态变量写更好。
+
+特殊trace状态变量 $self_trace
+$self_trace和前面介绍的特殊trace状态变量不同，它是用来控制tracepoint的行为的。
+默认情况下，tracepoint被触发后，如果current_task是KGTP自己的进程（GDB，netcat，getframe或者其他访问KGTP接口的进程）的时候，其将不执行任何actions。
+如果你想让tracepoint actions和任何task的时候都执行，请包含一个包含一个访问到$self_trace的命令到actions中，也就是说增加下面的命令到actions中：
+
+>teval $self_trace=0
+用$kret trace函数的结尾
+有时，因为内核是用优化编译的，所以在函数结尾设置tracepoint有时很困难。这时你可以用$kret帮助你。
+$kret是一个类似$self_trace的特殊trace状态变量。当你在tracepoint action里设置它的值的时候，这个tracepoint将用kretprobe而不是kprobe注册。于是其就可以trace一个函数的结尾。
+请 注意 这个tracepoint 必须用 "function_name" 的格式设置在函数的第一个地址上。
+
+下面的部分是一个例子：
+
+#"*(function_name)" format can make certain that GDB send the first address of function to KGTP.
+(gdb) trace *vfs_read
+(gdb) actions
+>teval $kret=0
+#Following part you can set commands that you want.
+用 $ignore_error 和 $last_errno 忽略tstart的错误
+当KGTP在tstart取得错误，这个命令将失败。
+但有时我们需要忽略这个错误信息并让KGTP工作。例如：如果你在inline函数spin_lock设置tracepoint，这个tracepoint将被设置到很多地址上，有一些地址不能设置kprobe，于是它就会让tstart出错。这时你就可以用"$ignore_error"忽略这些错误。
+最后一个错误信息将存在"$last_errno"中。
+
+(gdb) tvariable $ignore_error=1
+这个命令将打开忽略。
+
+(gdb) tvariable $ignore_error=0
+这个命令将关闭忽略。
+
+使用 $cooked_clock 和 $cooked_rdtsc 取得不包含KGTP运行时间的时间信息
+访问这两个trace状态变量可以取得不包含KGTP运行时间的时间信息，于是我们可以取得一段代码更真实的执行时间即使这个tracepoint的action比较复杂。
+
+使用 $xtime_sec 和 $xtime_nsec 取得 timespec
+访问trace状态变量将返回用getnstimeofday取得的timespec时间信息。
+$xtime_sec 将返回timespec秒的部分。
+$xtime_nsec 将返回timespec纳秒的部分。
+
+如何 backtrace (stack dump)
+每次你的程序做一个函数调用的时候， 这次调用的信息就会生成。这些信息包括调用函数的地址，调用参数，局部变量的值。这些信息被存储在我们称为栈帧的地方，栈帧是从调用栈中分配而来。
+
+通过$bt收集栈并用GDB命令backtrace进行分析
+因为这个方法更快（因为在trace的时候只收集）而且可以分析出大部分的调用栈中的信息（前面介绍的栈信息都可以分析出来），所以时间你使用这个方法做栈分析。
+首先我们需要在tracepoint action中增加命令收集栈。
+GDB收集栈的通常命令是： 在x86_32, 下面的命令将收集512字节的栈内容。
+>collect *(unsigned char *)$esp@512
+在x86_64, 下面的命令将收集512字节的栈内容。
+>collect *(unsigned char *)$rsp@512
+在MIPS或者ARM, 下面的命令将收集512字节的栈内容。
+>collect *(unsigned char *)$sp@512
+这些命令很难记，而且不同的体系结构需要不同的命令。
+KGTP有一个特殊trace状态变量$bt。如果tracepoint action访问到它，KGTP将自动收集$bt长度（默认值是512）的栈。下面这个action将收集512字节的栈内存：
+
+>collect $bt
+如果你想改变$bt的值，你可以在"tstart"使用下面这个GDB命令：
+
+(gdb) tvariable $bt=1024
+下面的部分是一个收集栈并用GDB进行分析的例子：
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8118c300: file /home/teawater/kernel2/linux/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $bt
+>end
+(gdb) tstart 
+(gdb) shell ls
+1      crypto    fs             include  kernel    mm               Module.symvers  security  System.map  vmlinux
+arch   drivers   hotcode.html   init     lib       modules.builtin  net             sound     usr         vmlinux.o
+block  firmware  hotcode.html~  ipc      Makefile  modules.order    scripts         source    virt
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+24      {
+(gdb) bt
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+#1  0xffffffff8118c689 in sys_getdents (fd=<optimized out>, dirent=0x1398c58, count=32768) at /home/teawater/kernel2/linux/fs/readdir.c:214
+#2  <signal handler called>
+#3  0x00007f00253848a5 in ?? ()
+#4  0x00003efd32cddfc9 in ?? ()
+#5  0x00002c15b7d04101 in ?? ()
+#6  0x000019c0c5704bf1 in ?? ()
+#7  0x0000000900000000 in ?? ()
+#8  0x000009988cc8d269 in ?? ()
+#9  0x000009988cc9b8d1 in ?? ()
+#10 0x0000000000000000 in ?? ()
+(gdb) up
+#1  0xffffffff8118c689 in sys_getdents (fd=<optimized out>, dirent=0x1398c58, count=32768) at /home/teawater/kernel2/linux/fs/readdir.c:214
+214             error = vfs_readdir(file, filldir, &buf);
+(gdb) p buf
+$1 = {current_dir = 0x1398c58, previous = 0x0, count = 32768, error = 0}
+(gdb) p error
+$3 = -9
+(gdb) frame 0
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+24      {
+从这个例子，我们可以看到一些分析调用栈的GDB命令：
+bt 是GDB命令 backtrace 的别名，这个命令将打印stack中的信息：每一行是一个调用栈。
+up n 是向上移动n个帧。如果n是正数，则向外到更高的帧，一直到这个栈最大的一行。n的默认值是1。
+down n 是向下移动n个帧。如果n是正数，则向内到更低的帧，一直到最新创建的那个栈帧。n的默认值是1。
+is move n frames down the stack. For positive numbers n, this advances toward the innermost frame, to lower frame numbers, to frames that were created more recently. n defaults to one. 你可以把 down 缩写为 do。
+frame n 是选择帧n。帧0是最近创建的帧，帧1调用这个帧的帧。所以最高的帧是main。
+你还可以看到当你用up，down或者frame来选择调用栈帧的时候，你可以输出不同帧的参数和局部变量。
+要取得更多关于如何使用GDB分析调用栈的信息，请到http://sourceware.org/gdb/current/onlinedocs/gdb/Stack.html。
+用$_ret来取得当前函数的调用函数的栈
+如果你只想取得当前函数的调用函数的栈，可以用$_ret。
+请 注意 使用$_ret的tracepoint不能设置在函数的第一个地址上。
+例如：
+
+(gdb) list vfs_read
+360     }
+361     
+362     EXPORT_SYMBOL(do_sync_read);
+363     
+364     ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
+365     {
+366             ssize_t ret;
+367     
+368             if (!(file->f_mode & FMODE_READ))
+369                     return -EBADF;
+(gdb) trace 368
+Tracepoint 2 at 0xffffffff8117a244: file /home/teawater/kernel2/linux/fs/read_write.c, line 368.
+(gdb) actions 
+Enter actions for tracepoint 2, one per line.
+End with a line saying just "end".
+>collect $_ret
+>end
+(gdb) tstart 
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 2
+#0  vfs_read (file=0xffff880141c46000, buf=0x359bda0 <Address 0x359bda0 out of bounds>, count=8192, pos=0xffff88012fa49f48)
+    at /home/teawater/kernel2/linux/fs/read_write.c:368
+368             if (!(file->f_mode & FMODE_READ))
+(gdb) bt
+#0  vfs_read (file=0xffff880141c46000, buf=0x359bda0 <Address 0x359bda0 out of bounds>, count=8192, pos=0xffff88012fa49f48)
+    at /home/teawater/kernel2/linux/fs/read_write.c:368
+#1  0xffffffff8117a3ea in sys_read (fd=<optimized out>, buf=<unavailable>, count=<unavailable>)
+    at /home/teawater/kernel2/linux/fs/read_write.c:469
+Backtrace stopped: not enough registers or memory available to unwind further
+(gdb) up
+#1  0xffffffff8117a3ea in sys_read (fd=<optimized out>, buf=<unavailable>, count=<unavailable>)
+    at /home/teawater/kernel2/linux/fs/read_write.c:469
+469                     ret = vfs_read(file, buf, count, &pos);
+(gdb) p ret
+$2 = -9
+我们可以看到调用vfs_read的函数是sys_read，函数sys_read的局部变量ret的值是-9。
+
+用 $dump_stack 输出栈分析到printk里
+因为这个方法需要在trace的时候分析栈并调用printk，所以它比较慢，不安全，不清晰也不能访问调用栈中的很多内容，所以我建议你上一部分介绍的方法
+KGTP有一个特殊的trace状态变量$dump_stack，收集这个变量可以令GDB调用栈分析并用printk输出。 下面是一个让内核输出vfs_readdir栈分析的例子：
+
+target remote /sys/kernel/debug/gtp
+trace vfs_readdir
+  commands
+    collect $dump_stack
+  end
+于是你的内核就会printk这样的信息：
+
+[22779.208064] gtp 1:Pid: 441, comm: python Not tainted 2.6.39-rc3+ #46
+[22779.208068] Call Trace:
+[22779.208072]  [<fe653cca>] gtp_get_var+0x4a/0xa0 [gtp]
+[22779.208076]  [<fe653d79>] gtp_collect_var+0x59/0xa0 [gtp]
+[22779.208080]  [<fe655974>] gtp_action_x+0x1bb4/0x1dc0 [gtp]
+[22779.208084]  [<c05b6408>] ? _raw_spin_unlock+0x18/0x40
+[22779.208088]  [<c023f152>] ? __find_get_block_slow+0xd2/0x160
+[22779.208091]  [<c01a8c56>] ? delayacct_end+0x96/0xb0
+[22779.208100]  [<c023f404>] ? __find_get_block+0x84/0x1d0
+[22779.208103]  [<c05b6408>] ? _raw_spin_unlock+0x18/0x40
+[22779.208106]  [<c02e0838>] ? find_revoke_record+0xa8/0xc0
+[22779.208109]  [<c02e0c45>] ? jbd2_journal_cancel_revoke+0xd5/0xe0
+[22779.208112]  [<c02db51f>] ? __jbd2_journal_temp_unlink_buffer+0x2f/0x110
+[22779.208115]  [<fe655c4c>] gtp_kp_pre_handler+0xcc/0x1c0 [gtp]
+[22779.208118]  [<c05b8a88>] kprobe_exceptions_notify+0x3d8/0x440
+[22779.208121]  [<c05b7d54>] ? hw_breakpoint_exceptions_notify+0x14/0x180
+[22779.208124]  [<c05b95eb>] ? sub_preempt_count+0x7b/0xb0
+[22779.208126]  [<c0227ac5>] ? vfs_readdir+0x15/0xb0
+[22779.208128]  [<c0227ac4>] ? vfs_readdir+0x14/0xb0
+[22779.208131]  [<c05b9743>] notifier_call_chain+0x43/0x60
+[22779.208134]  [<c05b9798>] __atomic_notifier_call_chain+0x38/0x50
+[22779.208137]  [<c05b97cf>] atomic_notifier_call_chain+0x1f/0x30
+[22779.208140]  [<c05b980d>] notify_die+0x2d/0x30
+[22779.208142]  [<c05b71c5>] do_int3+0x35/0xa0
+如何让tracepoint直接输出信息
+在前面的章节，你可以看到如果想取得Linux内核的信息，你需要用tracepoint "collect" action来保存信息到tracepoint帧中并用GDB tfind命来来分析这些数据帧。
+但是有时我们希望直接取得这些数据，所以KGTP提供了一种直接取得这些数据的方法。
+
+切换collect为直接输出数据
+KGTP有特殊trace状态变量$printk_level，$printk_format 和 $printk_tmp支持这个功能。
+$printk_level，如果这个值是8（这是默认值），"collect" action将是普通行为也就是保存数据到tracepoint帧中。
+如果值是0-7，"collect" 将以这个数字为printk级别输出信息，这些级别是：
+
+0       KERN_EMERG      system is unusable
+1       KERN_ALERT      action must be taken immediately
+2       KERN_CRIT       critical conditions
+3       KERN_ERR        error conditions
+4       KERN_WARNING    warning conditions
+5       KERN_NOTICE     normal but significant condition
+6       KERN_INFO       informational
+7       KERN_DEBUG      debug-level messages
+$printk_format，collect printk将按照这里设置的格式进行输出。 这些格式是：
+
+0       这是默认值。
+        如果collect的长度是1，2，4，8则其将输出一个无符号十进制数。
+        如果不是，则其将输出十六进制字串。
+1       输出值是有符号十进制数。
+2       输出值是无符号十进制数。
+3       输出值是无符号十六进制数。
+4       输出值是字符串。
+5       输出值是十六进制字串。
+如果要输出一个全局变量，需要将其先设置到$printk_tmp中。
+
+下面是一个显示调用vfs_readdir时的计数，pid，jiffies_64和文件名的例子：
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) tvariable $c
+(gdb) trace vfs_readdir
+(gdb) actions
+>teval $printk_level=0
+>collect $c=$c+1
+>collect ((struct task_struct *)$current_task)->pid
+>collect $printk_tmp=jiffies_64
+>teval $printk_format=4
+>collect file->f_path.dentry->d_iname
+>end
+于是内核将printk这些信息：
+
+gtp 1:$c=$c+1=41
+gtp 1:((struct task_struct *)$current_task)->pid=12085
+gtp 1:$printk_tmp=jiffies_64=4322021438
+gtp 1:file->f_path.dentry->d_iname=b26
+gtp 1:$c=$c+1=42
+gtp 1:((struct task_struct *)$current_task)->pid=12085
+gtp 1:$printk_tmp=jiffies_64=4322021438
+gtp 1:file->f_path.dentry->d_iname=b26
+"gtp 1" 的意思是数据是tracepoint 1输出的。
+
+如何用watch tracepoint控制硬件断点记录内存访问
+Watch tracepoint 可以通过设置一些特殊的trace状态变量设置硬件断点来记录内存访问。
+请 注意 watch tracepoint现在只有X86和X86_64支持。而且因为Linux 2.6.26和更老版本有一些IPI的问题，只有Linux 2.6.27和更新版本上可以正常使用动态watch tracepoint。
+
+watch tracepoint的trace状态变量
+名称	普通tracepoint写	普通tracepoint读	静态static tracepoint写	静态static tracepoint读	动态static tracepoint写	动态static tracepoint写
+$watch_static	 不支持	 不支持	 如果"teval $watch_static=1"则这个tracepoint是静态watch tracepoint。	 不支持	 如果"teval $watch_static=0"则这个tracepoint是动态watch tracepoint。	 不支持
+$watch_set_id	 当这个tracepoint要设置一个动态watch tracepoint的时候，设置动态watch tracepoint的ID到$watch_set_id来标明你要设置哪个动态watch tracepoint。	 不支持	 不支持	 不支持	 不支持	 不支持
+$watch_set_addr	 当这个tracepoint要设置一个动态watch tracepoint的时候，设置动态watch tracepoint的地址到$watch_set_addr来标明你要设置哪个动态watch tracepoint。	 不支持	 不支持	 不支持	 不支持	 不支持
+$watch_type	 当这个tracepoint要设置一个动态watch tracepoint的时候，设置watch类型到$watch_type。
+0是执行。 1是写。 2是读或者写。	 取得这个tracepoint设置到$watch_type里的值。	 设置watch tracepoint的类型。	 取得这个watch tracepoint的类型。	 设置watch tracepoint的默认类型。	 取得这个watch tracepoint在实际执行中的类型。
+$watch_size	 当这个tracepoint要设置一个动态watch tracepoint的时候，设置watch长度到$watch_size。
+长度是1, 2, 4, 8。	 取得这个tracepoint设置到$watch_size里的值。	 设置watch tracepoint的长度。	 取得这个watch tracepoint的长度。	 设置watch tracepoint的默认长度。	 取得这个watch tracepoint在实际执行中的长度。
+$watch_start	 设置地址到动态watch tracepoint($watch_set_addr或者$watch_set_id设置)中并让其开始工作。	 取得这次开始的返回值。 （其可能会失败因为X86只有4个硬件断点）
+取得0则成功，小于0则是错误ID。	 不支持	 不支持	 不支持	 不支持
+$watch_stop	 设置地址到$watch_stop将让一个watch这个地址的动态watch tracepoint停止。	 取得这次停止的返回值。	 不支持	 不支持	 不支持	 不支持
+$watch_trace_num	 不支持	 不支持	 不支持	 不支持	 不支持	 设置这个动态watch tracepoint的tracepoint的号码。
+$watch_trace_addr	 不支持	 不支持	 不支持	 不支持	 不支持	 设置这个动态watch tracepoint的tracepoint的地址。
+$watch_addr	 不支持	 不支持	 不支持	 这个watch tracepoint监视的地址。	 不支持	 这个watch tracepoint监视的地址。
+$watch_val	 不支持	 不支持	 不支持	 这个watch tracepoint监视的内存的值。	 不支持	 这个watch tracepoint监视的内存的值。
+$watch_count	 不支持	 不支持	 不支持	 不支持	 不支持	 这个watch tracepoint会话的一个特殊计数ID。
+静态watch tracepoint
+当你要监视全局变量或者可以取得地址的变量的值的时候，你可以使用静态watch tracepoint。下面是一个监视jiffies_64写的例子:
+
+#静态watch tracepoint从tracepoint的地址中取得要监视的地址
+trace *&jiffies_64
+  actions
+    #Set this watch tracepoint to static
+    teval $watch_static=1
+    #Watch memory write
+    teval $watch_type=1
+    teval $watch_size=8
+    collect $watch_val
+    collect $bt
+  end
+动态watch tracepoint
+当你要监视局部变量或者只能在函数中取得地址的变量的值的时候，你可以使用动态watch tracepoint。下面是一个监视函数function get_empty_filp中f->f_posf->f_op写的例子:
+
+trace *1
+  commands
+    teval $watch_static=0
+    teval $watch_type=1
+    teval $watch_size=8
+    collect $bt
+    collect $watch_addr
+    collect $watch_val
+  end
+定义了一个动态watch tracepoint。地址"1"并不是其要监视的地址。其将帮助tracepoint来找到这个动态watch tracepoint。
+
+list get_empty_filp
+trace 133
+  commands
+    teval $watch_set_addr=1
+    teval $watch_size=4
+    teval $watch_start=&(f->f_pos)
+    teval $watch_size=8
+    teval $watch_start=&(f->f_op)
+  end
+在函数get_empty_filp中定义一个普通tracepoint，其将开始监视f->f_pos和f->f_op。
+
+trace file_sb_list_del
+  commands
+    teval $watch_stop=&(file->f_pos)
+    teval $watch_stop=&(file->f_op)
+  end
+在函数file_sb_list_del中定义一个普通tracepoint，其将停止监视file->f_pos和file->f_op。
+
+使用while-stepping让Linux内核做单步
+请 注意 while-stepping现在只有X86和X86_64支持。
+
+如何使用 while-stepping
+while-stepping 是一种可以包含actions的特殊tracepoint action。
+当一个actions中包含了“while-stepping n”的tracepoint执行的时候，其将做n次单步并执行while-stepping的actions。例如：
+
+trace vfs_read
+#因为单步会影响系统速度，所以最好用passcount或者condition限制tracepoint的执行次数。
+passcount 1
+  commands
+    collect $bt
+    collect $step_count
+    #做2000次单步。
+    while-stepping 2000
+      #下面这部分是"while-stepping 2000"的actions。
+      #因为单步可能会执行到其他函数，所以最好不要访问局部变量。
+      collect $bt
+      collect $step_count
+    end
+  end
+请 注意 tracepoint在执行单步的时候会关闭当前CPU的中断。 在actions中访问 $step_count 将得到从1开始的这步的计数。
+
+读while-stepping的traceframe
+不同step的数据将会被记录到不同的traceframe中，你可以用tfind (https://code.google.com/p/kgtp/wiki/HOWTOCN#用tfind选择trace帧缓存里面的条目) 选择他们。
+或者你可以将KGTP切换到回放模式，这样GDB可以用执行和反向执行命令选择一个while-stepping tracepoint的traceframe。例如：
+用tfind选择一个while-stepping的traceframe。
+
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+下面的命令将切换KGTP到回放模式。
+
+(gdb) monitor replay
+(gdb) tfind -1
+No longer looking at any trace frame
+#0  vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+于是可以使用执行命令。
+
+(gdb) n
+368             if (!(file->f_mode & FMODE_READ))
+(gdb) p file->f_mode
+$5 = 3
+设置断点 (只在回放模式下有效，不会影响到Linux内核执行)。
+
+(gdb) b 375
+Breakpoint 2 at 0xffffffff81179b75: file /build/buildd/linux-3.2.0/fs/read_write.c, line 375.
+(gdb) c
+Continuing.
+
+Breakpoint 2, vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:375
+375             ret = rw_verify_area(READ, file, pos, count);
+(gdb) s
+rw_verify_area (read_write=0, file=0xffff8801f7bd4c00, ppos=0xffff8801f4b45f48, count=16)
+    at /build/buildd/linux-3.2.0/fs/read_write.c:300
+300             inode = file->f_path.dentry->d_inode;
+使用反向执行命令。
+
+(gdb) rs
+
+Breakpoint 2, vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:375
+375             ret = rw_verify_area(READ, file, pos, count);
+(gdb) rn
+372             if (unlikely(!access_ok(VERIFY_WRITE, buf, count)))
+GDB命令tstart，tstop，tfind或者quit可以自动关闭回放模式。
+
+如何显示被优化掉的变量值
+有时GDB会这样输出信息：
+
+inode has been optimized out of existence.
+res has been optimized out of existence.
+这是因为inode和res的值被优化掉了。内核用-O2编译的所以你有时会碰到这个问题。
+有两个方法处理这个问题：
+
+升级你的GCC
+VTA branch http://gcc.gnu.org/wiki/Var_Tracking_Assignments 已经整合进GCC 4.5，其可以帮助生成之前被标记为"optimized out"的值的调试信息。
+
+如何取得函数指针指向的函数
+如果函数指针没有被优化掉
+你可以直接collect这个指针，例如：
+
+377                     count = ret;
+378                     if (file->f_op->read)
+379                             ret = file->f_op->read(file, buf, count, pos);
+(gdb) 
+(gdb) trace 379
+Tracepoint 1 at 0xffffffff81173ba5: file /home/teawater/kernel/linux/fs/read_write.c, line 379.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect file->f_op->read
+>end
+(gdb) tstart
+(gdb) tstop
+(gdb) tfind
+(gdb) p file->f_op->read
+$5 = (ssize_t (*)(struct file *, char *, size_t, loff_t *)) 0xffffffff81173190 <do_sync_read>
+#于是就知道file->f_op->read指向do_sync_read。
+如果函数指针被优化掉了
+可以用tracepoint step处理这个问题，例如：
+
+#找到调用指针的指令
+(gdb) disassemble /rm vfs_read
+379                             ret = file->f_op->read(file, buf, count, pos);
+   0xffffffff81173ba5 <+181>:   48 89 da        mov    %rbx,%rdx
+   0xffffffff81173ba8 <+184>:   4c 89 e9        mov    %r13,%rcx
+   0xffffffff81173bab <+187>:   4c 89 e6        mov    %r12,%rsi
+   0xffffffff81173bae <+190>:   4c 89 f7        mov    %r14,%rdi
+   0xffffffff81173bb1 <+193>:   ff d0   callq  *%rax
+   0xffffffff81173bb3 <+195>:   48 89 c3        mov    %rax,%rbx
+(gdb) trace *0xffffffff81173bb1
+Tracepoint 1 at 0xffffffff81173bb1: file /home/teawater/kernel/linux/fs/read_write.c, line 379.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>while-stepping 1
+ >collect $reg
+ >end
+>end
+(gdb) tstart 
+(gdb) tstop 
+(gdb) tfind 
+#0  tty_read (file=0xffff88006ca74900, buf=0xb6b7dc <Address 0xb6b7dc out of bounds>, count=8176, 
+    ppos=0xffff88006e197f48) at /home/teawater/kernel/linux/drivers/tty/tty_io.c:960
+960     {
+#于是就知道file->f_op->read指向tty_read。
+请 注意 while-stepping 将让tracepoint不能使用kprobes-optimization。
+
+/sys/kernel/debug/gtpframe和离线调试
+/sys/kernel/debug/gtpframe是一个当KGTP停止时的tfine格式（GDB可以读取它）的接口。
+在运行GDB的主机上：
+改变 "target remote XXXX" 为：
+
+(gdb) target remote | perl ./getgtprsp.pl
+之后像平时一样设置tracepoint：
+
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8114f3c0: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+#If your GDB support tracepoint "printf" (see "Howto use tracepoint printf"), use it to show the value directly is better.
+>collect $reg
+>end
+(gdb) tstart 
+(gdb) stop 
+(gdb) quit
+于是你可以在当前目录找到文件gtpstart和gtpstop，把他们拷贝到你想调试的主机上。
+
+在被调试主机上，先拷贝KGTP目录中的程序"putgtprsp"和"gtp.ko"到这台机器上。insmod gtp.ko之后：
+启动tracepoint：
+
+./putgtprsp ./gtpstart
+停止tracepoint：
+
+./putgtprsp ./gtpstop
+可以按照http://code.google.com/p/kgtp/wiki/HOWTOCN#如何让tracepoint直接输出信息直接在板子上显示信息。
+
+如果要保存trace帧之后再分析，你可以拷贝文件"/sys/kernel/debug/gtpframe"到有GDB的主机上。
+请 注意 有些"cp"不能很好的处理这个问题，可以用"cat /sys/kernel/debug/gtpframe > ./gtpframe"拷贝它。
+在运行GDB的主机上：
+(gdb) target tfile ./gtpframe
+Tracepoint 1 at 0xffffffff8114f3dc: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+Created tracepoint 1 for target's tracepoint 1 at 0xffffffff8114f3c0.
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880036e8f300, filler=0xffffffff8114f240 <filldir>, buf=0xffff880001e5bf38)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+请 注意 如果你想在使用离线调试后从远程主机上的GDB连接KGTP，你需要在调用"nc"之前"rmmod gtp"和"insmod gtp.ko"。
+
+如何使用 /sys/kernel/debug/gtpframe_pipe
+这个接口提供和"gtpframe"同样的数据，但是可以在KGTP tracepoint运行的时候也可以使用。在数据读出之后，其将自动从trace帧里删除类似ftrace "trace_pipe"。
+
+用GDB读帧信息
+#连接到接口上
+(gdb) target tfile /sys/kernel/debug/gtpframe_pipe
+#取得一个trace帧条目
+(gdb) tfind 0
+Found trace frame 0, tracepoint 1
+#取得下一个
+(gdb) tfind 
+Target failed to find requested trace frame.
+(gdb) tfind 0
+Found trace frame 0, tracepoint 1
+这个方法和python一起分析内核比较好，add-ons/hotcode.py就是这样的例子。
+
+用cat读帧信息
+sudo cat /sys/kernel/debug/gtpframe_pipe > g
+于是所有帧信息都被存入了文件"g"。
+
+用getframe读帧信息
+KGTP包含一个"getframe"可以用来帮助取得trace帧。
+下面这里是它的帮助：
+
+getframe -h
+Get the trace frame of KGTP and save them in current 
+directory with tfile format.
+Usage: ./getframe [option]
+
+  -g n    Set the minimum free size limit to n G.
+          When free size of current disk is smaller than n G,
+          ./getframe will exit (-q) or wait some seconds (-w).
+          The default value of it is 2 G.
+
+  -q      Quit when current disk is smaller than
+          minimum free size limit (-g).
+
+  -w n    Wait n seconds when current disk is smaller
+          than minimum free size limit (-g).
+
+  -e n    Set the entry number of each tfile to n.
+          The default value of it is 1000.
+
+  -h      Display this information.
+使用 $pipe_trace
+为了锁安全，KGTP默认将自动忽略读/sys/kernel/debug/gtpframe_pipe的任务。
+如果你真希望trace这个任务而且确定这是安全的，你可以使用"tstart"之前使用下面的命令：
+
+(gdb) tvariable $pipe_trace=1
+于是KGTP将不再忽略读/sys/kernel/debug/gtpframe_pipe的任务。
+
+和用户层程序一起使用KGTP
+直接读用户层程序的内存
+KGTP可以不同停止应用层程序的情况下直接读取其内存，请到http://code.google.com/p/kgtp/wiki/HOWTOCN#用户程序的内存取得如何做。
+
+在tracepoint收集用户层程序的栈信息(可用来做backtrace)
+$current_task_user 是一个特殊trace状态变量。当current task 在user模式的时候，其的值为真。
+$current 是一个特殊trace状态变量。当一个tracepoint的action collect其的时候，tracepoint将收集current task的寄存器和内存值。
+用这两个trace状态变量，就可以用KGTP收集用户层程序的栈信息(可用来做backtrace)。
+下面这个例子显示如何从用户层到Linux内核层做backtrace(stack dump)：
+
+#连接KGTP(和上一节介绍的方法相同)
+(gdb) target extended-remote /sys/kernel/debug/gtp
+#设置一个收集进程18776的用户栈的tracepoint。
+(gdb) trace vfs_read
+Tracepoint 1 at 0xffffffff8117a3d0: file /home/teawater/kernel/linux/fs/read_write.c, line 365.
+(gdb) condition 1 ($current_task_user && $current_task_pid == 18776)
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $current
+>collect $bt
+>end
+#Setup a tracepoint that collect kernel space stack of task 18776.
+#设置一个收集进程18776的内核栈的tracepoint。
+(gdb) trace vfs_read
+Note: breakpoint 1 also set at pc 0xffffffff8117a3d0.
+Tracepoint 2 at 0xffffffff8117a3d0: file /home/teawater/kernel/linux/fs/read_write.c, line 365.
+(gdb) condition 2 ($current_task_user && $current_task_pid == 18776)
+(gdb) actions 
+Enter actions for tracepoint 2, one per line.
+End with a line saying just "end".
+>collect $bt
+>end
+(gdb) tstart
+(gdb) tstop
+#下面这部分和上一节相同，增加一个新的inferior用来分析应用程序的信息。
+(gdb) add-inferior 
+Added inferior 2
+(gdb) inferior 2
+[Switching to inferior 2 [<null>] (<noexec>)]
+(gdb) file gdb
+Reading symbols from /usr/local/bin/gdb...done.
+(gdb) attach 18776
+#tracepoint 1 收集了用户层的栈信息。
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  0x00007f77331d7d0f in __read_nocancel () from /lib/x86_64-linux-gnu/libpthread.so.0
+#这是程序18776用户层的backtrace。
+(gdb) bt
+#0  0x00007f77331d7d0f in __read_nocancel () from /lib/x86_64-linux-gnu/libpthread.so.0
+#1  0x000000000078e145 in rl_callback_read_char () at ../../src/readline/callback.c:201
+#2  0x000000000069de79 in rl_callback_read_char_wrapper (client_data=<optimized out>) at ../../src/gdb/event-top.c:169
+#3  0x000000000069ccf8 in process_event () at ../../src/gdb/event-loop.c:401
+#4  process_event () at ../../src/gdb/event-loop.c:351
+#5  0x000000000069d448 in gdb_do_one_event () at ../../src/gdb/event-loop.c:465
+#6  0x000000000069d5d5 in start_event_loop () at ../../src/gdb/event-loop.c:490
+#7  0x0000000000697083 in captured_command_loop (data=<optimized out>) at ../../src/gdb/main.c:226
+#8  0x0000000000695d8b in catch_errors (func=0x697070 <captured_command_loop>, func_args=0x0, errstring=0x14df99e "", 
+    mask=6) at ../../src/gdb/exceptions.c:546
+#9  0x00000000006979e6 in captured_main (data=<optimized out>) at ../../src/gdb/main.c:1001
+#10 0x0000000000695d8b in catch_errors (func=0x697360 <captured_main>, 
+    func@entry=<error reading variable: PC not available>, func_args=0x7fff08afd5b0, 
+    func_args@entry=<error reading variable: PC not available>, errstring=<unavailable>, 
+    errstring@entry=<error reading variable: PC not available>, mask=<unavailable>, 
+    mask@entry=<error reading variable: PC not available>) at ../../src/gdb/exceptions.c:546
+#11 <unavailable> in ?? ()
+Backtrace stopped: not enough registers or memory available to unwind further
+#tracepoint 2收集了内核空间的栈，所以要切换回inferior 1装载内核调试信息。
+(gdb) tfind
+Found trace frame 1, tracepoint 2
+#0  0xffffffff8117a3d0 in ?? ()
+(gdb) inferior 1
+[Switching to inferior 1 [Remote target] (/home/teawater/kernel/b/vmlinux)]
+[Switching to thread 1 (Remote target)] 
+#0  vfs_read (file=0xffff88021a559500, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, count=1, 
+    pos=0xffff8800c47e1f48) at /home/teawater/kernel/linux/fs/read_write.c:365
+365     {
+#这是内核栈的backtrace。
+(gdb) bt
+#0  vfs_read (file=0xffff88021a559500, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, count=1, 
+    pos=0xffff8800c47e1f48) at /home/teawater/kernel/linux/fs/read_write.c:365
+#1  0xffffffff8117a59a in sys_read (fd=<optimized out>, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, 
+    count=1) at /home/teawater/kernel/linux/fs/read_write.c:469
+#2  <signal handler called>
+#3  0x00007f77331d7d10 in ?? ()
+#4  0x0000000000000000 in ?? ()
+如何使用 add-ons/hotcode.py
+这个脚本可以通过记录并分析中断处理时候的取得的PC值从而得到Linux kernel或者用户层程序的热点代码。
+请到 http://code.google.com/p/kgtp/wiki/hotcode 去看如何使用它。
+
+如何增加用C写的插件
+KGTP支持用C写的插件，插件将被编译成LKM。 KGTP support plugin that write in C. The plugin will be built as LKM
+
+API
+#include "gtp.h"
+这是插件需要的包含API的头文件。 
+
+extern int gtp_plugin_mod_register(struct module *mod);
+extern int gtp_plugin_mod_unregister(struct module *mod);
+这两个函数注册和注销插件模块。这样KGTP就可以在访问插件模块资源的时候增加其的引用计数了。 
+
+extern struct gtp_var *gtp_plugin_var_add(char *name, int64_t val,
+                                          struct gtp_var_hooks *hooks);
+这个函数会增加特殊trace状态变量到KGTP。
+
+name 特殊trace状态变量的名字.
+val 特殊trace状态变量的初始值.
+hooks 函数指针。如果这个功能不支持，函数指针就设置为NULL。
+返回值 成功返回gtp_var指针。失败则返回用IS_ERR和PTR_ERR可以处理的错误码。
+
+
+struct gtp_var_hooks {
+        int     (*gdb_set_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+                               int64_t val);
+        int     (*gdb_get_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+                               int64_t *val);
+        int     (*agent_set_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+                                 int64_t val);
+        int     (*agent_get_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+                                 int64_t *val);
+};
+gdb_set_val 在GDB设置TSV值的时候调用，请 注意 TSV只能被GDB命令"tvariable $xxx=1"设置而且只有在GDB命令"tstart"的时候才会被发到KGTP。
+unused 是无用的，只用来让这个指针可以和agent_set_val共享函数。
+var 是指向gtp_var的指针，于是当多个TSV共享一个函数的时候，这个值可以用来判定哪个TSV被访问了。
+val 是GDB设置来的值。
+返回值 错误返回-1，正确返回0。
+gdb_get_val 在GDB取TSV值的时候被调用。请 注意 取TSV值和设置TSV不同，设置任何时候都会直接从KGTP里取，并且取值的GDB命令和访问一个普通的GDB内部变量一样。例如："p $xxx"。
+unused 和gdb_set_val作用相同。
+var 和gdb_set_val作用相同。
+val 用来返回值的指针。
+返回值 和gdb_set_val作用相同。
+agent_set_val 在tracepoint action(http://code.google.com/p/kgtp/wiki/HOWTOCN#teval_expr1,_expr2,_...)设置TSV的时候调用。
+gts 是指向tracepoint会话结构的指针。
+var 和gdb_set_val作用相同。
+val action设置的值。
+返回值 和gdb_set_val作用相同。
+agent_get_val will be called when tracepoint action(http://code.google.com/p/kgtp/wiki/HOWTOCN#collect_expr1,_expr2,_... 或者 HOWTO#teval_expr1,_expr2,_...) get the TSV.
+gts 和agent_set_val作用相同。
+var 和gdb_set_val作用相同。
+val 和gdb_get_val作用相同。
+返回值 和gdb_set_val作用相同。
+
+
+extern int gtp_plugin_var_del(struct gtp_var *var);
+当rmmod插件模块的时候，用这个函数删除gtp_plugin_var_add增加的TSV。 
+
+例子
+KGTP目录里的plugin_example.c是KGTP plugin的例子，可以用"make P=1"直接编译其。其将增加四个TSV到KGTP中。
+
+$test1 什么也不支持。
+$test2 支持被GDB或者tracepoint action读写。
+$test3 只支持tracepoint action写，当设置一个值到里面的时候，其将找到这个值对应的符号并打印出来。例如 "teval $test3=(int64_t)$rip"。
+$test4 只支持tracepoint action写，当设置值的时候其将打印当前tracepoint的地址的符号。
+如何使用
+安装KGTP模块 http://code.google.com/p/kgtp/wiki/HOWTOCN#执行
+insmod plugin_example.ko
+让GDB连上KGTP并使用其。
+断开GDB. 如果 http://code.google.com/p/kgtp/wiki/HOWTOCN#GDB断开的时候不要停止tracepoint 中的选项设置为打开，则设置其为关闭。
+rmmod plugin_example.ko
+请 注意 KGTP支持加入多个插件。
+
+如何使用性能计数器
+性能计数器是大部分现代CPU都有的特殊硬件寄存器。这些寄存器对一些硬件事件进行计数：例如指令执行数量，cachemisses数量，分支预测失败数，而且这些计数不会让应用程序或者内核变慢。其还可以设置到达一定的值的时候发生中断，这些就可以用来分析在某CPU上执行程序的性能。
+Linux性能计数器子系统perf event可以用来取得性能计数器的值。你可以用KGTP perf event trace状态变量访问这些值。
+请读内核目录里的tools/perf/design.txt文件取得perf event的更多信息。
+
+定义一个perf event trace状态变量
+访问一个性能计数器需要定义下面的trace状态变量：
+
+"pe_cpu_"+tv_name       定义性能计数器的CPU ID。
+"pe_type_"+tv_name      定义性能计数器的类型。
+"pe_config_"+tv_name    定义性能计数器的配置。
+"pe_en_"+tv_name        定义性能计数器的启动开关。
+                        默认情况下性能计数器是关闭的。
+"pe_val_"+tv_name       访问这个变量能取得性能计数器的值。
+定义一个per_cpu perf event trace状态变量
+定义一个per_cpu perf event trace状态变量和http://code.google.com/p/kgtp/wiki/HOWTOCN#Per_cpu_trace状态变量一样。
+
+"p_pe_"+perf_event type+string+CPU_id
+请 注意 如果定义一个per_cpu perf event trace状态变量，就不需要在定义cpu id("pe_cpu")因为KGTP已经取得了CPU的ID。
+
+perf event的类型和配置
+类型可以是：
+
+0       PERF_TYPE_HARDWARE
+1       PERF_TYPE_SOFTWARE
+2       PERF_TYPE_TRACEPOINT
+3       PERF_TYPE_HW_CACHE
+4       PERF_TYPE_RAW
+5       PERF_TYPE_BREAKPOINT
+如果类型是0(PERF_TYPE_HARDWARE)，配置可以是：
+
+0       PERF_COUNT_HW_CPU_CYCLES
+1       PERF_COUNT_HW_INSTRUCTIONS
+2       PERF_COUNT_HW_CACHE_REFERENCES
+3       PERF_COUNT_HW_CACHE_MISSES
+4       PERF_COUNT_HW_BRANCH_INSTRUCTIONS
+5       PERF_COUNT_HW_BRANCH_MISSES
+6       PERF_COUNT_HW_BUS_CYCLES
+7       PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
+8       PERF_COUNT_HW_STALLED_CYCLES_BACKEND
+
+如果类型是3(PERF_TYPE_HW_CACHE)，配置要分为3部分： 第一部分是cache id，其在设置进配置的时候需要 << 0：
+
+0       PERF_COUNT_HW_CACHE_L1D
+1       PERF_COUNT_HW_CACHE_L1I
+2       PERF_COUNT_HW_CACHE_LL
+3       PERF_COUNT_HW_CACHE_DTLB
+4       PERF_COUNT_HW_CACHE_ITLB
+5       PERF_COUNT_HW_CACHE_BPU
+第二部分是cache op id，其在设置进配置的时候需要 << 8：
+
+0       PERF_COUNT_HW_CACHE_OP_READ
+1       PERF_COUNT_HW_CACHE_OP_WRITE
+2       PERF_COUNT_HW_CACHE_OP_PREFETCH
+第三部分是cache op result id，其在设置进配置的时候需要 << 16：
+
+0       PERF_COUNT_HW_CACHE_RESULT_ACCESS
+1       PERF_COUNT_HW_CACHE_RESULT_MISS
+如果你想取得PERF_COUNT_HW_CACHE_L1I(1), PERF_COUNT_HW_CACHE_OP_WRITE(1) and PERF_COUNT_HW_CACHE_RESULT_MISS(1)你需要使用：
+
+(gdb) tvariable $pe_config_cache=1 | (1 << 8) | (1 << 16)
+内核目录中的tools/perf/design.txt是关于perf event的类型和配置。
+
+用$p_pe_en打开和关闭一个CPU上所有的perf event
+我认为取得一段代码的性能计数器信息比较好的办法是在函数开头打开计数器在函数结束的时候关闭计数器。你可以用"pe_en"设置他们，但是如果你有多个perf event trace状态变量的时候，这样会让tracepoint action很大。$p_pe_en就是处理这种问题的。 你可以打开所有perf event trace状态变量在当前CPU上用下面的action：
+
+>teval $p_pe_en=1
+设置$p_pe_en为0来关闭他们。
+
+>teval $p_pe_en=0
+用来帮助设置和取得perf event trace状态变量的GDB脚本
+下面这个GDB脚本定义了2个命令dpe和spe来帮助定义和显示perf event trace状态变量。
+你可以把他们存在~/.gdbinit或者你自己的tracepoint脚本中。于是你就可以在GDB中直接使用这2个命令。
+
+define dpe
+  if ($argc < 2)
+    printf "Usage: dpe pe_type pe_config [enable]\n"
+  end
+  if ($argc >= 2)
+    eval "tvariable $p_pe_val_%d%d_c",$arg0, $arg1
+    eval "tvariable $p_pe_en_%d%d_c",$arg0, $arg1
+    set $tmp=0
+    while $tmp<$cpu_number
+      eval "tvariable $p_pe_type_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg0
+      eval "tvariable $p_pe_config_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg1
+      eval "tvariable $p_pe_val_%d%d_c%d=0",$arg0, $arg1, $tmp
+      if ($argc >= 3)
+        eval "tvariable $p_pe_en_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg2
+      end
+      set $tmp=$tmp+1
+    end
+  end
+end
+
+document dpe
+Usage: dpe pe_type pe_config [enable]
+end
+
+define spe
+  if ($argc != 2 && $argc != 3)
+    printf "Usage: spe pe_type pe_config [cpu_id]\n"
+  end
+  if ($argc == 2)
+    set $tmp=0
+    while $tmp<$cpu_number
+      eval "printf \"$p_pe_val_%%d%%d_c%%d=%%ld\\n\",$arg0, $arg1, $tmp, $p_pe_val_%d%d_c%d", $arg0, $arg1, $tmp
+      set $tmp=$tmp+1
+    end
+  end
+  if ($argc == 3)
+    eval "printf \"$p_pe_val_%%d%%d_c%%d=%%ld\\n\",$arg0, $arg1, $tmp, $p_pe_val_%d%d_c%d", $arg0, $arg1, $arg2
+  end
+end
+
+document spe
+Usage: spe pe_type pe_config [cpu_id]
+end
+下面是一个取得函数tcp_v4_rcv性能计数器的例子：
+
+#连接KGTP
+(gdb) target remote /sys/kernel/debug/gtp
+#定义3个perf event trace状态变量PERF_COUNT_HW_CPU_CYCLES，PERF_COUNT_HW_CACHE_MISSES和PERF_COUNT_HW_BRANCH_MISSES。
+(gdb) dpe 0 0
+(gdb) dpe 0 3
+(gdb) dpe 0 5
+#在函数开头打开这个CPU的性能寄存器
+(gdb) trace tcp_v4_rcv
+(gdb) action
+>teval $p_pe_en=1
+>end
+#$kret 让我们可以处理到函数tcp_v4_rcv的结尾：
+(gdb) trace *(tcp_v4_rcv)
+(gdb) action
+>teval $kret=0
+#关闭这个CPU上的所有性能计数器
+>teval $p_pe_en=0
+#访问这些perf event trace状态变量将取得他们的值
+>collect $p_pe_val_00_0
+>collect $p_pe_val_03_0
+>collect $p_pe_val_05_0
+#设置这些perf event trace状态变量为0
+>teval $p_pe_val_00_0=0
+>teval $p_pe_val_03_0=0
+>teval $p_pe_val_05_0=0
+>end
+tstart
+#等一会让每个CPU收一些TCP包
+(gdb) tstop
+(gdb) tfind
+(gdb) spe 0 0 $cpu_id
+$p_pe_val_00_2=12676
+(gdb) spe 0 3 $cpu_id
+$p_pe_val_03_2=7
+(gdb) spe 0 5 $cpu_id
+$p_pe_val_05_2=97
--- /dev/null
+++ b/Documentation/gtp/quickstart.txt
@@ -0,0 +1,250 @@
+		Linux Kernel GDB tracepoint module (KGTP) quick start
+		=====================================================
+		By Hui Zhu <teawater@gmail.com>
+		https://code.google.com/p/kgtp/wiki/Quickstart
+		2011-09-12
+
+Table of contents
+-----------------
+Ubuntu
+Fedora
+
+
+
+
+Ubuntu
+------
+
+Install GDB for KGTP
+--------------------
+
+This GDB's filename is different with the current GDB that you are using.
+So please don't worry that it affect current GDB that your are using.
+
+For the Ubuntu 10.04 or later, running the following line at a terminal:
+sudo add-apt-repository ppa:teawater/gdb-$(lsb_release -rs)
+sudo apt-get update
+sudo apt-get install gdb-release
+
+For the Ubuntu older than 10.04, please go to https://code.google.com/p/gdbt/
+get howto install GDB for KGTP from source.
+
+
+
+Install Linux kernel packages that KGTP need
+--------------------------------------------
+
+Please ignore this section if the Linux kernel of your system is built by
+yourself.
+
+Install the Linux kernel debug image
+------------------------------------
+
+Add debug source to the sources list of Ubuntu
+----------------------------------------------
+
+Create an /etc/apt/sources.list.d/ddebs.list by running the following line at
+a terminal:
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+
+Stable releases (not alphas and betas) require three more lines adding to the
+same file, which is done by the following terminal command:
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-security main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+
+Import the debug symbol archive signing key:
+sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 428D7C01
+
+Then run:
+sudo apt-get update
+
+Get Linux kernel debug image
+----------------------------
+sudo apt-get install linux-image-$(uname -r)-dbgsym
+
+
+Install the Linux kernel headers
+--------------------------------
+
+Please ignore this section if the Linux kernel of your system is built by
+yourself.
+sudo apt-get install linux-headers-generic
+
+
+Install the Linux kernel source
+-------------------------------
+
+Install the source package:
+sudo apt-get install linux-source
+
+Uncompress the source package:
+sudo mkdir -p /build/buildd/
+sudo tar vxjf /usr/src/linux-source-$(uname -r | sed 's/-.*//').tar.bz2 -C /build/buildd/
+sudo mv /build/buildd/linux-source-$(uname -r | sed 's/-.*//') /build/buildd/linux-$(uname -r | sed 's/-.*//')
+
+
+
+Install GCC
+-----------
+
+sudo apt-get install gcc
+
+
+
+Get and build KGTP
+------------------
+
+Install subversion:
+sudo apt-get install subversion
+
+Get the source of KGTP with subversion and put it to directory "kgtp":
+svn checkout https://kgtp.googlecode.com/svn/trunk kgtp
+
+Build KGTP:
+cd kgtp
+make
+
+
+
+Use KGTP
+--------
+
+Mount the sysfs and debugfs:
+sudo mount -t sysfs none /sys/
+sudo mount -t debugfs none /sys/kernel/debug/
+
+Insert the KGTP module to the current Linux Kernel:
+cd kgtp
+sudo insmod gtp.ko
+
+Use GDB connect to KGTP:
+sudo gdb-release /usr/lib/debug/boot/vmlinux-$(uname -r)
+(gdb) target remote /sys/kernel/debug/gtp
+
+Do a very simple trace:
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xc02289f0: file /build/buildd/linux-2.6.35/fs/readdir.c, line 23.
+(gdb) actions
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $reg
+>end
+(gdb) tstart
+(gdb) shell ls
+vmlinux-2.6.35-30-generic
+(gdb) tstop
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0x0, filler=0x163d8ae3, buf=0x18c0) at readdir.c:23
+23      {
+
+
+
+End
+---
+
+Now, you can begin to rock and roll your Linux kernel with KGTP and GDB.
+Please go to see gtp.txt to get more message about howto use KGTP.
+
+
+
+
+Fedora
+------
+
+Install GDB for KGTP
+--------------------
+
+Please go to https://code.google.com/p/gdbt/ get howto install GDB for KGTP
+from source.
+
+
+
+Install Linux kernel packages that KGTP need
+--------------------------------------------
+
+Please ignore this section if the Linux kernel of your system is built
+by yourself.
+
+
+Install the Linux kernel debug image
+------------------------------------
+
+sudo yum --enablerepo=fedora-debuginfo install kernel-debuginfo
+
+
+Install the Linux kernel devel package
+--------------------------------------
+
+sudo yum install kernel-devel-$(uname -r)
+
+
+
+Install GCC
+-----------
+
+sudo yum install gcc
+
+
+
+Get and build KGTP
+------------------
+
+Install subversion:
+sudo yum install subversion
+
+Get the source of KGTP with subversion and put it to directory "kgtp":
+svn checkout https://kgtp.googlecode.com/svn/trunk kgtp
+
+Build KGTP:
+cd kgtp
+make
+
+
+
+Use KGTP
+--------
+
+Mount the sysfs and debug fs:
+sudo mount -t sysfs none /sys/
+sudo mount -t debugfs none /sys/kernel/debug/
+
+Insert the KGTP module to the current Linux Kernel:
+cd kgtp
+sudo insmod gtp.ko
+
+Use GDB connect to KGTP:
+sudo gdb-release /usr/lib/debug/lib/modules/$(uname -r)/vmlinux
+(gdb) target remote /sys/kernel/debug/gtp
+
+Do a very simple trace:
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8110ec9b: file fs/readdir.c, line 23.
+(gdb) actions
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $reg
+>end
+(gdb) tstart
+(gdb) shell ls
+co.patch                  getframe      getmod.c   gtp.mod.c  gtp.txt         perf_event.c
+dkms.conf                 getframe.c    getmod.py  gtp.mod.o  Makefile        ring_buffer.c
+dkms_others_install.sh    getgtprsp.pl  gtp.c      gtp.o      modules.order   ring_buffer.h
+dkms_others_uninstall.sh  getmod        gtp.ko     gtp.patch  Module.symvers
+(gdb) tstop
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880019d3df00, filler=0xffffffff8110eb16 <filldir>, buf=0xffff880003b39f38)
+    at fs/readdir.c:23
+23      {
+
+
+
+End
+---
+
+Now, you can begin to rock and roll your Linux kernel with KGTP and GDB.
+Please go to HOWTO to get more message about howto use KGTP.
--- a/arch/arm/mm/flush.c
+++ b/arch/arm/mm/flush.c
@@ -251,3 +251,5 @@ void __flush_anon_page(struct vm_area_st
 	 */
 	__cpuc_flush_dcache_page(page_address(page));
 }
+EXPORT_SYMBOL(__flush_anon_page);
+
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -1222,5 +1222,13 @@ do {									\
 	register_cpu_notifier(&fn##_nb);				\
 } while (0)
 
+#ifdef CONFIG_PERF_EVENTS
+extern void perf_event_set(struct perf_event *event, u64 val);
+extern int local_perf_event_enable(void *info);
+extern int local_perf_event_disable(void *info);
+#endif
+
+#define KGTP_API_VERSION	20120917
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_PERF_EVENT_H */
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -37,6 +37,12 @@
 
 #include <asm/irq_regs.h>
 
+#include <linux/version.h>
+#ifndef RHEL_RELEASE_VERSION
+#define RHEL_RELEASE_VERSION(a,b)	(((a) << 8) + (b))
+#define RHEL_RELEASE_CODE		0
+#endif
+
 struct remote_function_call {
 	struct task_struct	*p;
 	int			(*func)(void *info);
@@ -1314,6 +1320,9 @@ static void perf_set_shadow_time(struct
 	else
 		event->shadow_ctx_time = tstamp - ctx->timestamp;
 }
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
+EXPORT_SYMBOL_GPL(perf_event_disable);
+#endif
 
 #define MAX_INTERRUPTS (~0ULL)
 
@@ -1802,6 +1811,9 @@ static void ctx_sched_out(struct perf_ev
 	}
 	perf_pmu_enable(ctx->pmu);
 }
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
+EXPORT_SYMBOL_GPL(perf_event_enable);
+#endif
 
 /*
  * Test whether two contexts are equivalent, i.e. whether they
@@ -3187,6 +3199,14 @@ static void perf_event_reset(struct perf
 	perf_event_update_userpage(event);
 }
 
+void perf_event_set(struct perf_event *event, u64 val)
+{
+	(void)perf_event_read(event);
+	local64_set(&event->count, val);
+	perf_event_update_userpage(event);
+}
+EXPORT_SYMBOL_GPL(perf_event_set);
+
 /*
  * Holding the top-level event's child_mutex means that any
  * descendant process that has inherited this event will block
@@ -7552,3 +7572,15 @@ struct cgroup_subsys perf_subsys = {
 	.attach		= perf_cgroup_attach,
 };
 #endif /* CONFIG_CGROUP_PERF */
+
+int local_perf_event_enable(void *info)
+{
+	return __perf_event_enable(info);
+}
+EXPORT_SYMBOL_GPL(local_perf_event_enable);
+
+int local_perf_event_disable(void *info)
+{
+	return __perf_event_disable(info);
+}
+EXPORT_SYMBOL_GPL(local_perf_event_disable);
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1132,6 +1132,16 @@ config DMA_API_DEBUG
 	  This option causes a performance degredation.  Use only if you want
 	  to debug device drivers. If unsure, say N.
 
+config GTP
+	tristate "GDB tracepoint support"
+	depends on X86 || ARM || MIPS
+	select KPROBES
+	select DEBUG_FS
+	---help---
+	  Supply GDB tracepoint interface in /sys/kernel/debug/gtp.
+	  See Documentation/trace/gtp.txt or
+	  https://code.google.com/p/kgtp/wiki/HOWTO for more info.
+
 source "samples/Kconfig"
 
 source "lib/Kconfig.kgdb"
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -99,6 +99,8 @@ obj-$(CONFIG_GENERIC_CSUM) += checksum.o
 
 obj-$(CONFIG_GENERIC_ATOMIC64) += atomic64.o
 
+obj-$(CONFIG_GTP) += gtp.o
+
 hostprogs-y	:= gen_crc32table
 clean-files	:= crc32table.h
 
--- /dev/null
+++ b/lib/gtp.c
@@ -0,0 +1,12890 @@
+/*
+ * Kernel GDB tracepoint module.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright(C) KGTP team (https://code.google.com/p/kgtp/), 2010-2013
+ *
+ */
+
+/* If "* 10" means that this is not a release version.  */
+#define GTP_VERSION			(20130508)
+
+#include <linux/version.h>
+#ifndef RHEL_RELEASE_VERSION
+#define RHEL_RELEASE_VERSION(a,b)	(((a) << 8) + (b))
+#define RHEL_RELEASE_CODE		0
+#endif
+
+/* Sepcial config ------------------------------------------------ */
+#define GTP_RB
+
+#ifdef GTP_FRAME_SIMPLE
+/* This is a debug option.
+   This define is for simple frame alloc record, then we can get how many
+   memory are weste by FRAME_ALIGN. */
+/* #define FRAME_ALLOC_RECORD */
+#undef GTP_RB
+#endif
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#undef GTP_RB
+#endif
+
+/* If define USE_PROC, KGTP will use ProcFS instead DebugFS.  */
+#ifndef GTP_NO_AUTO_BUILD
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11))
+#define USE_PROC
+#endif
+#endif
+#ifndef USE_PROC
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11))
+#warning If got some build error about debugfs, you can use "USE_PROC=1" handle it.
+#endif
+#endif
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
+#warning If got some build error about ring buffer, you can use "FRAME_SIMPLE=1" handle it.
+#endif
+#endif
+
+/* If define GTP_CLOCK_CYCLE, $clock will return rdtscll.  */
+#ifndef GTP_NO_AUTO_BUILD
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#define GTP_CLOCK_CYCLE
+#endif
+#endif
+#ifndef GTP_CLOCK_CYCLE
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#warning If got some build error about cpu_clock or local_clock, you can use "CLOCK_CYCLE=1" handle it.
+#endif
+#endif
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#ifndef CONFIG_RING_BUFFER
+#define CONFIG_RING_BUFFER
+#include "ring_buffer.h"
+#include "ring_buffer.c"
+#define GTP_SELF_RING_BUFFER
+#warning Use the ring buffer inside KGTP.
+#endif
+#endif
+/* Sepcial config ------------------------------------------------ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/kprobes.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <asm/atomic.h>
+#ifdef CONFIG_X86
+#include <asm/debugreg.h>
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
+#include <linux/kdebug.h>
+#else
+#include <asm/kdebug.h>
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+#include <linux/hw_breakpoint.h>
+#endif
+#include "gtp.h"
+#ifdef GTP_FTRACE_RING_BUFFER
+#ifndef GTP_SELF_RING_BUFFER
+#include <linux/ring_buffer.h>
+#endif
+#endif
+#ifdef CONFIG_PERF_EVENTS
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)) \
+    && (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,1))
+#warning "Current Kernel is too old.  Function of performance counters is not available."
+#else
+#include <linux/perf_event.h>
+#define GTP_PERF_EVENTS
+#endif
+#else
+#warning "Current Kernel doesn't open CONFIG_PERF_EVENTS.  Function of performance counters is not available."
+#endif
+
+#ifndef __percpu
+#define __percpu
+#endif
+
+#ifndef this_cpu_ptr
+#define this_cpu_ptr(v)	per_cpu_ptr(v, smp_processor_id())
+#endif
+
+#define KERN_NULL
+
+/* check ---------------------------------------------------------- */
+#ifndef CONFIG_KPROBES
+#error "Linux Kernel doesn't support KPROBES.  Please open it in 'General setup->Kprobes'."
+#endif
+
+#ifdef USE_PROC
+#ifndef CONFIG_PROC_FS
+#error "Linux Kernel doesn't support procfs."
+#endif
+#else
+#ifndef CONFIG_DEBUG_FS
+#error "Linux Kernel doesn't support debugfs."
+#endif
+#endif
+
+#if !defined CONFIG_X86 && !defined CONFIG_MIPS && !defined CONFIG_ARM
+#error "KGTP support X86_32, X86_64, MIPS and ARM."
+#endif
+/* ---------------------------------------------------------------- */
+
+#ifdef KGTP_API_VERSION
+#define KGTP_API_VERSION_LOCAL	KGTP_API_VERSION
+#else
+#define KGTP_API_VERSION_LOCAL	0
+#endif
+
+#ifndef DEFINE_SEMAPHORE
+#define DEFINE_SEMAPHORE(name)	DECLARE_MUTEX(name)
+#endif
+
+#ifdef GTPDEBUG
+#define GTP_DEBUG		KERN_WARNING
+#endif
+
+#ifndef list_first_entry
+#define list_first_entry(ptr, type, member) \
+	list_entry((ptr)->next, type, member)
+#endif
+
+/* #define GTP_DEBUG_V */
+
+#define GTP_RW_MAX		16384
+#define GTP_RW_BUFP_MAX		(GTP_RW_MAX - 4 - gtp_rw_size)
+
+#define FID_TYPE		unsigned int
+#define FID_SIZE		sizeof(FID_TYPE)
+#define FID(x)			(*((FID_TYPE *)x))
+enum {
+	FID_HEAD = 0,
+	FID_REG,
+	FID_MEM,
+	FID_VAR,
+	FID_END,
+	FID_PAGE_BEGIN,
+	FID_PAGE_END,
+};
+
+/* GTP_FRAME_SIZE must align with FRAME_ALIGN_SIZE if use GTP_FRAME_SIMPLE.  */
+#define GTP_FRAME_SIZE		5242880
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#define FRAME_ALIGN_SIZE	sizeof(unsigned int)
+#define FRAME_ALIGN(x)		((x + FRAME_ALIGN_SIZE - 1) \
+				 & (~(FRAME_ALIGN_SIZE - 1)))
+#endif
+#ifdef GTP_FRAME_SIMPLE
+#define GTP_FRAME_HEAD_SIZE	(FID_SIZE + sizeof(char *) + sizeof(ULONGEST))
+#define GTP_FRAME_REG_SIZE	(FID_SIZE + sizeof(char *) \
+				 + sizeof(struct pt_regs))
+#define GTP_FRAME_MEM_SIZE	(FID_SIZE + sizeof(char *) \
+				 + sizeof(struct gtp_frame_mem))
+#define GTP_FRAME_VAR_SIZE	(FID_SIZE + sizeof(char *) \
+				 + sizeof(struct gtp_frame_var))
+#endif
+#ifdef GTP_RB
+/* The frame head size: FID_HEAD + count id + frame number + pointer to prev frem */
+#define GTP_FRAME_HEAD_SIZE	(FID_SIZE + sizeof(u64) + sizeof(ULONGEST) + sizeof(void *))
+/* The frame head size: FID_PAGE_BEGIN + count id */
+#define GTP_FRAME_PAGE_BEGIN_SIZE	(FID_SIZE + sizeof(u64))
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+#define GTP_FRAME_HEAD_SIZE	(FID_SIZE + sizeof(ULONGEST))
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+#define GTP_FRAME_REG_SIZE	(FID_SIZE + sizeof(struct pt_regs))
+#define GTP_FRAME_MEM_SIZE	(FID_SIZE + sizeof(struct gtp_frame_mem))
+#define GTP_FRAME_VAR_SIZE	(FID_SIZE + sizeof(struct gtp_frame_var))
+#endif
+
+#define INT2CHAR(h)		((h) > 9 ? (h) + 'a' - 10 : (h) + '0')
+
+enum {
+	op_check_add = 0xe0,
+	op_check_sub,
+	op_check_mul,
+	op_check_div_signed,
+	op_check_div_unsigned,
+	op_check_rem_signed,
+	op_check_rem_unsigned,
+	op_check_lsh,
+	op_check_rsh_signed,
+	op_check_rsh_unsigned,
+	op_check_trace,
+	op_check_bit_and,
+	op_check_bit_or,
+	op_check_bit_xor,
+	op_check_equal,
+	op_check_less_signed,
+	op_check_less_unsigned,
+	op_check_pop,
+	op_check_swap,
+	op_check_if_goto,
+	op_check_printf,	/* XXX: still not used.  */
+
+	op_trace_printk = 0xfd,
+	op_trace_quick_printk,
+	op_tracev_printk,
+};
+
+struct action_agent_exp {
+	unsigned int	size;
+	uint8_t		*buf;
+	int		need_var_lock;
+};
+
+struct action_m {
+	int		regnum;
+	CORE_ADDR	offset;
+	size_t		size;
+};
+
+struct action {
+	struct action	*next;
+	unsigned char	type;
+	union {
+		ULONGEST		reg_mask;
+		struct action_agent_exp	exp;
+		struct action_m		m;
+	} u;
+};
+
+struct gtpsrc {
+	struct gtpsrc	*next;
+	char		*src;
+};
+
+enum gtp_stop_type {
+	gtp_stop_normal = 0,
+	gtp_stop_frame_full,
+	gtp_stop_efault,
+	gtp_stop_access_wrong_reg,
+	gtp_stop_agent_expr_code_error,
+	gtp_stop_agent_expr_stack_overflow,
+};
+
+/* See $current.  */
+#define GTP_ENTRY_FLAGS_CURRENT_TASK	1
+/* This gtp entry is registered inside the system.  */
+#define GTP_ENTRY_FLAGS_REG		2
+/* See $no_self_trace.  */
+#define GTP_ENTRY_FLAGS_SELF_TRACE	4
+/* This gtp entry has passcount.  */
+#define GTP_ENTRY_FLAGS_HAVE_PASS	8
+/* See $printk_level.  */
+#define GTP_ENTRY_FLAGS_HAVE_PRINTK	16
+/* See $kret.  */
+#define GTP_ENTRY_FLAGS_IS_KRETPROBE	32
+
+enum gtp_entry_type {
+	/* Normal tracepoint.  */
+	gtp_entry_kprobe = 0,
+
+	/* Watch.  */
+	gtp_entry_watch_static,
+	gtp_entry_watch_dynamic,
+};
+
+enum gtp_watch_type {
+	gtp_watch_exec		= 0,
+	gtp_watch_write		= 1,
+	gtp_watch_read_write	= 2,
+};
+
+struct gtp_entry {
+	union gtp_entry_u {
+		/* For gtp_entry_kprobe.  */
+		struct gtp_kp {
+			struct kretprobe	kpret;
+			struct tasklet_struct	stop_tasklet;
+			struct work_struct	stop_work;
+		} kp;
+
+		/* For gtp_entry_watch_static and gtp_entry_watch_dynamic.  */
+		struct {
+			int type;
+			int size;
+		} watch;
+	} u;
+	unsigned long		flags;
+	enum gtp_entry_type	type;
+	ULONGEST		num;
+	ULONGEST		addr;
+
+	struct action		*cond;
+	struct action		*action_list;
+	int			step;
+	struct action		*step_action_list;
+
+	atomic_t		current_pass;
+	struct gtpsrc		*printk_str;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	/* This is to enable and disable an tracepoint.  */
+	struct tasklet_struct	enable_tasklet;
+	struct work_struct	enable_work;
+	struct tasklet_struct	disable_tasklet;
+	struct work_struct	disable_work;
+#endif
+	enum gtp_stop_type	reason;
+
+	struct gtp_entry	*next;
+
+	int			disable;
+	ULONGEST		pass;
+	struct gtpsrc		*src;
+	/* Sometime, it will not same with action
+	   because action will be deleted.  */
+	struct gtpsrc		*action_cmd;
+};
+
+struct gtp_frame_mem {
+	CORE_ADDR	addr;
+	size_t		size;
+};
+
+struct gtp_frame_var {
+	unsigned int	num;
+	int64_t		val;
+};
+
+struct gtpro_entry {
+	struct gtpro_entry	*next;
+	CORE_ADDR		start;
+	CORE_ADDR		end;
+};
+
+static pid_t			gtp_gtp_pid;
+static unsigned int		gtp_gtp_pid_count;
+static pid_t			gtp_gtpframe_pid;
+static unsigned int		gtp_gtpframe_pid_count;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+static pid_t			gtp_gtpframe_pipe_pid;
+#endif
+
+static struct gtp_entry		*gtp_list;
+static struct gtp_entry		*current_gtp;
+static struct gtpsrc		*current_gtp_action_cmd;
+static struct gtpsrc		*current_gtp_src;
+
+static struct workqueue_struct	*gtp_wq;
+
+static int			gtp_read_ack;
+static char			*gtp_rw_buf;
+static char			*gtp_rw_bufp;
+static size_t			gtp_rw_size;
+
+static int			gtp_start;
+
+static int			gtp_disconnected_tracing;
+static int			gtp_circular;
+#if defined(GTP_FTRACE_RING_BUFFER)			\
+    && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))	\
+    && !defined(GTP_SELF_RING_BUFFER)
+static int			gtp_circular_is_changed;
+#endif
+
+static int			gtp_cpu_number;
+
+/* Current number in the frame.  */
+static int			gtp_frame_current_num;
+/* Current tracepoint id.  */
+static ULONGEST			gtp_frame_current_tpe;
+static atomic_t			gtp_frame_create;
+static char			*gtp_frame_file;
+static size_t			gtp_frame_file_size;
+static DECLARE_WAIT_QUEUE_HEAD(gtpframe_wq);
+#ifdef GTP_FRAME_SIMPLE
+static DEFINE_SPINLOCK(gtp_frame_lock);
+static char			*gtp_frame;
+static char			*gtp_frame_r_start;
+static char			*gtp_frame_w_start;
+static char			*gtp_frame_end;
+static int			gtp_frame_is_circular;
+static char			*gtp_frame_current;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+static struct ring_buffer	*gtp_frame;
+static struct ring_buffer_iter	*gtp_frame_iter[NR_CPUS];
+static int			gtp_frame_current_cpu;
+static u64			gtp_frame_current_clock;
+#endif
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+static DECLARE_WAIT_QUEUE_HEAD(gtpframe_pipe_wq);
+static atomic_t			gtpframe_pipe_wq_v;
+static struct tasklet_struct	gtpframe_pipe_wq_tasklet;
+#endif
+
+static struct gtpro_entry	*gtpro_list;
+
+#define GTP_PRINTF_MAX		256
+static DEFINE_PER_CPU(char[GTP_PRINTF_MAX], gtp_printf);
+
+#ifdef CONFIG_X86
+static DEFINE_PER_CPU(u64, rdtsc_current);
+static DEFINE_PER_CPU(u64, rdtsc_offset);
+#endif
+static DEFINE_PER_CPU(u64, local_clock_current);
+static DEFINE_PER_CPU(u64, local_clock_offset);
+
+static uint64_t			gtp_start_last_errno;
+static int			gtp_start_ignore_error;
+
+static int			gtp_pipe_trace;
+
+static int			gtp_bt_size;
+
+static int			gtp_noack_mode;
+
+static pid_t			gtp_current_pid;
+
+#ifdef CONFIG_X86
+/* Following part is for while-stepping.  */
+struct gtp_step_s {
+	spinlock_t		lock;
+	int			step;
+	int			irq_need_open;
+	struct gtp_entry	*tpe;
+};
+static DEFINE_PER_CPU(struct gtp_step_s, gtp_step);
+#endif
+
+#ifdef CONFIG_X86
+static int	gtp_have_watch_tracepoint;
+static int	gtp_have_step;
+#endif
+
+#ifdef CONFIG_X86
+/* Following part is for watch tracepoint.  */
+/* This part is X86 special.  */
+#define HWB_NUM			4
+
+static unsigned long		gtp_hwb_drx[HWB_NUM];
+static unsigned long		gtp_hwb_dr7;
+
+#define GTP_HWB_DR7_DEF		(0x400UL)
+#define GTP_HWB_DR6_MASK	(0xe00fUL)
+
+/* This part is for all the arch.  */
+struct gtp_hwb_s {
+	struct list_head	node;
+
+	/* This is the number of this hardware breakpoint.  */
+	int			num;
+
+	/* This is the address, size and type of this
+	   hardware breakpoint.  */
+	CORE_ADDR		addr;
+	int			size;
+	int			type;
+
+	/* This is the num and address that setup this hardware
+	   breakpoints.
+	   For the static watch, this is the num and address of this
+	   tracepoint.
+	   For the dynamic watch, this is the num and address of
+	   the tracepoint that call $watch_start.  */
+	ULONGEST		trace_num;
+	ULONGEST		trace_addr;
+
+	unsigned int		count;
+
+	/* Point to the watchpoint struct.
+	   If NULL, this hardware breakpoint is not used.  */
+	struct gtp_entry	*watch;
+};
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+static struct hw_breakpoint {
+	int			num;
+	struct perf_event	* __percpu *pev;
+} breakinfo[HWB_NUM];
+#endif
+
+static struct gtp_hwb_s	gtp_hwb[HWB_NUM];
+
+static LIST_HEAD(gtp_hwb_used_list);
+static LIST_HEAD(gtp_hwb_unused_list);
+
+static DEFINE_RWLOCK(gtp_hwb_lock);
+
+static unsigned int	gtp_hwb_sync_count;
+static DEFINE_PER_CPU(unsigned int, gtp_hwb_sync_count_local);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static DEFINE_PER_CPU(struct cpumask, gtp_hwb_sync_cpu_mask);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+#define gtp_get_debugreg(val, reg)	get_debugreg(val, reg)
+#define gtp_set_debugreg(val, reg)	set_debugreg(val, reg)
+#else
+#define gtp_get_debugreg(val, reg)		\
+	do {					\
+		switch(reg) {			\
+		case 0:				\
+			get_debugreg(val, 0);	\
+			break;			\
+		case 1:				\
+			get_debugreg(val, 1);	\
+			break;			\
+		case 2:				\
+			get_debugreg(val, 2);	\
+			break;			\
+		case 3:				\
+			get_debugreg(val, 3);	\
+			break;			\
+		}				\
+	} while (0)
+
+static void
+gtp_set_debugreg(unsigned long val, int reg)
+{
+	switch(reg) {
+	case 0:
+		gtp_set_debugreg(val, 0);
+		break;
+	case 1:
+		gtp_set_debugreg(val, 1);
+		break;
+	case 2:
+		gtp_set_debugreg(val, 2);
+		break;
+	case 3:
+		gtp_set_debugreg(val, 3);
+		break;
+	}
+}
+#endif
+
+static void
+gtp_hwb_stop(void *data)
+{
+	read_lock(&gtp_hwb_lock);
+	__get_cpu_var(gtp_hwb_sync_count_local) = gtp_hwb_sync_count;
+	gtp_set_debugreg(0UL, 0);
+	gtp_set_debugreg(0UL, 1);
+	gtp_set_debugreg(0UL, 2);
+	gtp_set_debugreg(0UL, 3);
+	gtp_set_debugreg(GTP_HWB_DR7_DEF, 7);
+	read_unlock(&gtp_hwb_lock);
+}
+
+static void
+gtp_hwb_sync_local(void)
+{
+	__get_cpu_var(gtp_hwb_sync_count_local) = gtp_hwb_sync_count;
+	gtp_set_debugreg(gtp_hwb_drx[0], 0);
+	gtp_set_debugreg(gtp_hwb_drx[1], 1);
+	gtp_set_debugreg(gtp_hwb_drx[2], 2);
+	gtp_set_debugreg(gtp_hwb_drx[3], 3);
+	gtp_set_debugreg(gtp_hwb_dr7, 7);
+}
+
+static void
+gtp_hwb_sync(void *data)
+{
+	gtp_hwb_sync_local();
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int
+gtp_ipi_handler(struct kprobe *p, struct pt_regs *regs)
+{
+	read_lock(&gtp_hwb_lock);
+
+	if (__get_cpu_var(gtp_hwb_sync_count_local) != gtp_hwb_sync_count)
+		gtp_hwb_sync_local();
+
+	read_unlock(&gtp_hwb_lock);
+
+	return 0;
+}
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static struct kprobe gtp_ipi_kp;
+#endif
+#endif
+
+static char *
+string2hex(char *pkg, char *out)
+{
+	char	*ret = out;
+
+	while (pkg[0]) {
+		sprintf(out, "%02x", pkg[0]);
+		pkg++;
+		out += 2;
+	}
+	out[0] = '\0';
+
+	return ret;
+}
+
+/* Strdup begin.  If end is not NULL, it point to the end of this dup.  */
+
+static char *
+gtp_strdup(char *begin, char *end)
+{
+	int	len;
+	char	*ret;
+
+	if (end)
+		len = end - begin;
+	else
+		len = strlen(begin);
+
+	ret = kmalloc(len + 1, GFP_KERNEL);
+	if (ret == NULL)
+		return NULL;
+
+	strncpy(ret, begin, len);
+	ret[len] = '\0';
+
+	return ret;
+}
+
+/* Following part is for GTP_LOCAL_CLOCK.  */
+
+#define GTP_LOCAL_CLOCK	gtp_local_clock()
+#ifdef GTP_CLOCK_CYCLE
+static unsigned long long
+gtp_local_clock(void)
+{
+#ifdef CONFIG_X86
+	unsigned long long a;
+	rdtscll(a);
+	return a;
+#else
+#error "This ARCH cannot get cycle."
+#endif
+}
+#else
+static unsigned long long
+gtp_local_clock(void)
+{
+#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK
+	unsigned long flags;
+	unsigned int cpu;
+
+	local_irq_save(flags);
+	cpu = smp_processor_id();
+	local_irq_restore(flags);
+
+	return cpu_clock(cpu);
+#else
+	return cpu_clock(0);
+#endif	/* CONFIG_HAVE_UNSTABLE_SCHED_CLOCK */
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+static long
+probe_kernel_read(void *dst, void *src, size_t size)
+{
+	long ret;
+	mm_segment_t old_fs = get_fs();
+
+	set_fs(KERNEL_DS);
+
+	/* pagefault_disable();*/
+	inc_preempt_count();
+	barrier();
+
+	ret = __copy_from_user_inatomic(dst,
+			(__force const void __user *)src, size);
+
+	/* pagefault_enable(); */
+	barrier();
+	dec_preempt_count();
+	barrier();
+	preempt_check_resched();
+
+	set_fs(old_fs);
+
+	return ret ? -EFAULT : 0;
+}
+#endif
+
+#ifdef GTP_RB
+#include "gtp_rb.c"
+#endif
+
+/* Following part is for TSV.  */
+
+/* getgtprsp.pl need the ID of TSV.  */
+
+enum {
+	GTP_VAR_VERSION_ID			= 1,
+	GTP_VAR_CPU_ID				= 2,
+	GTP_VAR_CURRENT_TASK_ID			= 3,
+	GTP_VAR_CURRENT_THREAD_INFO_ID		= 4,
+	GTP_VAR_CLOCK_ID			= 5,
+	GTP_VAR_COOKED_CLOCK_ID			= 6,
+#ifdef CONFIG_X86
+	GTP_VAR_RDTSC_ID			= 7,
+	GTP_VAR_COOKED_RDTSC_ID			= 8,
+#endif
+#ifdef GTP_RB
+	GTP_VAR_GTP_RB_DISCARD_PAGE_NUMBER	= 9,
+#endif
+	GTP_VAR_PRINTK_TMP_ID			= 10,
+	GTP_VAR_PRINTK_LEVEL_ID			= 11,
+	GTP_VAR_PRINTK_FORMAT_ID		= 12,
+	GTP_VAR_DUMP_STACK_ID			= 13,
+	GTP_VAR_SELF_TRACE_ID			= 14,
+	GTP_VAR_CPU_NUMBER_ID			= 15,
+	GTP_VAR_PC_PE_EN_ID			= 16,
+	GTP_VAR_KRET_ID				= 17,
+	GTP_VAR_XTIME_SEC_ID			= 18,
+	GTP_VAR_XTIME_NSEC_ID			= 19,
+	GTP_VAR_IGNORE_ERROR_ID			= 20,
+	GTP_VAR_LAST_ERRNO_ID			= 21,
+	GTP_VAR_HARDIRQ_COUNT_ID		= 22,
+	GTP_VAR_SOFTIRQ_COUNT_ID		= 23,
+	GTP_VAR_IRQ_COUNT_ID			= 24,
+	GTP_VAR_PIPE_TRACE_ID			= 25,
+	GTP_VAR_CURRENT_TASK_PID_ID		= 26,
+	GTP_VAR_CURRENT_TASK_USER_ID		= 27,
+	GTP_VAR_CURRENT_ID			= 28,
+	GTP_VAR_BT_ID				= 29,
+
+	GTP_VAR_ENABLE_ID			= 30,
+	GTP_VAR_DISABLE_ID			= 31,
+
+	GTP_WATCH_STATIC_ID			= 32,
+	GTP_WATCH_TYPE_ID			= 33,
+	GTP_WATCH_SIZE_ID			= 34,
+	GTP_WATCH_SET_ID_ID			= 35,
+	GTP_WATCH_SET_ADDR_ID			= 36,
+	GTP_WATCH_START_ID			= 37,
+	GTP_WATCH_STOP_ID			= 38,
+	GTP_WATCH_TRACE_NUM_ID			= 39,
+	GTP_WATCH_TRACE_ADDR_ID			= 40,
+	GTP_WATCH_ADDR_ID			= 41,
+	GTP_WATCH_VAL_ID			= 42,
+	GTP_WATCH_COUNT_ID			= 43,
+
+	GTP_STEP_COUNT_ID			= 44,
+	GTP_STEP_ID_ID				= 45,
+
+	GTP_VAR_SPECIAL_MIN			= GTP_VAR_VERSION_ID,
+	GTP_VAR_SPECIAL_MAX			= GTP_STEP_ID_ID,
+};
+
+enum pe_tv_id {
+	pe_tv_unknown = 0,
+	pe_tv_cpu,
+	pe_tv_type,
+	pe_tv_config,
+	pe_tv_en,
+	pe_tv_val,
+	pe_tv_enabled,
+	pe_tv_running,
+};
+
+enum {
+	gtp_var_normal = 0,
+#ifdef GTP_PERF_EVENTS
+	gtp_var_perf_event,
+	gtp_var_perf_event_per_cpu,
+#endif
+	gtp_var_per_cpu,
+	gtp_var_special,
+};
+
+struct gtp_var;
+
+#ifdef GTP_PERF_EVENTS
+struct gtp_var_perf_event	{
+	struct gtp_var_perf_event	*pc_next;
+	int				en;
+	struct perf_event		*event;
+	int				cpu;
+	u64				val;
+	u64				enabled;	/* The perf inside timer */
+	u64				running;	/* The perf inside timer */
+	char				*name;
+	struct perf_event_attr		attr;
+};
+
+struct gtp_var_pe	{
+	enum pe_tv_id			ptid;
+	struct gtp_var_perf_event	*pe;
+};
+#endif
+
+struct gtp_var_per_cpu {
+	union {
+		int64_t			val;
+#ifdef GTP_PERF_EVENTS
+		struct gtp_var_pe	pe;
+#endif
+	} u;
+};
+
+struct gtp_var_pc {
+	int				cpu;
+	struct gtp_var_per_cpu __percpu	*pc;
+};
+
+struct gtp_var {
+	struct list_head	node;
+	unsigned int		type;
+	unsigned int		num;
+	int64_t			initial_val;
+	char			*src;
+	union {
+		int64_t			val;
+		struct gtp_var_pc	pc;
+#ifdef GTP_PERF_EVENTS
+		struct gtp_var_pe	pe;
+#endif
+		struct gtp_var_hooks	*hooks;
+	} u;
+};
+
+#define gtp_var_get_pc(var)	((struct gtp_var_per_cpu *)((var)->u.pc.cpu < 0 ?  \
+				                            this_cpu_ptr(var->u.pc.pc)  \
+				                            : per_cpu_ptr((var)->u.pc.pc, (var)->u.pc.cpu)))
+#ifdef GTP_PERF_EVENTS
+#define gtp_var_get_pc_pe(var)	(&(gtp_var_get_pc(var)->u.pe))
+#define gtp_var_get_pe(var)	((var)->type == gtp_var_perf_event_per_cpu  \
+				 ? gtp_var_get_pc_pe(var) : &((var)->u.pe))
+#endif
+
+static DEFINE_SPINLOCK(gtp_var_lock);
+static LIST_HEAD(gtp_var_list);
+static unsigned int	gtp_var_num;
+static struct gtp_var	*current_gtp_var;
+static struct gtp_var	**gtp_var_array;
+
+static struct gtp_var *
+gtp_var_find_num(unsigned int num)
+{
+	struct gtp_var		*var;
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		if (var->num == num)
+			return var;
+	}
+
+	return NULL;
+}
+
+static struct gtp_var *
+gtp_var_find_src(char *src)
+{
+	struct gtp_var		*var;
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		if (strcmp (var->src + 2, src + 2) == 0)
+			return var;
+	}
+
+	return NULL;
+}
+
+static int
+gtp_var_array_find_num(struct gtp_var *var)
+{
+	int	i;
+
+	for (i = 0; i < gtp_var_num; i++) {
+		if (gtp_var_array[i] == var)
+			return i;
+	}
+
+	return -1;
+}
+
+static struct gtp_var *
+gtp_var_alloc(int cpu_id, unsigned int num, int num_not_set,
+	      int64_t initial_val, char *src)
+{
+	struct gtp_var	*var;
+
+	if (!num_not_set && gtp_var_find_num(num)) {
+		printk(KERN_WARNING "KGTP: TSV number %d already exist.\n",
+		       num);
+		return ERR_PTR(-EINVAL);
+	}
+	if (strlen(src) < 4) {
+		printk(KERN_WARNING "KGTP: TSV %d's src %s is too short.\n",
+		       num, src);
+		return ERR_PTR(-EINVAL);
+	}
+	if (gtp_var_find_src(src)) {
+		printk(KERN_WARNING "KGTP: TSV src %s already exist.\n",
+		       src);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (cpu_id < 0)
+		var = kzalloc(sizeof(struct gtp_var), GFP_KERNEL);
+	else
+		var = kmalloc_node(sizeof(struct gtp_var),
+				   GFP_KERNEL | __GFP_ZERO,
+				   cpu_to_node(cpu_id));
+	if (var == NULL)
+		return ERR_PTR(-ENOMEM);
+	var->src = gtp_strdup(src, NULL);
+	if (var->src == NULL) {
+		kfree(var);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	var->initial_val = initial_val;
+	if (num_not_set) {
+		num = GTP_VAR_SPECIAL_MAX + 1;
+		while (1) {
+			struct gtp_var		*var;
+			struct list_head	*cur;
+
+			list_for_each(cur, &gtp_var_list) {
+				var = list_entry(cur, struct gtp_var, node);
+				if (var->num == num)
+					break;
+			}
+			if (cur == &gtp_var_list)
+				break;
+			num++;
+		}
+	}
+	var->num = num;
+
+	return var;
+}
+
+static struct gtp_var *
+gtp_var_special_add(unsigned int num, int num_not_set,
+		    int64_t initial_val, char *name,
+		    struct gtp_var_hooks *hooks)
+{
+	int		name_len = strlen(name);
+	char		src[3 + name_len * 2];
+	struct gtp_var	*var;
+
+	if (name_len == 0) {
+		printk(KERN_WARNING "KGTP: TSV name %s len cannot be zero.\n",
+		       name);
+		return ERR_PTR(-EINVAL);
+	}
+
+	strcpy(src, "1:");
+	string2hex (name, src + 2);
+
+	var = gtp_var_alloc(-1, num, num_not_set, initial_val, src);
+	if (IS_ERR(var))
+		return var;
+
+	var->type = gtp_var_special;
+	var->u.hooks = hooks;
+
+	list_add(&var->node, &gtp_var_list);
+	gtp_var_num++;
+
+	return var;
+}
+
+static void
+gtp_var_release(int include_special)
+{
+	struct gtp_var		*var;
+	struct list_head	*cur, *tmp;
+
+#ifdef GTP_PERF_EVENTS
+	/* Remove all data of pe.  */
+	while (1) {
+		struct gtp_var_perf_event	*pe = NULL;
+
+		list_for_each(cur, &gtp_var_list) {
+			var = list_entry(cur, struct gtp_var, node);
+			if ((var->type == gtp_var_perf_event
+			     || var->type == gtp_var_perf_event_per_cpu)
+			    && gtp_var_get_pe(var)->pe) {
+				pe = gtp_var_get_pe(var)->pe;
+				break;
+			}
+		}
+		if (pe == NULL)
+			break;
+		if (pe->event)
+			perf_event_release_kernel(pe->event);
+		kfree(pe->name);
+		kfree(pe);
+		list_for_each(cur, &gtp_var_list) {
+			var = list_entry(cur, struct gtp_var, node);
+			if ((var->type == gtp_var_perf_event
+			     || var->type == gtp_var_perf_event_per_cpu)
+			    && gtp_var_get_pe(var)->pe == pe) {
+				gtp_var_get_pe(var)->pe = NULL;
+				if (var->type == gtp_var_perf_event_per_cpu)
+					var->type = gtp_var_per_cpu;
+			}
+		}
+	}
+#endif
+
+	/* Remove all data of pc.  */
+	while (1) {
+		struct gtp_var_per_cpu	*pc = NULL;
+
+		list_for_each(cur, &gtp_var_list) {
+			var = list_entry(cur, struct gtp_var, node);
+			if (var->type == gtp_var_per_cpu && var->u.pc.pc) {
+				pc = var->u.pc.pc;
+				break;
+			}
+		}
+		if (pc == NULL)
+			break;
+		free_percpu(pc);
+		list_for_each(cur, &gtp_var_list) {
+			var = list_entry(cur, struct gtp_var, node);
+			if ((var->type == gtp_var_per_cpu)
+			    && var->u.pc.pc == pc) {
+				var->u.pc.pc = NULL;
+			}
+		}
+	}
+
+	list_for_each_safe(cur, tmp, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		if (!include_special && var->type == gtp_var_special)
+			continue;
+
+		list_del(&var->node);
+		gtp_var_num--;
+		kfree(var->src);
+		kfree(var);
+	}
+}
+
+static int
+gtp_version_hooks_get_val(struct gtp_trace_s *unused1, struct gtp_var *unused2,
+			  int64_t *val)
+{
+	*val = GTP_VERSION;
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_version_hooks = {
+	.gdb_get_val = gtp_version_hooks_get_val,
+	.agent_get_val = gtp_version_hooks_get_val,
+};
+
+static int
+gtp_cpu_id_hooks_get_val(struct gtp_trace_s *unused1, struct gtp_var *unused2,
+			  int64_t *val)
+{
+	*val = smp_processor_id();
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_cpu_id_hooks = {
+	.gdb_get_val = gtp_cpu_id_hooks_get_val,
+	.agent_get_val = gtp_cpu_id_hooks_get_val,
+};
+
+static int
+gtp_current_task_hooks_get_val(struct gtp_trace_s *gts,
+			       struct gtp_var *unused, int64_t *val)
+{
+	if (gts->ri)
+		*val = (int64_t)(CORE_ADDR)gts->ri->task;
+	else
+		*val = (int64_t)(CORE_ADDR)get_current();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_task_hooks = {
+	.agent_get_val = gtp_current_task_hooks_get_val,
+};
+
+static int
+gtp_current_task_pid_hooks_get_val(struct gtp_trace_s *gts,
+				   struct gtp_var *unused2, int64_t *val)
+{
+	if (gts->ri)
+		*val = (uint64_t)(CORE_ADDR)gts->ri->task->pid;
+	else
+		*val = (uint64_t)(CORE_ADDR)get_current()->pid;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_task_pid_hooks = {
+	.agent_get_val = gtp_current_task_pid_hooks_get_val,
+};
+
+static int
+gtp_current_thread_info_hooks_get_val(struct gtp_trace_s *unused1,
+				      struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)(CORE_ADDR)current_thread_info();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_thread_info_hooks = {
+	.agent_get_val = gtp_current_thread_info_hooks_get_val,
+};
+
+static int
+gtp_current_task_user_hooks_get_val(struct gtp_trace_s *unused1,
+				    struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)user_mode(task_pt_regs(get_current()));
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_task_user_hooks = {
+	.agent_get_val = gtp_current_task_user_hooks_get_val,
+};
+
+static int
+gtp_clock_hooks_get_val(struct gtp_trace_s *unused1,
+			struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)GTP_LOCAL_CLOCK;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_clock_hooks = {
+	.gdb_get_val = gtp_clock_hooks_get_val,
+	.agent_get_val = gtp_clock_hooks_get_val,
+};
+
+static int
+gtp_cooked_clock_hooks_get_val(struct gtp_trace_s *unused1,
+			       struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)(__get_cpu_var(local_clock_current)
+				- __get_cpu_var(local_clock_offset));
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_cooked_clock_hooks = {
+	.agent_get_val = gtp_cooked_clock_hooks_get_val,
+};
+
+#ifdef CONFIG_X86
+static int
+gtp_rdtsc_hooks_get_val(struct gtp_trace_s *unused1,
+			struct gtp_var *unused2, int64_t *val)
+{
+	unsigned long long a;
+
+	rdtscll(a);
+	*val = (int64_t)a;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_rdtsc_hooks = {
+	.gdb_get_val = gtp_rdtsc_hooks_get_val,
+	.agent_get_val = gtp_rdtsc_hooks_get_val,
+};
+
+static int
+gtp_cooked_rdtsc_hooks_get_val(struct gtp_trace_s *unused1,
+			       struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)(__get_cpu_var(rdtsc_current)
+				- __get_cpu_var(rdtsc_offset));
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_cooked_rdtsc_hooks = {
+	.agent_get_val = gtp_cooked_rdtsc_hooks_get_val,
+};
+#endif
+
+#ifdef GTP_RB
+static int
+gtp_rb_discard_page_number_hooks_get_val(struct gtp_trace_s *unused1,
+					 struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)atomic_read(&gtp_rb_discard_page_number);
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_rb_discard_page_number_hooks = {
+	.gdb_get_val = gtp_rb_discard_page_number_hooks_get_val,
+};
+#endif
+
+static int
+gtp_printk_tmp_hooks_get_val(struct gtp_trace_s *gts,
+			     struct gtp_var *unused, int64_t *val)
+{
+	*val = gts->printk_tmp;
+
+	return 0;
+}
+
+static int
+gtp_printk_tmp_hooks_set_val(struct gtp_trace_s *gts,
+			     struct gtp_var *unused, int64_t val)
+{
+	gts->printk_tmp = val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_printk_tmp_hooks = {
+	.agent_get_val = gtp_printk_tmp_hooks_get_val,
+	.agent_set_val = gtp_printk_tmp_hooks_set_val,
+};
+
+static int
+gtp_printk_level_hooks_set_val(struct gtp_trace_s *gts,
+			       struct gtp_var *unused, int64_t val)
+{
+	gts->printk_level = (unsigned int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_printk_level_hooks = {
+	.agent_set_val = gtp_printk_level_hooks_set_val,
+};
+
+static int
+gtp_printk_format_hooks_set_val(struct gtp_trace_s *gts,
+				struct gtp_var *unused, int64_t val)
+{
+	gts->printk_format = (unsigned int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_printk_format_hooks = {
+	.agent_set_val = gtp_printk_format_hooks_set_val,
+};
+
+static int
+gtp_dump_stack_hooks_get_val(struct gtp_trace_s *gts,
+			     struct gtp_var *unused1, int64_t *val)
+{
+	printk(KERN_NULL "CPU%d gtp %d %p:", smp_processor_id(),
+	       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr);
+	dump_stack();
+	*val = 0;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_dump_stack_hooks = {
+	.agent_get_val = gtp_dump_stack_hooks_get_val,
+};
+
+static int
+gtp_pipe_trace_hooks_get_val(struct gtp_trace_s *unused1,
+			     struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_pipe_trace;
+
+	return 0;
+}
+
+static int
+gtp_pipe_trace_hooks_set_val(struct gtp_trace_s *unused1,
+			     struct gtp_var *unused2, int64_t val)
+{
+	gtp_pipe_trace = (int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_pipe_trace_hooks = {
+	.gdb_get_val = gtp_pipe_trace_hooks_get_val,
+	.gdb_set_val = gtp_pipe_trace_hooks_set_val,
+};
+
+static int
+gtp_cpu_number_hooks_get_val(struct gtp_trace_s *unused1,
+			     struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_cpu_number;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_cpu_number_hooks = {
+	.gdb_get_val = gtp_cpu_number_hooks_get_val,
+	.agent_get_val = gtp_cpu_number_hooks_get_val,
+};
+
+static void	gtp_pc_pe_en(int enable);
+
+static int
+gtp_pc_pe_en_hooks_set_val(struct gtp_trace_s *unused1,
+			   struct gtp_var *unused2, int64_t val)
+{
+	gtp_pc_pe_en((int)val);
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_pc_pe_en_hooks = {
+	.agent_set_val = gtp_pc_pe_en_hooks_set_val,
+};
+
+static int
+gtp_xtime_hooks_agent_get_val(struct gtp_trace_s *gts,
+			      struct gtp_var *gtv, int64_t *val)
+{
+	if (gts->xtime.tv_sec == 0 && gts->xtime.tv_nsec == 0)
+		getnstimeofday(&gts->xtime);
+
+	if (gtv->num == GTP_VAR_XTIME_SEC_ID)
+		*val = (int64_t)gts->xtime.tv_sec;
+	else
+		*val = (int64_t)gts->xtime.tv_nsec;
+
+	return 0;
+}
+
+static int
+gtp_xtime_hooks_gdb_get_val(struct gtp_trace_s *gts,
+			    struct gtp_var *gtv, int64_t *val)
+{
+	struct timespec	time;
+
+	getnstimeofday(&time);
+	if (gtv->num == GTP_VAR_XTIME_SEC_ID)
+		*val = (int64_t)time.tv_sec;
+	else
+		*val = (int64_t)time.tv_nsec;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_xtime_hooks = {
+	.agent_get_val = gtp_xtime_hooks_agent_get_val,
+	.gdb_get_val = gtp_xtime_hooks_gdb_get_val,
+};
+
+static int
+gtp_ignore_error_hooks_get_val(struct gtp_trace_s *unused1,
+			       struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_start_ignore_error;
+
+	return 0;
+}
+
+static int
+gtp_ignore_error_hooks_set_val(struct gtp_trace_s *unused1,
+			       struct gtp_var *unused2, int64_t val)
+{
+	gtp_start_ignore_error = (int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_ignore_error_hooks = {
+	.gdb_get_val = gtp_ignore_error_hooks_get_val,
+	.gdb_set_val = gtp_ignore_error_hooks_set_val,
+};
+
+static int
+gtp_last_errno_hooks_get_val(struct gtp_trace_s *unused1,
+			     struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_start_last_errno;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_last_errno_hooks = {
+	.gdb_get_val = gtp_last_errno_hooks_get_val,
+};
+
+static int
+gtp_hardirq_count_hooks_get_val(struct gtp_trace_s *unused1,
+				struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)hardirq_count();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_hardirq_count_hooks = {
+	.agent_get_val = gtp_hardirq_count_hooks_get_val,
+};
+
+static int
+gtp_softirq_count_hooks_get_val(struct gtp_trace_s *unused1,
+				struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)softirq_count();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_softirq_count_hooks = {
+	.agent_get_val = gtp_softirq_count_hooks_get_val,
+};
+
+static int
+gtp_irq_count_hooks_get_val(struct gtp_trace_s *unused1,
+			    struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)irq_count();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_irq_count_hooks = {
+	.agent_get_val = gtp_irq_count_hooks_get_val,
+};
+
+static int
+gtp_bt_hooks_get_val(struct gtp_trace_s *unused1,
+		     struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_bt_size;
+
+	return 0;
+}
+
+static int
+gtp_bt_hooks_set_val(struct gtp_trace_s *unused1,
+		     struct gtp_var *unused2, int64_t val)
+{
+	gtp_bt_size = (int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_bt_hooks = {
+	.gdb_get_val = gtp_bt_hooks_get_val,
+	.gdb_set_val = gtp_bt_hooks_set_val,
+};
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+
+static void	gtp_handler_enable_disable(struct gtp_trace_s *gts,
+					   ULONGEST val, int enable);
+
+static int
+gtp_enable_disable_hooks_set_val(struct gtp_trace_s *gts,
+				 struct gtp_var *gtv, int64_t val)
+{
+	gtp_handler_enable_disable(gts, val,
+				   (gtv->num == GTP_VAR_ENABLE_ID));
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_enable_disable_hooks = {
+	.agent_set_val = gtp_enable_disable_hooks_set_val,
+};
+#endif
+
+#ifdef CONFIG_X86
+static int
+gtp_watch_type_hooks_set_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t val)
+{
+	if (gts->tpe->type != gtp_entry_kprobe) {
+		printk(KERN_WARNING "Cannot set $watch_type in hardware breakpoint handler.\n");
+		return -1;
+	}
+	if (val != gtp_watch_exec && val != gtp_watch_write
+	    && val != gtp_watch_read_write) {
+		printk(KERN_WARNING "$watch_type just support set to 0, 1 or 2.\n");
+		return -1;
+	}
+
+	gts->watch_type = val;
+
+	return 0;
+}
+
+static int
+gtp_watch_type_hooks_get_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t *val)
+{
+	if (gts->tpe->type == gtp_entry_kprobe)
+		*val = gts->watch_type;
+	else
+		*val = gts->hwb->type;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_type_hooks = {
+	.agent_set_val = gtp_watch_type_hooks_set_val,
+	.agent_get_val = gtp_watch_type_hooks_get_val,
+};
+
+static int
+gtp_watch_size_hooks_set_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t val)
+{
+	if (gts->tpe->type != gtp_entry_kprobe) {
+		printk(KERN_WARNING "Cannot set $watch_size in hardware breakpoint handler.\n");
+		return -1;
+	}
+	if (val != 1 && val != 2 && val != 4 && val != 8) {
+		printk(KERN_WARNING "$watch_size just support set to 1, 2, 4 or 8.\n");
+		return -1;
+	}
+
+	gts->watch_size = val;
+
+	return 0;
+}
+
+static int
+gtp_watch_size_hooks_get_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t *val)
+{
+	if (gts->tpe->type == gtp_entry_kprobe)
+		*val = gts->watch_size;
+	else
+		*val = gts->hwb->size;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_size_hooks = {
+	.agent_set_val = gtp_watch_size_hooks_set_val,
+	.agent_get_val = gtp_watch_size_hooks_get_val,
+};
+
+static struct gtp_entry *
+gtp_list_find_watch_num(ULONGEST num)
+{
+	struct gtp_entry	*tpe;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->type == gtp_entry_watch_dynamic
+		    && tpe->num == num)
+			return tpe;
+	}
+
+	return NULL;
+}
+
+static struct gtp_entry *
+gtp_list_find_watch_addr(ULONGEST addr)
+{
+	struct gtp_entry	*tpe;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->type == gtp_entry_watch_dynamic
+		    && tpe->addr == addr)
+			return tpe;
+	}
+
+	return NULL;
+}
+
+static int
+gtp_watch_set_hooks_set_val(struct gtp_trace_s *gts,
+			    struct gtp_var *gtv, int64_t val)
+{
+	struct gtp_entry	*tpe;
+
+	if (gts->tpe->type != gtp_entry_kprobe) {
+		printk(KERN_WARNING "Cannot set $watch_id in hardware breakpoint handler.\n");
+		return -1;
+	}
+
+	if (gtv->num == GTP_WATCH_SET_ID_ID)
+		tpe = gtp_list_find_watch_num(val);
+	else
+		tpe = gtp_list_find_watch_addr(val);
+	if (!tpe) {
+		printk(KERN_WARNING "Cannot find dynamic watch tracepoint %s is %lld.\n",
+		       (gtv->num == GTP_WATCH_SET_ID_ID) ? "id" : "address", val);
+		return -1;
+	}
+
+	gts->watch_tpe = tpe;
+	gts->watch_type = gtp_watch_write;
+	gts->watch_size = 1;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_set_hooks = {
+	.agent_set_val = gtp_watch_set_hooks_set_val,
+};
+
+static int gtp_register_hwb(const struct gtp_hwb_s *arg, int nowait);
+static int gtp_unregister_hwb(CORE_ADDR addr, int sync);
+
+static int
+gtp_watch_start_hooks_set_val(struct gtp_trace_s *gts,
+			      struct gtp_var *gtv, int64_t val)
+{
+	struct gtp_hwb_s	arg;
+
+	if (gts->watch_tpe == NULL) {
+		printk(KERN_WARNING "Cannot set $watch_id in hardware breakpoint handler.\n");
+		return -1;
+	}
+
+	arg.addr = val;
+	arg.size = gts->watch_size;
+	arg.type = gts->watch_type;
+	arg.trace_num = gts->tpe->num;
+	arg.trace_addr = gts->tpe->addr;
+	arg.watch = gts->watch_tpe;
+	gts->watch_start_ret = gtp_register_hwb(&arg, 1);
+
+	return 0;
+}
+
+static int
+gtp_watch_start_hooks_get_val(struct gtp_trace_s *gts,
+			      struct gtp_var *gtv, int64_t *val)
+{
+	*val = gts->watch_start_ret;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_start_hooks = {
+	.agent_set_val = gtp_watch_start_hooks_set_val,
+	.agent_get_val = gtp_watch_start_hooks_get_val,
+};
+
+static int
+gtp_watch_stop_hooks_set_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t val)
+{
+	gts->watch_stop_ret = gtp_unregister_hwb(val, 1);
+
+	return 0;
+}
+
+static int
+gtp_watch_stop_hooks_get_val(struct gtp_trace_s *gts,
+			      struct gtp_var *gtv, int64_t *val)
+{
+	*val = gts->watch_stop_ret;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_stop_hooks = {
+	.agent_set_val = gtp_watch_stop_hooks_set_val,
+	.agent_get_val = gtp_watch_stop_hooks_get_val,
+};
+
+static int
+gtp_watch_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+		  int64_t *val)
+{
+	if (gts->tpe->type == gtp_entry_kprobe)
+		return -1;
+
+	switch (gtv->num) {
+	case GTP_WATCH_TRACE_NUM_ID:
+		*val = gts->hwb->trace_num;
+		break;
+	case GTP_WATCH_TRACE_ADDR_ID:
+		*val = gts->hwb->trace_addr;
+		break;
+	case GTP_WATCH_ADDR_ID:
+		*val = gts->hwb->addr;
+		break;
+	case GTP_WATCH_COUNT_ID:
+		*val = gts->hwb->count;
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_get_hooks = {
+	.agent_get_val = gtp_watch_get_val,
+};
+
+static int
+gtp_watch_val_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+		      int64_t *val)
+{
+	union {
+		union {
+			uint8_t	bytes[1];
+			uint8_t	val;
+		} u8;
+		union {
+			uint8_t	bytes[2];
+			uint16_t val;
+		} u16;
+		union {
+			uint8_t bytes[4];
+			uint32_t val;
+		} u32;
+		union {
+			uint8_t bytes[8];
+			ULONGEST val;
+		} u64;
+	} cnv;
+
+	if (gts->tpe->type == gtp_entry_kprobe)
+		return -1;
+
+	switch (gts->hwb->size) {
+	case 1:
+		if (probe_kernel_read(cnv.u8.bytes, (void *)gts->hwb->addr, 1))
+			return -1;
+		*val = (int64_t) cnv.u8.val;
+		break;
+	case 2:
+		if (probe_kernel_read(cnv.u16.bytes, (void *)gts->hwb->addr, 2))
+			return -1;
+		*val = (int64_t) cnv.u16.val;
+		break;
+	case 4:
+		if (probe_kernel_read(cnv.u32.bytes, (void *)gts->hwb->addr, 4))
+			return -1;
+		*val = (int64_t) cnv.u32.val;
+		break;
+	case 8:
+		if (probe_kernel_read(cnv.u64.bytes, (void *)gts->hwb->addr, 8))
+			return -1;
+		*val = (int64_t) cnv.u64.val;
+		break;
+	}
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_val_hooks = {
+	.agent_get_val = gtp_watch_val_get_val,
+};
+#endif
+
+#ifdef GTP_RB
+static int
+gtp_step_count_hooks_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+			     int64_t *val)
+{
+	if (gts->step)
+		*val = gts->tpe->step - gts->step + 1;
+	else
+		*val = 0;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_step_count_hooks = {
+	.agent_get_val = gtp_step_count_hooks_get_val,
+};
+
+static DEFINE_PER_CPU(int64_t, gtp_step_id);
+
+static int
+gtp_step_id_hooks_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+			  int64_t *val)
+{
+	if (!gts->step) {
+		if (++ __get_cpu_var(gtp_step_id) == 0)
+			__get_cpu_var(gtp_step_id) = 1;
+	}
+
+	*val = __get_cpu_var(gtp_step_id);
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_step_id_hooks = {
+	.agent_get_val = gtp_step_id_hooks_get_val,
+};
+#endif
+
+static int
+gtp_var_special_add_all(void)
+{
+	struct gtp_var	*var;
+
+	var = gtp_var_special_add(GTP_VAR_VERSION_ID, 0, GTP_VERSION,
+				  "gtp_version", &gtp_version_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CPU_ID, 0, 0, "cpu_id",
+				  &gtp_cpu_id_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_TASK_ID, 0, 0,
+				  "current_task", &gtp_current_task_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_TASK_PID_ID, 0, 0,
+				  "current_task_pid",
+				  &gtp_current_task_pid_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_THREAD_INFO_ID, 0, 0,
+				  "current_thread_info",
+				  &gtp_current_thread_info_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_TASK_USER_ID, 0, 0,
+				  "current_task_user",
+				  &gtp_current_task_user_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_ID, 0, 0, "current", NULL);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CLOCK_ID, 0, 0, "clock",
+				  &gtp_clock_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_COOKED_CLOCK_ID, 0, 0,
+				  "cooked_clock", &gtp_cooked_clock_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+#ifdef CONFIG_X86
+	var = gtp_var_special_add(GTP_VAR_RDTSC_ID, 0, 0, "rdtsc",
+				  &gtp_rdtsc_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_COOKED_RDTSC_ID, 0, 0,
+				  "cooked_rdtsc", &gtp_cooked_rdtsc_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+
+#ifdef GTP_RB
+	var = gtp_var_special_add(GTP_VAR_GTP_RB_DISCARD_PAGE_NUMBER, 0, 0,
+				  "gtp_rb_discard_page_number", 
+				  &gtp_rb_discard_page_number_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+
+	var = gtp_var_special_add(GTP_VAR_PRINTK_TMP_ID, 0, 0,
+				  "printk_tmp", &gtp_printk_tmp_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_PRINTK_LEVEL_ID, 0, 8,
+				  "printk_level", &gtp_printk_level_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_PRINTK_FORMAT_ID, 0, 0,
+				  "printk_format", &gtp_printk_format_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_DUMP_STACK_ID, 0, 0,
+				  "dump_stack", &gtp_dump_stack_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_SELF_TRACE_ID, 0, 0,
+				  "self_trace", NULL);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_PIPE_TRACE_ID, 0, 0,
+				  "pipe_trace", &gtp_pipe_trace_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CPU_NUMBER_ID, 0, 0,
+				  "cpu_number", &gtp_cpu_number_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_PC_PE_EN_ID, 0, 0,
+				  "p_pe_en", &gtp_pc_pe_en_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_KRET_ID, 0, 0,
+				  "kret", NULL);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_XTIME_SEC_ID, 0, 0,
+				  "xtime_sec", &gtp_xtime_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_XTIME_NSEC_ID, 0, 0,
+				  "xtime_nsec", &gtp_xtime_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_IGNORE_ERROR_ID, 0, 0,
+				  "ignore_error", &gtp_ignore_error_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_LAST_ERRNO_ID, 0, 0,
+				  "last_errno", &gtp_last_errno_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_HARDIRQ_COUNT_ID, 0, 0,
+				  "hardirq_count", &gtp_hardirq_count_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_SOFTIRQ_COUNT_ID, 0, 0,
+				  "softirq_count", &gtp_softirq_count_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_IRQ_COUNT_ID, 0, 0,
+				  "irq_count", &gtp_irq_count_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_BT_ID, 0, 512, "bt",
+				  &gtp_bt_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	var = gtp_var_special_add(GTP_VAR_ENABLE_ID, 0, 0,
+				  "enable", &gtp_enable_disable_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_DISABLE_ID, 0, 0,
+				  "disable", &gtp_enable_disable_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+
+#ifdef CONFIG_X86
+	var = gtp_var_special_add(GTP_WATCH_STATIC_ID, 0, 0,
+				  "watch_static", NULL);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_TYPE_ID, 0, 0,
+				  "watch_type", &gtp_watch_type_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_SIZE_ID, 0, 1,
+				  "watch_size", &gtp_watch_size_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_SET_ID_ID, 0, 0,
+				  "watch_set_id", &gtp_watch_set_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_SET_ADDR_ID, 0, 0,
+				  "watch_set_addr", &gtp_watch_set_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_START_ID, 0, 0,
+				  "watch_start", &gtp_watch_start_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_STOP_ID, 0, 0,
+				  "watch_stop", &gtp_watch_stop_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_TRACE_NUM_ID, 0, 0,
+				  "watch_trace_num", &gtp_watch_get_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_TRACE_ADDR_ID, 0, 0,
+				  "watch_trace_addr", &gtp_watch_get_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_ADDR_ID, 0, 0,
+				  "watch_addr", &gtp_watch_get_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_VAL_ID, 0, 0,
+				  "watch_val", &gtp_watch_val_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_COUNT_ID, 0, 0,
+				  "watch_count", &gtp_watch_get_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+	var = gtp_var_special_add(GTP_STEP_COUNT_ID, 0, 0,
+				  "step_count", &gtp_step_count_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#ifdef GTP_RB
+	var = gtp_var_special_add(GTP_STEP_ID_ID, 0, 0,
+				  "step_id", &gtp_step_id_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)) \
+    || (RHEL_RELEASE_CODE != 0 && RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,6))
+#ifndef __HAVE_ARCH_STRCASECMP
+int strcasecmp(const char *s1, const char *s2)
+{
+	int c1, c2;
+
+	do {
+		c1 = tolower(*s1++);
+		c2 = tolower(*s2++);
+	} while (c1 == c2 && c1 != 0);
+	return c1 - c2;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCASECMP
+int strncasecmp(const char *s1, const char *s2, size_t n)
+{
+	int c1, c2;
+
+	do {
+		c1 = tolower(*s1++);
+		c2 = tolower(*s2++);
+	} while ((--n > 0) && c1 == c2 && c1 != 0);
+	return c1 - c2;
+}
+#endif
+#endif
+
+struct gtp_realloc_s {
+	char	*buf;
+	size_t	size;
+	size_t	real_size;
+};
+
+static int
+gtp_realloc_alloc(struct gtp_realloc_s *grs, size_t size)
+{
+	if (size) {
+		grs->buf = vmalloc(size);
+		if (!grs->buf)
+			return -ENOMEM;
+	} else
+		grs->buf = NULL;
+
+	grs->size = 0;
+	grs->real_size = size;
+
+	return 0;
+}
+
+static char *
+gtp_realloc(struct gtp_realloc_s *grs, size_t size, int is_end)
+{
+	char	*tmp;
+
+	if (unlikely((grs->real_size < grs->size + size)
+		     || (is_end && grs->real_size != grs->size + size))) {
+		grs->real_size = grs->size + size;
+		if (!is_end)
+			grs->real_size += 100;
+
+		tmp = vmalloc(grs->real_size);
+		if (!tmp) {
+			vfree(grs->buf);
+			memset(grs, 0, sizeof(struct gtp_realloc_s));
+			return NULL;
+		}
+
+		memcpy(tmp, grs->buf, grs->size);
+		if (grs->buf)
+			vfree(grs->buf);
+		grs->buf = tmp;
+	}
+
+	grs->size += size;
+	return grs->buf + grs->size - size;
+}
+
+static int
+gtp_realloc_str(struct gtp_realloc_s *grs, char *str, int is_end)
+{
+	char	*wbuf;
+	int	str_len = strlen(str);
+
+	wbuf = gtp_realloc(grs, str_len, is_end);
+	if (wbuf == NULL)
+		return -ENOMEM;
+
+	memcpy(wbuf, str, str_len);
+
+	return 0;
+}
+
+static inline void
+gtp_realloc_reset(struct gtp_realloc_s *grs)
+{
+	grs->size = 0;
+}
+
+static inline int
+gtp_realloc_is_alloced(struct gtp_realloc_s *grs)
+{
+	return (grs->buf != NULL);
+}
+
+static inline int
+gtp_realloc_is_empty(struct gtp_realloc_s *grs)
+{
+	return (grs->size == 0);
+}
+
+static inline void
+gtp_realloc_sub_size(struct gtp_realloc_s *grs, size_t size)
+{
+	grs->size -= size;
+}
+
+#ifdef CONFIG_X86
+ULONGEST
+gtp_action_reg_read(struct gtp_trace_s *gts, int num)
+{
+	ULONGEST	ret;
+
+	switch (num) {
+#ifdef CONFIG_X86_32
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	case 0:
+		ret = gts->regs->ax;
+		break;
+	case 1:
+		ret = gts->regs->cx;
+		break;
+	case 2:
+		ret = gts->regs->dx;
+		break;
+	case 3:
+		ret = gts->regs->bx;
+		break;
+	case 4:
+		ret = (ULONGEST)(CORE_ADDR)&gts->regs->sp;
+		break;
+	case 5:
+		ret = gts->regs->bp;
+		break;
+	case 6:
+		ret = gts->regs->si;
+		break;
+	case 7:
+		ret = gts->regs->di;
+		break;
+	case 8:
+		if (GTP_X86_NEED_ADJUST_PC(gts))
+			ret = gts->regs->ip - 1;
+		else
+			ret = gts->regs->ip;
+		break;
+	case 9:
+		ret = gts->regs->flags;
+		break;
+	case 10:
+		ret = gts->regs->cs;
+		break;
+	case 11:
+		ret = gts->regs->ss;
+		break;
+	case 12:
+		ret = gts->regs->ds;
+		break;
+	case 13:
+		ret = gts->regs->es;
+		break;
+	case 14:
+		ret = gts->regs->fs;
+		break;
+	case 15:
+		ret = gts->regs->gs;
+		break;
+#else
+	case 0:
+		ret = gts->regs->eax;
+		break;
+	case 1:
+		ret = gts->regs->ecx;
+		break;
+	case 2:
+		ret = gts->regs->edx;
+		break;
+	case 3:
+		ret = gts->regs->ebx;
+		break;
+	case 4:
+		ret = (ULONGEST)(CORE_ADDR)&gts->regs->esp;
+		break;
+	case 5:
+		ret = gts->regs->ebp;
+		break;
+	case 6:
+		ret = gts->regs->esi;
+		break;
+	case 7:
+		ret = gts->regs->edi;
+		break;
+	case 8:
+		if (GTP_X86_NEED_ADJUST_PC(gts))
+			ret = gts->regs->eip - 1;
+		else
+			ret = gts->regs->eip;
+		break;
+	case 9:
+		ret = gts->regs->eflags;
+		break;
+	case 10:
+		ret = gts->regs->xcs;
+		break;
+	case 11:
+		ret = gts->regs->xss;
+		break;
+	case 12:
+		ret = gts->regs->xds;
+		break;
+	case 13:
+		ret = gts->regs->xes;
+		break;
+	case 14:
+		/* ret = gts->regs->xfs; */
+		ret = 0;
+		break;
+	case 15:
+		/* ret = gts->regs->xgs; */
+		ret = 0;
+		break;
+#endif
+#else
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	case 0:
+		ret = gts->regs->ax;
+		break;
+	case 1:
+		ret = gts->regs->bx;
+		break;
+	case 2:
+		ret = gts->regs->cx;
+		break;
+	case 3:
+		ret = gts->regs->dx;
+		break;
+	case 4:
+		ret = gts->regs->si;
+		break;
+	case 5:
+		ret = gts->regs->di;
+		break;
+	case 6:
+		ret = gts->regs->bp;
+		break;
+	case 7:
+		ret = gts->regs->sp;
+		break;
+	case 16:
+		if (GTP_X86_NEED_ADJUST_PC(gts))
+			ret = gts->regs->ip - 1;
+		else
+			ret = gts->regs->ip;
+		break;
+	case 17:
+		ret = gts->regs->flags;
+		break;
+#else
+	case 0:
+		ret = gts->regs->rax;
+		break;
+	case 1:
+		ret = gts->regs->rbx;
+		break;
+	case 2:
+		ret = gts->regs->rcx;
+		break;
+	case 3:
+		ret = gts->regs->rdx;
+		break;
+	case 4:
+		ret = gts->regs->rsi;
+		break;
+	case 5:
+		ret = gts->regs->rdi;
+		break;
+	case 6:
+		ret = gts->regs->rbp;
+		break;
+	case 7:
+		ret = gts->regs->rsp;
+		break;
+	case 16:
+		if (GTP_X86_NEED_ADJUST_PC(gts))
+			ret = gts->regs->rip - 1;
+		else
+			ret = gts->regs->rip;
+		break;
+	case 17:
+		ret = gts->regs->eflags;
+		break;
+#endif
+	case 8:
+		ret = gts->regs->r8;
+		break;
+	case 9:
+		ret = gts->regs->r9;
+		break;
+	case 10:
+		ret = gts->regs->r10;
+		break;
+	case 11:
+		ret = gts->regs->r11;
+		break;
+	case 12:
+		ret = gts->regs->r12;
+		break;
+	case 13:
+		ret = gts->regs->r13;
+		break;
+	case 14:
+		ret = gts->regs->r14;
+		break;
+	case 15:
+		ret = gts->regs->r15;
+		break;
+	case 18:
+		ret = gts->regs->cs;
+		break;
+	case 19:
+		ret = gts->regs->ss;
+		break;
+#endif
+	default:
+		ret = 0;
+		gts->tpe->reason = gtp_stop_access_wrong_reg;
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(gtp_action_reg_read);
+
+static void
+gtp_regs2ascii(struct pt_regs *regs, char *buf)
+{
+#ifdef CONFIG_X86_32
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ax = 0x%x\n",
+		(unsigned int) regs->ax);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cx = 0x%x\n",
+		(unsigned int) regs->cx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: dx = 0x%x\n",
+		(unsigned int) regs->dx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bx = 0x%x\n",
+		(unsigned int) regs->bx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: sp = 0x%x\n",
+		(unsigned int) regs->sp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bp = 0x%x\n",
+		(unsigned int) regs->bp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: si = 0x%x\n",
+		(unsigned int) regs->si);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: di = 0x%x\n",
+		(unsigned int) regs->di);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ip = 0x%x\n",
+		(unsigned int) regs->ip);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: flags = 0x%x\n",
+		(unsigned int) regs->flags);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cs = 0x%x\n",
+		(unsigned int) regs->cs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ss = 0x%x\n",
+		(unsigned int) regs->ss);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ds = 0x%x\n",
+		(unsigned int) regs->ds);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: es = 0x%x\n",
+		(unsigned int) regs->es);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: fs = 0x%x\n",
+		(unsigned int) regs->fs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: gs = 0x%x\n",
+		(unsigned int) regs->gs);
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ax));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->cx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->dx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->bx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->sp));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->bp));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->si));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->di));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ip));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->flags));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->cs));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ss));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ds));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->es));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->fs));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->gs));
+	buf += 8;
+#else
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->eax));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ecx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->edx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ebx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->esp));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ebp));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->esi));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->edi));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->eip));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->eflags));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->xcs));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->xss));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->xds));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->xes));
+	buf += 8;
+	/* sprintf(buf, "%08x", (unsigned int) swab32(regs->xfs)); */
+	sprintf(buf, "00000000");
+	buf += 8;
+	/* sprintf(buf, "%08x", (unsigned int) swab32(regs->xgs)); */
+	sprintf(buf, "00000000");
+	buf += 8;
+#endif
+#else
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ax = 0x%lx\n", regs->ax);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bx = 0x%lx\n", regs->bx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cx = 0x%lx\n", regs->cx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: dx = 0x%lx\n", regs->dx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: si = 0x%lx\n", regs->si);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: di = 0x%lx\n", regs->di);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bp = 0x%lx\n", regs->bp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: sp = 0x%lx\n", regs->sp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r8 = 0x%lx\n", regs->r8);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r9 = 0x%lx\n", regs->r9);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r10 = 0x%lx\n", regs->r10);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r11 = 0x%lx\n", regs->r11);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r12 = 0x%lx\n", regs->r12);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r13 = 0x%lx\n", regs->r13);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r14 = 0x%lx\n", regs->r14);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r15 = 0x%lx\n", regs->r15);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ip = 0x%lx\n", regs->ip);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: flags = 0x%lx\n", regs->flags);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cs = 0x%lx\n", regs->cs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ss = 0x%lx\n", regs->ss);
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->ax));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->bx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->cx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->dx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->si));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->di));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->bp));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->sp));
+	buf += 16;
+#else
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rax));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rbx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rcx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rdx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rsi));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rdi));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rbp));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rsp));
+	buf += 16;
+#endif
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r8));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r9));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r10));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r11));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r12));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r13));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r14));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r15));
+	buf += 16;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->ip));
+	buf += 16;
+	sprintf(buf, "%08x",
+		(unsigned int) swab32((unsigned int)regs->flags));
+	buf += 8;
+#else
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rip));
+	buf += 16;
+	sprintf(buf, "%08x",
+		(unsigned int) swab32((unsigned int)regs->eflags));
+	buf += 8;
+#endif
+	sprintf(buf, "%08x",
+		(unsigned int) swab32((unsigned int)regs->cs));
+	buf += 8;
+	sprintf(buf, "%08x",
+		(unsigned int) swab32((unsigned int)regs->ss));
+	buf += 8;
+#endif
+}
+
+static void
+gtp_regs2bin(struct pt_regs *regs, char *buf)
+{
+#ifdef CONFIG_X86_32
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ax = 0x%x\n",
+		(unsigned int) regs->ax);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cx = 0x%x\n",
+		(unsigned int) regs->cx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: dx = 0x%x\n",
+		(unsigned int) regs->dx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bx = 0x%x\n",
+		(unsigned int) regs->bx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: sp = 0x%x\n",
+		(unsigned int) regs->sp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bp = 0x%x\n",
+		(unsigned int) regs->bp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: si = 0x%x\n",
+		(unsigned int) regs->si);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: di = 0x%x\n",
+		(unsigned int) regs->di);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ip = 0x%x\n",
+		(unsigned int) regs->ip);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: flags = 0x%x\n",
+		(unsigned int) regs->flags);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cs = 0x%x\n",
+		(unsigned int) regs->cs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ss = 0x%x\n",
+		(unsigned int) regs->ss);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ds = 0x%x\n",
+		(unsigned int) regs->ds);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: es = 0x%x\n",
+		(unsigned int) regs->es);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: fs = 0x%x\n",
+		(unsigned int) regs->fs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: gs = 0x%x\n",
+		(unsigned int) regs->gs);
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	memcpy(buf, &regs->ax, 4);
+	buf += 4;
+	memcpy(buf, &regs->cx, 4);
+	buf += 4;
+	memcpy(buf, &regs->dx, 4);
+	buf += 4;
+	memcpy(buf, &regs->bx, 4);
+	buf += 4;
+	memcpy(buf, &regs->sp, 4);
+	buf += 4;
+	memcpy(buf, &regs->bp, 4);
+	buf += 4;
+	memcpy(buf, &regs->si, 4);
+	buf += 4;
+	memcpy(buf, &regs->di, 4);
+	buf += 4;
+	memcpy(buf, &regs->ip, 4);
+	buf += 4;
+	memcpy(buf, &regs->flags, 4);
+	buf += 4;
+	memcpy(buf, &regs->cs, 4);
+	buf += 4;
+	memcpy(buf, &regs->ss, 4);
+	buf += 4;
+	memcpy(buf, &regs->ds, 4);
+	buf += 4;
+	memcpy(buf, &regs->es, 4);
+	buf += 4;
+	memcpy(buf, &regs->fs, 4);
+	buf += 4;
+	memcpy(buf, &regs->gs, 4);
+	buf += 4;
+#else
+	memcpy(buf, &regs->eax, 4);
+	buf += 4;
+	memcpy(buf, &regs->ecx, 4);
+	buf += 4;
+	memcpy(buf, &regs->edx, 4);
+	buf += 4;
+	memcpy(buf, &regs->ebx, 4);
+	buf += 4;
+	memcpy(buf, &regs->esp, 4);
+	buf += 4;
+	memcpy(buf, &regs->ebp, 4);
+	buf += 4;
+	memcpy(buf, &regs->esi, 4);
+	buf += 4;
+	memcpy(buf, &regs->edi, 4);
+	buf += 4;
+	memcpy(buf, &regs->eip, 4);
+	buf += 4;
+	memcpy(buf, &regs->eflags, 4);
+	buf += 4;
+	memcpy(buf, &regs->xcs, 4);
+	buf += 4;
+	memcpy(buf, &regs->xss, 4);
+	buf += 4;
+	memcpy(buf, &regs->xds, 4);
+	buf += 4;
+	memcpy(buf, &regs->xes, 4);
+	buf += 4;
+	/* memcpy(buf, &regs->xfs, 4); */
+	memset(buf, '\0', 4);
+	buf += 4;
+	/* memcpy(buf, &regs->xgs, 4); */
+	memset(buf, '\0', 4);
+	buf += 4;
+#endif
+#else
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ax = 0x%lx\n", regs->ax);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bx = 0x%lx\n", regs->bx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cx = 0x%lx\n", regs->cx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: dx = 0x%lx\n", regs->dx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: si = 0x%lx\n", regs->si);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: di = 0x%lx\n", regs->di);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bp = 0x%lx\n", regs->bp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: sp = 0x%lx\n", regs->sp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r8 = 0x%lx\n", regs->r8);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r9 = 0x%lx\n", regs->r9);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r10 = 0x%lx\n", regs->r10);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r11 = 0x%lx\n", regs->r11);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r12 = 0x%lx\n", regs->r12);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r13 = 0x%lx\n", regs->r13);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r14 = 0x%lx\n", regs->r14);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r15 = 0x%lx\n", regs->r15);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ip = 0x%lx\n", regs->ip);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: flags = 0x%lx\n", regs->flags);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cs = 0x%lx\n", regs->cs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ss = 0x%lx\n", regs->ss);
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	memcpy(buf, &regs->ax, 8);
+	buf += 8;
+	memcpy(buf, &regs->bx, 8);
+	buf += 8;
+	memcpy(buf, &regs->cx, 8);
+	buf += 8;
+	memcpy(buf, &regs->dx, 8);
+	buf += 8;
+	memcpy(buf, &regs->si, 8);
+	buf += 8;
+	memcpy(buf, &regs->di, 8);
+	buf += 8;
+	memcpy(buf, &regs->bp, 8);
+	buf += 8;
+	memcpy(buf, &regs->sp, 8);
+	buf += 8;
+#else
+	memcpy(buf, &regs->rax, 8);
+	buf += 8;
+	memcpy(buf, &regs->rbx, 8);
+	buf += 8;
+	memcpy(buf, &regs->rcx, 8);
+	buf += 8;
+	memcpy(buf, &regs->rdx, 8);
+	buf += 8;
+	memcpy(buf, &regs->rsi, 8);
+	buf += 8;
+	memcpy(buf, &regs->rdi, 8);
+	buf += 8;
+	memcpy(buf, &regs->rbp, 8);
+	buf += 8;
+	memcpy(buf, &regs->rsp, 8);
+	buf += 8;
+#endif
+	memcpy(buf, &regs->r8, 8);
+	buf += 8;
+	memcpy(buf, &regs->r9, 8);
+	buf += 8;
+	memcpy(buf, &regs->r10, 8);
+	buf += 8;
+	memcpy(buf, &regs->r11, 8);
+	buf += 8;
+	memcpy(buf, &regs->r12, 8);
+	buf += 8;
+	memcpy(buf, &regs->r13, 8);
+	buf += 8;
+	memcpy(buf, &regs->r14, 8);
+	buf += 8;
+	memcpy(buf, &regs->r15, 8);
+	buf += 8;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	memcpy(buf, &regs->ip, 8);
+	buf += 8;
+	memcpy(buf, &regs->flags, 4);
+	buf += 4;
+#else
+	memcpy(buf, &regs->rip, 8);
+	buf += 8;
+	memcpy(buf, &regs->eflags, 4);
+	buf += 4;
+#endif
+	memcpy(buf, &regs->cs, 4);
+	buf += 4;
+	memcpy(buf, &regs->ss, 4);
+	buf += 4;
+#endif
+}
+#endif
+
+#ifdef CONFIG_MIPS
+static ULONGEST
+gtp_action_reg_read(struct gtp_trace_s *gts, int num)
+{
+	ULONGEST	ret;
+
+	if (num > 90) {
+		/* GDB convert the reg number to a GDB
+		   [1 * gdbarch_num_regs .. 2 * gdbarch_num_regs) REGNUM
+		   in function mips_dwarf_dwarf2_ecoff_reg_to_regnum.  */
+		num -= 90;
+	}
+
+	if (num >= 0 && num <= 31) {
+		ret = gts->regs->regs[num];
+	} else {
+		switch (num) {
+		case 32:
+			ret = gts->regs->cp0_status;
+			break;
+		case 33:
+			ret = gts->regs->lo;
+			break;
+		case 34:
+			ret = gts->regs->hi;
+			break;
+		case 35:
+			ret = gts->regs->cp0_badvaddr;
+			break;
+		case 36:
+			ret = gts->regs->cp0_cause;
+			break;
+		case 37:
+			ret = gts->regs->cp0_epc;
+			break;
+		default:
+			ret = 0;
+			gts->tpe->reason = gtp_stop_access_wrong_reg;
+			break;
+		}
+	}
+
+	return ret;
+};
+EXPORT_SYMBOL(gtp_action_reg_read);
+
+static void
+gtp_regs2ascii(struct pt_regs *regs, char *buf)
+{
+#ifdef GTP_DEBUG_V
+	{
+		int	i;
+
+		for (i = 0; i < 32; i++)
+			printk(GTP_DEBUG_V "gtp_gdbrsp_g: r%d = 0x%lx\n", i,
+			       regs->regs[i]);
+	}
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: status = 0x%lx\n",
+	       regs->cp0_status);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: lo = 0x%lx\n", regs->lo);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: hi = 0x%lx\n", regs->hi);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: badvaddr = 0x%lx\n",
+	       regs->cp0_badvaddr);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: cause = 0x%lx\n", regs->cp0_cause);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: pc = 0x%lx\n", regs->cp0_epc);
+#endif
+
+#ifdef CONFIG_32BIT
+#define OUTFORMAT	"%08lx"
+#define REGSIZE		8
+#ifdef __LITTLE_ENDIAN
+#define SWAB(a)		swab32(a)
+#else
+#define SWAB(a)		(a)
+#endif
+#else
+#define OUTFORMAT	"%016lx"
+#define REGSIZE		16
+#ifdef __LITTLE_ENDIAN
+#define SWAB(a)		swab64(a)
+#else
+#define SWAB(a)		(a)
+#endif
+#endif
+	{
+		int	i;
+
+		for (i = 0; i < 32; i++) {
+			sprintf(buf, OUTFORMAT,
+				 (unsigned long) SWAB(regs->regs[i]));
+			buf += REGSIZE;
+		}
+	}
+
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->cp0_status));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->lo));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->hi));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->cp0_badvaddr));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->cp0_cause));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->cp0_epc));
+	buf += REGSIZE;
+#undef OUTFORMAT
+#undef REGSIZE
+#undef SWAB
+}
+
+static void
+gtp_regs2bin(struct pt_regs *regs, char *buf)
+{
+#ifdef GTP_DEBUG_V
+	{
+		int	i;
+
+		for (i = 0; i < 32; i++)
+			printk(GTP_DEBUG_V "gtp_gdbrsp_g: r%d = 0x%lx\n", i,
+			       regs->regs[i]);
+	}
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: status = 0x%lx\n",
+	       regs->cp0_status);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: lo = 0x%lx\n", regs->lo);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: hi = 0x%lx\n", regs->hi);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: badvaddr = 0x%lx\n",
+	       regs->cp0_badvaddr);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: cause = 0x%lx\n", regs->cp0_cause);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: pc = 0x%lx\n", regs->cp0_epc);
+#endif
+
+#ifdef CONFIG_32BIT
+#define REGSIZE		4
+#else
+#define REGSIZE		8
+#endif
+	{
+		int	i;
+
+		for (i = 0; i < 32; i++) {
+			memcpy(buf, &regs->regs[i], REGSIZE);
+			buf += REGSIZE;
+		}
+	}
+	memcpy(buf, &regs->cp0_status, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->lo, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->hi, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->cp0_badvaddr, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->cp0_cause, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->cp0_epc, REGSIZE);
+	buf += REGSIZE;
+#undef REGSIZE
+}
+#endif
+
+#ifdef CONFIG_ARM
+ULONGEST
+gtp_action_reg_read(struct gtp_trace_s *gts, int num)
+{
+	if (num >= 0 && num < 16)
+		return gts->regs->uregs[num];
+	else if (num == 25)
+		return gts->regs->uregs[16];
+
+	gts->tpe->reason = gtp_stop_access_wrong_reg;
+	return 0;
+}
+EXPORT_SYMBOL(gtp_action_reg_read);
+
+static void
+gtp_regs2ascii(struct pt_regs *regs, char *buf)
+{
+#ifdef __LITTLE_ENDIAN
+#define SWAB(a)		swab32(a)
+#else
+#define SWAB(a)		(a)
+#endif
+	int	i;
+
+	for (i = 0; i < 16; i++) {
+#ifdef GTP_DEBUG_V
+		printk(GTP_DEBUG_V "gtp_gdbrsp_g: r%d = 0x%lx\n",
+		       i, regs->uregs[i]);
+#endif
+		sprintf(buf, "%08lx", (unsigned long) SWAB(regs->uregs[i]));
+		buf += 8;
+	}
+
+	/* f0-f7 fps */
+	memset(buf, '0', 200);
+	buf += 200;
+
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: cpsr = 0x%lx\n", regs->uregs[16]);
+#endif
+	sprintf(buf, "%08lx",
+		 (unsigned long) SWAB(regs->uregs[16]));
+	buf += 8;
+#undef SWAB
+}
+
+static void
+gtp_regs2bin(struct pt_regs *regs, char *buf)
+{
+	int	i;
+
+	for (i = 0; i < 16; i++) {
+#ifdef GTP_DEBUG_V
+		printk(GTP_DEBUG_V "gtp_gdbrsp_g: r%d = 0x%lx\n",
+		       i, regs->uregs[i]);
+#endif
+		memcpy(buf, &regs->uregs[i], 4);
+		buf += 4;
+	}
+
+	/* f0-f7 fps */
+	memset(buf, '\0', 100);
+	buf += 100;
+
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: cpsr = 0x%lx\n", regs->uregs[16]);
+#endif
+	memcpy(buf, &regs->uregs[16], 4);
+	buf += 4;
+}
+#endif
+
+#ifdef GTP_PERF_EVENTS
+#if KGTP_API_VERSION_LOCAL < 20120808
+#include "perf_event.c"
+#endif
+
+static DEFINE_PER_CPU(int, pc_pe_list_all_disabled);
+static DEFINE_PER_CPU(struct gtp_var_perf_event *, pc_pe_list);
+
+static void
+pc_pe_list_disable(void)
+{
+	struct gtp_var_perf_event *ppl;
+
+	if (__get_cpu_var(pc_pe_list_all_disabled))
+		return;
+
+	for (ppl = __get_cpu_var(pc_pe_list); ppl; ppl = ppl->pc_next) {
+		if (ppl->en)
+#if (KGTP_API_VERSION_LOCAL < 20120808)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
+			__gtp_perf_event_disable(ppl->event);
+#else
+			perf_event_disable(ppl->event);
+#endif
+#else
+			local_perf_event_disable(ppl->event);
+#endif
+	}
+}
+
+static void
+pc_pe_list_enable(void)
+{
+	struct gtp_var_perf_event *ppl;
+
+	if (__get_cpu_var(pc_pe_list_all_disabled))
+		return;
+
+	for (ppl = __get_cpu_var(pc_pe_list); ppl; ppl = ppl->pc_next) {
+		if (ppl->en)
+#if (KGTP_API_VERSION_LOCAL < 20120808)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
+			__gtp_perf_event_enable(ppl->event);
+#else
+			perf_event_enable(ppl->event);
+#endif
+#else
+			local_perf_event_enable(ppl->event);
+#endif
+	}
+}
+
+static void
+gtp_pc_pe_en(int enable)
+{
+	struct gtp_var_perf_event *ppl = __get_cpu_var(pc_pe_list);
+
+	for (ppl = __get_cpu_var(pc_pe_list); ppl; ppl = ppl->pc_next)
+		ppl->en = enable;
+
+	__get_cpu_var(pc_pe_list_all_disabled) = !enable;
+}
+
+static void
+gtp_pe_set_en(struct gtp_var_perf_event *pts, int enable)
+{
+	if (pts->event->cpu != smp_processor_id()) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)	\
+     && KGTP_API_VERSION_LOCAL < 20120808)
+		if (enable)
+			gtp_perf_event_enable(pts->event);
+		else
+			gtp_perf_event_disable(pts->event);
+#else
+		if (enable)
+			perf_event_enable(pts->event);
+		else
+			perf_event_disable(pts->event);
+#endif
+	}
+	pts->en = enable;
+}
+#else
+static void
+gtp_pc_pe_en(int enable)
+{
+}
+#endif	/* GTP_PERF_EVENTS */
+
+/* Following part is for gtp_task_read.  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+static inline int is_cow_mapping(unsigned int flags)
+#else
+static inline int is_cow_mapping(vm_flags_t flags)
+#endif
+{
+	return (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+#ifdef __HAVE_ARCH_PTE_SPECIAL
+# define HAVE_PTE_SPECIAL 1
+#else
+# define HAVE_PTE_SPECIAL 0
+#endif
+#endif
+struct page *
+gtp_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,
+				pte_t pte)
+{
+	unsigned long pfn = pte_pfn(pte);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	if (HAVE_PTE_SPECIAL) {
+		if (likely(!pte_special(pte)))
+			goto check_pfn;
+		/* XXX: not support is_zero_pfn.  */
+
+		return NULL;
+	}
+#endif
+
+	/* !HAVE_PTE_SPECIAL case follows: */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	if (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {
+#else
+	if (unlikely(vma->vm_flags & (VM_PFNMAP))) {
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+		if (vma->vm_flags & VM_MIXEDMAP) {
+			if (!pfn_valid(pfn))
+				return NULL;
+			goto out;
+		} else {
+#endif
+			unsigned long off;
+			off = (addr - vma->vm_start) >> PAGE_SHIFT;
+			if (pfn == vma->vm_pgoff + off)
+				return NULL;
+			if (!is_cow_mapping(vma->vm_flags))
+				return NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+		}
+#endif
+	}
+
+	/* XXX: is_zero_pfn is not support.
+	if (is_zero_pfn(pfn))
+		return NULL;
+	*/
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+check_pfn:
+#endif
+	/* XXX: highest_memmap_pfn is not support.
+	if (unlikely(pfn > highest_memmap_pfn)) {
+		print_bad_pte(vma, addr, pte, NULL);
+		return NULL;
+	}
+	*/
+
+	/*
+	 * NOTE! We still have PageReserved() pages in the page tables.
+	 * eg. VDSO mappings can cause them to exist.
+	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+out:
+#endif
+	return pfn_to_page(pfn);
+}
+
+/* Example: follow_page */
+
+struct page *
+gtp_follow_page(struct vm_area_struct *vma, unsigned long address,
+		unsigned int flags)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+	spinlock_t *ptl;
+	struct page *page;
+	struct mm_struct *mm = vma->vm_mm;
+
+	/* XXX: not support follow_huge_addr.  */
+
+	page = NULL;
+	pgd = pgd_offset(mm, address);
+	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
+		goto no_page_table;
+
+	pud = pud_offset(pgd, address);
+	if (pud_none(*pud))
+		goto no_page_table;
+
+	/* XXX: not support pud_huge. */
+
+	if (unlikely(pud_bad(*pud)))
+		goto no_page_table;
+
+	pmd = pmd_offset(pud, address);
+	if (pmd_none(*pmd))
+		goto no_page_table;
+
+	/* XXX: not support pmd_huge. */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38))
+	if (unlikely(pmd_bad(*pmd)))
+		goto no_page_table;
+#else
+	if (pmd_trans_huge(*pmd)) {
+		/* XXX: not support wait_split_huge_page.  */
+		goto no_page_table;
+	}
+#endif
+
+	if (unlikely(pmd_bad(*pmd)))
+		goto no_page_table;
+
+	ptep = pte_offset_map_lock(mm, pmd, address, &ptl);
+
+	pte = *ptep;
+	if (!pte_present(pte))
+		goto no_page;
+	if ((flags & FOLL_WRITE) && !pte_write(pte))
+		goto unlock;
+
+	page = gtp_vm_normal_page(vma, address, pte);
+	if (unlikely(!page)) {
+		/* XXX: not support is_zero_pfn.  */
+		goto bad_page;
+	}
+
+	if (flags & FOLL_GET) {
+		/* XXX: not support get_page_foll(page) */
+		get_page(page);
+	}
+unlock:
+	pte_unmap_unlock(ptep, ptl);
+	return page;
+
+bad_page:
+	pte_unmap_unlock(ptep, ptl);
+	return ERR_PTR(-EFAULT);
+
+no_page:
+	pte_unmap_unlock(ptep, ptl);
+	if (!pte_none(pte))
+		return page;
+
+no_page_table:
+	return page;
+}
+
+/* Example: __get_user_pages */
+
+static int
+gtp_get_user_page(struct mm_struct *mm, unsigned long start,
+		  struct page **pages, struct vm_area_struct **vmas)
+{
+	struct vm_area_struct	*vma;
+	struct page		*page;
+
+	/* XXX: not use find_extend_vma because cannot get
+	   find_vma_prev and expand_stack.  */
+	vma = find_vma(mm, start);
+	if (vma->vm_flags & VM_LOCKED)
+		return 0;
+
+	/* XXX: not use get_gate_vma because not support vm_normal_page. */
+	if (!vma ||
+		    (vma->vm_flags & (VM_IO | VM_PFNMAP)) ||
+		    !(VM_MAYREAD & vma->vm_flags))
+			return -EFAULT;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+	if (is_vm_hugetlb_page(vma)) {
+		/* XXX: not support follow_hugetlb_page.  */
+		return 0;
+	}
+#endif
+	page = gtp_follow_page(vma, start, FOLL_GET);
+	if (IS_ERR(page))
+		return PTR_ERR(page);
+	if (pages) {
+		pages[0] = page;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19))
+#if defined(CONFIG_ARM) && (KGTP_API_VERSION_LOCAL < 20120917)
+		printk(KERN_WARNING "You use KGTP $current but your Kernel "
+				    "doesn't support flush_anon_page.  "
+				    "If you want use it, "
+				    "please patch the patch of KGTP "
+				    "(http://code.google.com/p/kgtp/wiki/HOWTO#Use_KGTP_patch_for_Linux_kernel).\n");
+#else
+		flush_anon_page(vma, page, start);
+#endif
+#else
+		flush_anon_page(page, start);
+#endif
+		flush_dcache_page(page);
+	}
+	if (vmas)
+		vmas[0] = vma;
+
+	return 1;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))
+static struct task_struct	gtp_fake_task;
+static struct thread_info	gtp_fake_thread;
+#endif
+
+/* Example: access_remote_vm */
+
+static int
+gtp_task_read(pid_t pid, struct task_struct *tsk, unsigned long addr,
+	      void *buf, int len, int in_kprobe_handler)
+{
+	int			ret = -ESRCH;
+	struct mm_struct	*mm;
+	struct vm_area_struct	*vma;
+	void			*old_buf = buf;
+
+	if (in_kprobe_handler) {
+		/* The tsk cannot be NULL.  */
+		/* get_task_mm */
+		ret = -ENXIO;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		if (tsk->flags & PF_KTHREAD)
+#else
+		if (tsk->flags & PF_BORROWED_MM)
+#endif
+			return ret;
+		task_lock(tsk);
+		mm = tsk->mm;
+	} else {
+		/* Example: ptrace_get_task_struct
+		issue 131: For the Linux kernel 2.6.23 and older version,
+		it should use read_lock(&tasklist_lock) and
+		read_unlock(&tasklist_lock).
+		But tasklist_lock is not exported.
+		And find_task_by_pid use RCU.  So use rcu_read_lock and
+		rcu_read_unlock to handle it.  */
+		ret = -ESRCH;
+		rcu_read_lock();
+		if (!tsk) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
+			tsk = pid_task(find_vpid(pid), PIDTYPE_PID);
+#else
+			tsk = find_task_by_pid(pid);
+#endif
+			if (!tsk) {
+				rcu_read_unlock();
+				return ret;
+			}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))
+#ifdef CONFIG_IA32_EMULATION
+			/* This part for get_gate_vma.  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+#ifndef __HAVE_THREAD_FUNCTIONS
+			gtp_fake_task.thread_info = &gtp_fake_thread;
+#else
+			task_stack_page(&gtp_fake_task) = &gtp_fake_thread;
+#endif
+#else
+			task_stack_page(&gtp_fake_task) = &gtp_fake_thread;
+#endif
+			task_thread_info(&gtp_fake_task)->flags = task_thread_info(tsk)->flags;
+#endif
+#endif
+		}
+		mm = get_task_mm(tsk);
+		rcu_read_unlock();
+	}
+	if (!mm)
+		goto out;
+
+	if (in_kprobe_handler) {
+		if (!down_read_trylock(&mm->mmap_sem))
+			goto out;
+	} else
+		down_read(&mm->mmap_sem);
+
+	while (len) {
+		int bytes, offset;
+		void *maddr;
+		struct page *page = NULL;
+
+		if (in_kprobe_handler)
+			ret = gtp_get_user_page(mm, addr, &page, &vma);
+		else {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))
+			ret = get_user_pages(&gtp_fake_task, mm, addr, 1, 0, 1, &page,
+				     &vma);
+#else
+			ret = get_user_pages(NULL, mm, addr, 1, 0, 1, &page, &vma);
+#endif
+		}
+		if (ret <= 0) {
+			/*
+			 * Check if this is a VM_IO | VM_PFNMAP VMA, which
+			 * we can access using slightly different code.
+			 */
+#ifdef CONFIG_HAVE_IOREMAP_PROT
+			vma = find_vma(mm, addr);
+			if (!vma || vma->vm_start > addr)
+				break;
+			if (vma->vm_ops && vma->vm_ops->access)
+				ret = vma->vm_ops->access(vma, addr, buf,
+							  len, 0);
+			if (ret <= 0)
+#endif
+				break;
+			bytes = ret;
+		} else {
+			bytes = len;
+			offset = addr & (PAGE_SIZE-1);
+			if (bytes > PAGE_SIZE-offset)
+				bytes = PAGE_SIZE-offset;
+
+			if (in_kprobe_handler)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+				maddr = kmap_atomic(page);
+#else
+				maddr = kmap_atomic(page, KM_IRQ1);
+#endif
+			else
+				maddr = kmap(page);
+			copy_from_user_page(vma, page, addr,
+					    buf, maddr + offset, bytes);
+			if (in_kprobe_handler)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+				kunmap_atomic(maddr);
+#else
+				kunmap_atomic(maddr, KM_IRQ1);
+#endif
+			else
+				kunmap(maddr);
+			page_cache_release(page);
+		}
+		len -= bytes;
+		buf += bytes;
+		addr += bytes;
+	}
+	ret = buf - old_buf;
+
+	up_read(&mm->mmap_sem);
+	if (!in_kprobe_handler)
+		mmput(mm);
+out:
+	if (in_kprobe_handler)
+		task_unlock(tsk);
+	return ret;
+}
+
+static long
+gtp_task_handler_read(void *dst, void *src, size_t size)
+{
+	if (gtp_task_read(0, get_current(),
+			  (unsigned long)src, dst, size, 1) != size)
+		return -EFAULT;
+
+	return 0;
+}
+
+#ifdef GTP_FRAME_SIMPLE
+static char *
+gtp_frame_next(char *frame)
+{
+	switch (FID(frame)) {
+	case FID_HEAD:
+		frame += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+		break;
+	case FID_REG:
+		frame += FRAME_ALIGN(GTP_FRAME_REG_SIZE);
+		break;
+	case FID_MEM: {
+			struct gtp_frame_mem	*gfm;
+
+			gfm = (struct gtp_frame_mem *) (frame + FID_SIZE
+							+ sizeof(char *));
+			frame += FRAME_ALIGN(GTP_FRAME_MEM_SIZE + gfm->size);
+		}
+		break;
+	case FID_VAR:
+		frame += FRAME_ALIGN(GTP_FRAME_VAR_SIZE);
+		break;
+	case FID_END:
+		frame = gtp_frame_end;
+		break;
+	default:
+		return NULL;
+		break;
+	}
+
+	return frame;
+}
+#endif
+
+#ifdef GTP_FRAME_SIMPLE
+#ifdef FRAME_ALLOC_RECORD
+ULONGEST	frame_alloc_size;
+ULONGEST	frame_alloc_size_hole;
+#endif
+
+static char *
+gtp_frame_alloc(size_t size)
+{
+	char	*ret = NULL;
+
+#ifdef FRAME_ALLOC_RECORD
+	frame_alloc_size += size;
+	frame_alloc_size_hole += (FRAME_ALIGN(size) - size);
+#endif
+
+	size = FRAME_ALIGN(size);
+
+	if (size > GTP_FRAME_SIZE)
+		return NULL;
+
+	spin_lock(&gtp_frame_lock);
+
+	if (gtp_frame_w_start + size > gtp_frame_end) {
+		if (gtp_circular) {
+			gtp_frame_is_circular = 1;
+#ifdef FRAME_ALLOC_RECORD
+			if (gtp_frame_w_start != gtp_frame_end
+			    && gtp_frame_end - gtp_frame_w_start < FID_SIZE) {
+				printk(KERN_WARNING "Frame align wrong."
+						    "start = %p end = %p\n",
+				       gtp_frame_w_start, gtp_frame_end);
+				goto out;
+			}
+#endif
+			if (gtp_frame_w_start != gtp_frame_end)
+				FID(gtp_frame_w_start) = FID_END;
+			gtp_frame_w_start = gtp_frame;
+			gtp_frame_r_start = gtp_frame;
+		} else
+			goto out;
+	}
+
+	if (gtp_frame_is_circular) {
+		while (gtp_frame_w_start <= gtp_frame_r_start
+		       && gtp_frame_w_start + size > gtp_frame_r_start) {
+			char *tmp = gtp_frame_next(gtp_frame_r_start);
+			if (tmp == NULL)
+				goto out;
+			if (tmp == gtp_frame_end)
+				gtp_frame_r_start = gtp_frame;
+			else
+				gtp_frame_r_start = tmp;
+		}
+	}
+
+	ret = gtp_frame_w_start;
+	gtp_frame_w_start += size;
+
+out:
+	spin_unlock(&gtp_frame_lock);
+	return ret;
+}
+#endif
+
+#define GTP_PRINTK_FORMAT_A	0
+#define GTP_PRINTK_FORMAT_D	1
+#define GTP_PRINTK_FORMAT_U	2
+#define GTP_PRINTK_FORMAT_X	3
+#define GTP_PRINTK_FORMAT_S	4
+#define GTP_PRINTK_FORMAT_B	5
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#define GTP_FRAME_RINGBUFFER_ALLOC(size)				\
+	do {								\
+		rbe = ring_buffer_lock_reserve(gtp_frame, size);	\
+		if (rbe == NULL) {					\
+			gts->tpe->reason = gtp_stop_frame_full;		\
+			return -1;					\
+		}							\
+		tmp = ring_buffer_event_data(rbe);			\
+	} while (0)
+#endif
+
+static int	gtp_collect_var(struct gtp_trace_s *gts, int num);
+#ifdef GTP_RB
+static int	gtp_var_array_step_id_id = 0;
+#endif
+
+static int
+gtp_action_head(struct gtp_trace_s *gts)
+{
+	char				*tmp;
+	ULONGEST			*trace_nump;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+#endif
+
+#ifdef GTP_RB
+	gts->next = (struct gtp_rb_s *)this_cpu_ptr(gtp_rb);
+#endif
+
+	/* Get the head.  */
+#ifdef GTP_FTRACE_RING_BUFFER
+	GTP_FRAME_RINGBUFFER_ALLOC(GTP_FRAME_HEAD_SIZE);
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#ifdef GTP_RB
+	GTP_RB_LOCK(gts->next);
+	tmp = gtp_rb_alloc(gts->next, GTP_FRAME_HEAD_SIZE, 0);
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	tmp = gtp_frame_alloc(GTP_FRAME_HEAD_SIZE);
+#endif
+	if (!tmp) {
+		gts->tpe->reason = gtp_stop_frame_full;
+		return -1;
+	}
+#endif
+
+	FID(tmp) = FID_HEAD;
+	tmp += FID_SIZE;
+
+#ifdef GTP_RB
+	gts->id = gtp_rb_clock();
+	*(u64 *)tmp = gts->id;
+	tmp += sizeof(u64);
+#endif
+
+#ifdef GTP_FRAME_SIMPLE
+	gts->next = (char **)tmp;
+	*(gts->next) = NULL;
+	tmp += sizeof(char *);
+#endif
+
+	trace_nump = (ULONGEST *)tmp;
+	*trace_nump = gts->tpe->num;
+	tmp += sizeof(ULONGEST);
+
+#ifdef GTP_RB
+	*(void **)tmp = gtp_rb_prev_frame_get(gts->next);
+	gtp_rb_prev_frame_set(gts->next, (void *)(tmp + sizeof(void *)
+					          - GTP_FRAME_HEAD_SIZE));
+#endif
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	ring_buffer_unlock_commit(gtp_frame, rbe);
+	gts->next = (char *)1;
+#endif
+
+	atomic_inc(&gtp_frame_create);
+
+#ifdef GTP_RB
+	/* Auto collect $step_id.  */
+	if (gts->tpe->step) {
+		if (gtp_collect_var(gts, gtp_var_array_step_id_id))
+			return -1;
+	}
+#endif
+
+	return 0;
+}
+
+static int
+gtp_action_printk(struct gtp_trace_s *gts, ULONGEST addr, size_t size)
+{
+	unsigned int	printk_format = gts->printk_format;
+	char		*pbuf = __get_cpu_var(gtp_printf);
+
+	if (gts->printk_str == NULL) {
+		gts->tpe->reason = gtp_stop_agent_expr_code_error;
+		printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+				    "printk doesn't have var name.  Please "
+				    "check actions of it.\n",
+			(int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr);
+		return -1;
+	}
+
+	if (size) {
+		if (size > GTP_PRINTF_MAX - 1)
+			size = GTP_PRINTF_MAX - 1;
+		if (gts->printk_format != GTP_PRINTK_FORMAT_S
+		    && gts->printk_format != GTP_PRINTK_FORMAT_B
+		    && size > 8)
+			size = 8;
+		if (gts->read_memory(pbuf, (void *)(CORE_ADDR)addr, size)) {
+			gts->tpe->reason = gtp_stop_efault;
+			printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+					    "read %p %u get error.\n",
+			       (int)gts->tpe->num,
+			       (void *)(CORE_ADDR)gts->tpe->addr,
+			       (void *)(CORE_ADDR)addr,
+			       (unsigned int)size);
+			return -1;
+		}
+	} else {
+		size = sizeof(ULONGEST);
+		memcpy(pbuf, &addr, sizeof(ULONGEST));
+	}
+
+	if (printk_format == GTP_PRINTK_FORMAT_A) {
+		if (size == 1 || size == 2 || size == 4 || size == 8)
+			printk_format = GTP_PRINTK_FORMAT_U;
+		else
+			printk_format = GTP_PRINTK_FORMAT_B;
+	}
+
+	switch (printk_format) {
+	case GTP_PRINTK_FORMAT_D:
+		switch (size) {
+		case 1:
+			printk(KERN_NULL "<%d>CPU%d %s%d\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, pbuf[0]);
+			break;
+		case 2:
+			printk(KERN_NULL "<%d>CPU%d %s%d\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src,
+			       (int)(*(short *)pbuf));
+			break;
+		case 4:
+			printk(KERN_NULL "<%d>CPU%d %s%d\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(int *)pbuf);
+			break;
+		case 8:
+			printk(KERN_NULL "<%d>CPU%d %s%lld\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(long long *)pbuf);
+			break;
+		default:
+			printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+					    "size %d cannot printk.\n",
+			       (int)gts->tpe->num,
+			       (void *)(CORE_ADDR)gts->tpe->addr,
+			       (unsigned int)size);
+			gts->tpe->reason = gtp_stop_agent_expr_code_error;
+			return -1;
+			break;
+		}
+		break;
+	case GTP_PRINTK_FORMAT_U:
+		switch (size) {
+		case 1:
+			printk(KERN_NULL "<%d>CPU%d %s%u\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, pbuf[0]);
+			break;
+		case 2:
+			printk(KERN_NULL "<%d>CPU%d %s%u\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, (int)(*(short *)pbuf));
+			break;
+		case 4:
+			printk(KERN_NULL "<%d>CPU%d %s%u\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(int *)pbuf);
+			break;
+		case 8:
+			printk(KERN_NULL "<%d>CPU%d %s%llu\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(long long *)pbuf);
+			break;
+		default:
+			printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p"
+					    "size %d cannot printk.\n",
+			       (int)gts->tpe->num,
+			       (void *)(CORE_ADDR)gts->tpe->addr,
+			       (unsigned int)size);
+			gts->tpe->reason = gtp_stop_agent_expr_code_error;
+			return -1;
+			break;
+		}
+		break;
+	case GTP_PRINTK_FORMAT_X:
+		switch (size) {
+		case 1:
+			printk(KERN_NULL "<%d>CPU%d %s0x%x\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, pbuf[0]);
+			break;
+		case 2:
+			printk(KERN_NULL "<%d>CPU%d %s0x%x\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, (int)(*(short *)pbuf));
+			break;
+		case 4:
+			printk(KERN_NULL "<%d>CPU%d %s0x%x\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(int *)pbuf);
+			break;
+		case 8:
+			printk(KERN_NULL "<%d>CPU%d %s0x%llx\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(long long *)pbuf);
+			break;
+		default:
+			printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+					    "size %d cannot printk.\n",
+			       (int)gts->tpe->num,
+			       (void *)(CORE_ADDR)gts->tpe->addr,
+			       (unsigned int)size);
+			gts->tpe->reason = gtp_stop_agent_expr_code_error;
+			return -1;
+			break;
+		}
+		break;
+	case GTP_PRINTK_FORMAT_S:
+		pbuf[GTP_PRINTF_MAX - 1] = '\0';
+		printk("<%d>CPU%d %s%s\n", gts->printk_level,
+		       smp_processor_id(), gts->printk_str->src, pbuf);
+		break;
+	case GTP_PRINTK_FORMAT_B: {
+			size_t	i;
+
+			printk(KERN_NULL "<%d>CPU%d %s", gts->printk_level,
+			       smp_processor_id(), gts->printk_str->src);
+			for (i = 0; i < size; i++)
+				printk("%02x", (unsigned int)pbuf[i]);
+			printk("\n");
+		}
+		break;
+	default:
+		printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+				    "printk format %u is not support.\n",
+		       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr,
+		       gts->printk_format);
+		gts->tpe->reason = gtp_stop_agent_expr_code_error;
+		return -1;
+		break;
+	}
+
+	gts->printk_str = gts->printk_str->next;
+
+	return 0;
+}
+
+static int
+gtp_action_memory_read(struct gtp_trace_s *gts, int reg, CORE_ADDR addr,
+		       size_t size)
+{
+	char				*tmp;
+	struct gtp_frame_mem		*fm;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+#endif
+
+	if (reg >= 0)
+		addr += (CORE_ADDR) gtp_action_reg_read(gts, reg);
+	if (gts->tpe->reason != gtp_stop_normal)
+		return -1;
+
+	if (gts->next == NULL) {
+		if (gtp_action_head(gts))
+			return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	GTP_FRAME_RINGBUFFER_ALLOC(GTP_FRAME_MEM_SIZE + size);
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#ifdef GTP_RB
+	tmp = gtp_rb_alloc(gts->next, GTP_FRAME_MEM_SIZE + size, gts->id);
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	tmp = gtp_frame_alloc(GTP_FRAME_MEM_SIZE + size);
+#endif
+	if (!tmp) {
+		gts->tpe->reason = gtp_stop_frame_full;
+		return -1;
+	}
+#ifdef GTP_FRAME_SIMPLE
+	*gts->next = tmp;
+#endif
+#endif
+
+	FID(tmp) = FID_MEM;
+	tmp += FID_SIZE;
+
+#ifdef GTP_FRAME_SIMPLE
+	gts->next = (char **)tmp;
+	*gts->next = NULL;
+	tmp += sizeof(char *);
+#endif
+
+	fm = (struct gtp_frame_mem *)tmp;
+	fm->addr = addr;
+	fm->size = size;
+	tmp += sizeof(struct gtp_frame_mem);
+
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_action_memory_read: id:%d addr:%p %p %u\n",
+	       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr,
+	       (void *)addr, (unsigned int)size);
+#endif
+
+	if (gts->read_memory(tmp, (void *)addr, size)) {
+		gts->tpe->reason = gtp_stop_efault;
+#ifdef GTP_FRAME_SIMPLE
+		memset(tmp, 0, size);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		ring_buffer_discard_commit(gtp_frame, rbe);
+#endif
+#ifdef GTP_RB
+		GTP_RB_RELEASE(gts->next);
+#endif
+		printk(KERN_WARNING "gtp_action_memory_read: id:%d addr:%p "
+				    "read %p %u get error.\n",
+		       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr,
+		       (void *)addr, (unsigned int)size);
+		return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	ring_buffer_unlock_commit(gtp_frame, rbe);
+#endif
+
+	return 0;
+}
+
+static int
+gtp_action_r(struct gtp_trace_s *gts, struct action *ae)
+{
+	struct pt_regs			*regs;
+	char				*tmp;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+#endif
+
+	if (gts->next == NULL) {
+		if (gtp_action_head(gts))
+			return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	GTP_FRAME_RINGBUFFER_ALLOC(GTP_FRAME_REG_SIZE);
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#ifdef GTP_RB
+	tmp = gtp_rb_alloc(gts->next, GTP_FRAME_REG_SIZE, gts->id);
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	tmp = gtp_frame_alloc(GTP_FRAME_REG_SIZE);
+#endif
+	if (!tmp) {
+		gts->tpe->reason = gtp_stop_frame_full;
+		return -1;
+	}
+#ifdef GTP_FRAME_SIMPLE
+	*gts->next = tmp;
+#endif
+#endif
+
+	FID(tmp) = FID_REG;
+	tmp += FID_SIZE;
+
+#ifdef GTP_FRAME_SIMPLE
+	gts->next = (char **)tmp;
+	*gts->next = NULL;
+	tmp += sizeof(char *);
+#endif
+
+	regs = (struct pt_regs *)tmp;
+
+	memcpy(regs, gts->regs, sizeof(struct pt_regs));
+#ifdef CONFIG_X86_32
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	regs->sp = (unsigned long)&regs->sp;
+#else
+	regs->esp = (unsigned long)&regs->esp;
+#endif
+#endif	/* CONFIG_X86_32 */
+
+	if (gts->ri)
+		GTP_REGS_PC(regs) = (CORE_ADDR)gts->ri->ret_addr;
+#ifdef CONFIG_X86
+	else if (GTP_X86_NEED_ADJUST_PC(gts))
+		GTP_REGS_PC(regs) -= 1;
+#endif	/* CONFIG_X86 */
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	ring_buffer_unlock_commit(gtp_frame, rbe);
+#endif
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+static DEFINE_SPINLOCK(gtp_handler_enable_disable_loc);
+
+static void
+gtp_handler_enable_disable(struct gtp_trace_s *gts, ULONGEST val, int enable)
+{
+	struct gtp_entry	*tpe;
+
+	spin_lock(&gtp_handler_enable_disable_loc);
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (val == 0 || tpe->num == val || gts->tpe != tpe)  {
+			/* Following code can insert this task
+				into tasklet without wake up softirqd.  */
+			add_preempt_count(HARDIRQ_OFFSET);
+			if (enable && tpe->disable)
+				tasklet_schedule(&gts->tpe->enable_tasklet);
+			else if (!enable && !tpe->disable)
+				tasklet_schedule(&gts->tpe->disable_tasklet);
+			sub_preempt_count(HARDIRQ_OFFSET);
+			tpe->disable = !tpe->disable;
+		}
+	}
+	spin_unlock(&gtp_handler_enable_disable_loc);
+}
+#endif
+
+static int
+gtp_var_agent_get_val(struct gtp_trace_s *gts, int num, int64_t *val)
+{
+	int		ret = 0;
+	struct gtp_var	*var;
+
+	var = gtp_var_array[num];
+	switch (var->type) {
+	case gtp_var_special:
+		ret = var->u.hooks->agent_get_val(gts, var, val);
+		break;
+	case gtp_var_per_cpu:
+		*val = gtp_var_get_pc(var)->u.val;
+		break;
+	case gtp_var_normal:
+		*val = var->u.val;
+		break;
+#ifdef GTP_PERF_EVENTS
+	case gtp_var_perf_event_per_cpu:
+	case gtp_var_perf_event: {
+			struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+			pe->pe->val = perf_event_read_value(pe->pe->event,
+							    &(pe->pe->enabled),
+							    &(pe->pe->running));
+			switch (pe->ptid) {
+			case pe_tv_val:
+				*val = (int64_t)(pe->pe->val);
+				break;
+			case pe_tv_enabled:
+				*val = (int64_t)(pe->pe->enabled);
+				break;
+			case pe_tv_running:
+				*val = (int64_t)(pe->pe->running);
+				break;
+			default:
+				/* This just to handle warning of gcc.  */
+				break;
+			}
+		}
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+static int
+gtp_var_agent_set_val(struct gtp_trace_s *gts, int num, int64_t val)
+{
+	int		ret = 0;
+	struct gtp_var	*var;
+
+	var = gtp_var_array[num];
+	switch (var->type) {
+	case gtp_var_special:
+		ret = var->u.hooks->agent_set_val(gts, var, val);
+		break;
+	case gtp_var_per_cpu:
+		gtp_var_get_pc(var)->u.val = val;
+		break;
+	case gtp_var_normal:
+		var->u.val = val;
+		break;
+#ifdef GTP_PERF_EVENTS
+	case gtp_var_perf_event_per_cpu:
+	case gtp_var_perf_event: {
+		struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+		pe->pe->val = perf_event_read_value(pe->pe->event,
+						    &(pe->pe->enabled),
+						    &(pe->pe->running));
+		if (pe->ptid == pe_tv_en)
+			gtp_pe_set_en(pe->pe, (int)val);
+		else {
+			/* For pe_tv_val.  */
+#if (KGTP_API_VERSION_LOCAL < 20120808)
+			gtp_perf_event_set(pe->pe->event, (u64)val);
+#else
+			perf_event_set(pe->pe->event, (u64)val);
+#endif
+		}
+	}
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+/* The number is not the ID of tvar, it is the ID of gtp_var_array. */
+
+static int
+gtp_collect_var(struct gtp_trace_s *gts, int num)
+{
+	struct gtp_frame_var		*fvar;
+	char				*tmp;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+#endif
+
+	if (gts->next == NULL) {
+		if (gtp_action_head(gts))
+			return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	GTP_FRAME_RINGBUFFER_ALLOC(GTP_FRAME_VAR_SIZE);
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#ifdef GTP_RB
+	tmp = gtp_rb_alloc(gts->next, GTP_FRAME_VAR_SIZE, gts->id);
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	tmp = gtp_frame_alloc(GTP_FRAME_VAR_SIZE);
+#endif
+	if (!tmp) {
+		gts->tpe->reason = gtp_stop_frame_full;
+		return -1;
+	}
+#ifdef GTP_FRAME_SIMPLE
+	*gts->next = tmp;
+#endif
+#endif
+
+	FID(tmp) = FID_VAR;
+	tmp += FID_SIZE;
+
+#ifdef GTP_FRAME_SIMPLE
+	gts->next = (char **)tmp;
+	*gts->next = NULL;
+	tmp += sizeof(char *);
+#endif
+
+	fvar = (struct gtp_frame_var *) tmp;
+	fvar->num = gtp_var_array[num]->num;
+	if (gtp_var_agent_get_val(gts, num, &(fvar->val))) {
+		fvar->val = 0;
+		gts->tpe->reason = gtp_stop_agent_expr_code_error;
+		return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	ring_buffer_unlock_commit(gtp_frame, rbe);
+#endif
+
+	return 0;
+}
+
+#define STACK_MAX	32
+static DEFINE_PER_CPU(ULONGEST[STACK_MAX], action_x_stack);
+
+static int
+gtp_action_x(struct gtp_trace_s *gts, struct action *ae)
+{
+	int		ret = 0;
+	unsigned int	pc = 0, sp = 0;
+	ULONGEST	top = 0;
+	int		arg;
+	union {
+		union {
+			uint8_t	bytes[1];
+			uint8_t	val;
+		} u8;
+		union {
+			uint8_t	bytes[2];
+			uint16_t val;
+		} u16;
+		union {
+			uint8_t bytes[4];
+			uint32_t val;
+		} u32;
+		union {
+			uint8_t bytes[8];
+			ULONGEST val;
+		} u64;
+	} cnv;
+	uint8_t		*ebuf = ae->u.exp.buf;
+	int		psize = GTP_PRINTF_MAX;
+	char		*pbuf = __get_cpu_var(gtp_printf);
+	ULONGEST	*stack = __get_cpu_var(action_x_stack);
+
+	if (unlikely(ae->u.exp.need_var_lock))
+		spin_lock(&gtp_var_lock);
+
+	while (1) {
+#ifdef GTP_DEBUG_V
+		printk(GTP_DEBUG_V "gtp_parse_x: cmd %x\n", ebuf[pc]);
+#endif
+
+		switch (ebuf[pc++]) {
+		/* add */
+		case 0x02:
+			top += stack[--sp];
+			break;
+
+		case op_check_add:
+			if (sp)
+				top += stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* sub */
+		case 0x03:
+			top = stack[--sp] - top;
+			break;
+
+		case op_check_sub:
+			if (sp)
+				top = stack[--sp] - top;
+			else
+				goto code_error_out;
+			break;
+
+		/* mul */
+		case 0x04:
+			top *= stack[--sp];
+			break;
+
+		case op_check_mul:
+			if (sp)
+				top *= stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+#ifndef CONFIG_MIPS
+		/* div_signed */
+		case 0x05:
+			if (top) {
+				LONGEST l = (LONGEST) stack[--sp];
+				do_div(l, (LONGEST) top);
+				top = l;
+			} else
+				goto code_error_out;
+			break;
+
+		case op_check_div_signed:
+			if (top && sp) {
+				LONGEST l = (LONGEST) stack[--sp];
+				do_div(l, (LONGEST) top);
+				top = l;
+			} else
+				goto code_error_out;
+			break;
+
+		/* div_unsigned */
+		case 0x06:
+			if (top) {
+				ULONGEST ul = stack[--sp];
+				do_div(ul, top);
+				top = ul;
+			} else
+				goto code_error_out;
+			break;
+
+		case op_check_div_unsigned:
+			if (top && sp) {
+				ULONGEST ul = stack[--sp];
+				do_div(ul, top);
+				top = ul;
+			} else
+				goto code_error_out;
+			break;
+
+		/* rem_signed */
+		case 0x07:
+			if (top) {
+				LONGEST l1 = (LONGEST) stack[--sp];
+				LONGEST l2 = (LONGEST) top;
+				top = do_div(l1, l2);
+			} else
+				goto code_error_out;
+			break;
+
+		case op_check_rem_signed:
+			if (top && sp) {
+				LONGEST l1 = (LONGEST) stack[--sp];
+				LONGEST l2 = (LONGEST) top;
+				top = do_div(l1, l2);
+			} else
+				goto code_error_out;
+			break;
+
+		/* rem_unsigned */
+		case 0x08:
+			if (top) {
+				ULONGEST ul1 = stack[--sp];
+				ULONGEST ul2 = top;
+				top = do_div(ul1, ul2);
+			} else
+				goto code_error_out;
+			break;
+
+		case op_check_rem_unsigned:
+			if (top && sp) {
+				ULONGEST ul1 = stack[--sp];
+				ULONGEST ul2 = top;
+				top = do_div(ul1, ul2);
+			} else
+				goto code_error_out;
+			break;
+#endif
+
+		/* lsh */
+		case 0x09:
+			top = stack[--sp] << top;
+			break;
+
+		case op_check_lsh:
+			if (sp)
+				top = stack[--sp] << top;
+			else
+				goto code_error_out;
+			break;
+
+		/* rsh_signed */
+		case 0x0a:
+			top = ((LONGEST) stack[--sp]) >> top;
+			break;
+
+		case op_check_rsh_signed:
+			if (sp)
+				top = ((LONGEST) stack[--sp]) >> top;
+			else
+				goto code_error_out;
+			break;
+
+		/* rsh_unsigned */
+		case 0x0b:
+			top = stack[--sp] >> top;
+			break;
+
+		case op_check_rsh_unsigned:
+			if (sp)
+				top = stack[--sp] >> top;
+			else
+				goto code_error_out;
+			break;
+
+		/* trace */
+		case 0x0c:
+			--sp;
+			if (!(gts->tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)) {
+				if (gtp_action_memory_read
+					(gts, -1,
+						(CORE_ADDR) stack[sp],
+						(size_t) top))
+					goto out;
+			}
+			top = stack[--sp];
+			break;
+
+		case op_check_trace:
+			if (sp > 1) {
+				if (gtp_action_memory_read
+					(gts, -1, (CORE_ADDR) stack[--sp],
+					(size_t) top)) {
+					/* gtp_action_memory_read will
+						set error status with itself
+						if it got error. */
+					goto out;
+				}
+				top = stack[--sp];
+			} else
+				goto code_error_out;
+			break;
+
+		/* trace_printk */
+		case op_trace_printk:
+			if (gtp_action_printk(gts,
+						(ULONGEST)stack[--sp],
+						(size_t) top))
+				goto out;
+			top = stack[--sp];
+			break;
+
+		/* trace_quick */
+		case 0x0d:
+			if (!(gts->tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)) {
+				if (gtp_action_memory_read
+					(gts, -1, (CORE_ADDR) top,
+						(size_t) ebuf[pc]))
+					goto out;
+			}
+			pc++;
+			break;
+
+		/* trace_quick_printk */
+		case op_trace_quick_printk:
+			if (gtp_action_printk(gts, (ULONGEST) top,
+						(size_t) ebuf[pc++]))
+				goto out;
+			break;
+
+		/* log_not */
+		case 0x0e:
+			top = !top;
+			break;
+
+		/* bit_and */
+		case 0x0f:
+			top &= stack[--sp];
+			break;
+
+		case op_check_bit_and:
+			if (sp)
+				top &= stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* bit_or */
+		case 0x10:
+			top |= stack[--sp];
+			break;
+
+		case op_check_bit_or:
+			if (sp)
+				top |= stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* bit_xor */
+		case 0x11:
+			top ^= stack[--sp];
+			break;
+
+		case op_check_bit_xor:
+			if (sp)
+				top ^= stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* bit_not */
+		case 0x12:
+			top = ~top;
+			break;
+
+		/* equal */
+		case 0x13:
+			top = (stack[--sp] == top);
+			break;
+
+		case op_check_equal:
+			if (sp)
+				top = (stack[--sp] == top);
+			else
+				goto code_error_out;
+			break;
+
+		/* less_signed */
+		case 0x14:
+			top = (((LONGEST) stack[--sp])
+				< ((LONGEST) top));
+			break;
+
+		case op_check_less_signed:
+			if (sp)
+				top = (((LONGEST) stack[--sp])
+					< ((LONGEST) top));
+			else
+				goto code_error_out;
+			break;
+
+		/* less_unsigned */
+		case 0x15:
+			top = (stack[--sp] < top);
+			break;
+
+		case op_check_less_unsigned:
+			if (sp)
+				top = (stack[--sp] < top);
+			else
+				goto code_error_out;
+			break;
+
+		/* ext */
+		case 0x16:
+			arg = ebuf[pc++];
+			if (arg < (sizeof(LONGEST)*8)) {
+				LONGEST mask = 1 << (arg - 1);
+				top &= ((LONGEST) 1 << arg) - 1;
+				top = (top ^ mask) - mask;
+			}
+			break;
+
+		/* ref8 */
+		case 0x17:
+			if (gts->read_memory
+				(cnv.u8.bytes,
+				(void *)(CORE_ADDR)top, 1))
+				goto code_error_out;
+			top = (ULONGEST) cnv.u8.val;
+			break;
+
+		/* ref16 */
+		case 0x18:
+			if (gts->read_memory
+				(cnv.u16.bytes,
+				(void *)(CORE_ADDR)top, 2))
+				goto code_error_out;
+			top = (ULONGEST) cnv.u16.val;
+			break;
+
+		/* ref32 */
+		case 0x19:
+			if (gts->read_memory
+				(cnv.u32.bytes,
+				(void *)(CORE_ADDR)top, 4))
+				goto code_error_out;
+			top = (ULONGEST) cnv.u32.val;
+			break;
+
+		/* ref64 */
+		case 0x1a:
+			if (gts->read_memory
+				(cnv.u64.bytes,
+				(void *)(CORE_ADDR)top, 8))
+				goto code_error_out;
+			top = (ULONGEST) cnv.u64.val;
+			break;
+
+		/* if_goto */
+		case 0x20:
+			if (top)
+				pc = (ebuf[pc] << 8)
+					+ (ebuf[pc + 1]);
+			else
+				pc += 2;
+			/* pop */
+			top = stack[--sp];
+			break;
+
+		case op_check_if_goto:
+			if (top)
+				pc = (ebuf[pc] << 8)
+					+ (ebuf[pc + 1]);
+			else
+				pc += 2;
+			/* pop */
+			if (sp)
+				top = stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* goto */
+		case 0x21:
+			pc = (ebuf[pc] << 8) + (ebuf[pc + 1]);
+			break;
+
+		/* const8 */
+		case 0x22:
+			stack[sp++] = top;
+			top = ebuf[pc++];
+			break;
+
+		/* const16 */
+		case 0x23:
+			stack[sp++] = top;
+			top = ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			break;
+
+		/* const32 */
+		case 0x24:
+			stack[sp++] = top;
+			top = ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			break;
+
+		/* const64 */
+		case 0x25:
+			stack[sp++] = top;
+			top = ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			break;
+
+		/* reg */
+		case 0x26:
+			stack[sp++] = top;
+			arg = ebuf[pc++];
+			arg = (arg << 8) + ebuf[pc++];
+			top = gtp_action_reg_read(gts, arg);
+			if (gts->tpe->reason != gtp_stop_normal)
+				goto error_out;
+			break;
+
+		/* end */
+		case 0x27:
+			if (gts->run)
+				*(gts->run) = (int)top;
+			goto out;
+			break;
+
+		/* dup */
+		case 0x28:
+			stack[sp++] = top;
+			break;
+
+		/* pop */
+		case 0x29:
+			top = stack[--sp];
+			break;
+
+		case op_check_pop:
+			if (sp)
+				top = stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* zero_ext */
+		case 0x2a:
+			arg = ebuf[pc++];
+			if (arg < (sizeof(LONGEST)*8))
+				top &= ((LONGEST) 1 << arg) - 1;
+			break;
+
+		/* swap */
+		case 0x2b:
+			stack[sp] = top;
+			top = stack[sp - 1];
+			stack[sp - 1] = stack[sp];
+			break;
+
+		case op_check_swap:
+			if (sp) {
+				stack[sp] = top;
+				top = stack[sp - 1];
+				stack[sp - 1] = stack[sp];
+			} else
+				goto code_error_out;
+			break;
+
+		/* getv */
+		case 0x2c: {
+				int64_t	val;
+
+				arg = ebuf[pc++];
+				arg = (arg << 8) + ebuf[pc++];
+
+				stack[sp++] = top;
+
+				if (gtp_var_agent_get_val(gts, arg, &val))
+					goto code_error_out;
+
+				top = (ULONGEST)val;
+			}
+			break;
+
+		/* setv */
+		case 0x2d:
+			arg = ebuf[pc++];
+			arg = (arg << 8) + ebuf[pc++];
+			if (gtp_var_agent_set_val(gts, arg, (int64_t)top))
+				goto code_error_out;
+			break;
+
+		/* tracev */
+		case 0x2e:
+			arg = ebuf[pc++];
+			arg = (arg << 8) + ebuf[pc++];
+
+			if (gtp_collect_var(gts, arg)) {
+				/* gtp_collect_var will set error
+				   status with itself if it got error.  */
+				goto error_out;
+			}
+			break;
+
+		/* tracev_printk */
+		case op_tracev_printk: {
+				uint64_t	u64;
+				arg = ebuf[pc++];
+				arg = (arg << 8) + ebuf[pc++];
+
+				if (gtp_var_agent_get_val(gts, arg, &u64))
+					goto code_error_out;
+				if (gtp_action_printk(gts, u64, 0)) {
+					/* gtp_action_printk will set error status
+					   with itself if it got error. */
+					goto error_out;
+				}
+			}
+			break;
+		}
+
+		if (ae->type != 'X' && unlikely(sp > STACK_MAX - 5)) {
+			printk(KERN_WARNING "gtp_action_x: stack overflow.\n");
+			gts->tpe->reason
+				= gtp_stop_agent_expr_stack_overflow;
+			goto error_out;
+		}
+	}
+code_error_out:
+	gts->tpe->reason = gtp_stop_agent_expr_code_error;
+error_out:
+	ret = -1;
+	printk(KERN_WARNING "gtp_action_x: tracepoint %d addr:%p"
+			    "action X get error in pc %u.\n",
+		(int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr, pc);
+out:
+	if (unlikely(psize != GTP_PRINTF_MAX)) {
+		unsigned long	flags;
+
+		local_irq_save(flags);
+		printk("%s", pbuf - (GTP_PRINTF_MAX - psize));
+		local_irq_restore(flags);
+	}
+	if (unlikely(ae->u.exp.need_var_lock))
+		spin_unlock(&gtp_var_lock);
+	return ret;
+}
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+/* Wake up gtpframe pipe.  */
+static void
+gtp_handler_wakeup(void)
+{
+#ifdef GTP_FTRACE_RING_BUFFER
+	FID_TYPE	eid = FID_END;
+	ring_buffer_write(gtp_frame, FID_SIZE, &eid);
+#endif
+
+	if (atomic_read(&gtpframe_pipe_wq_v) > 0) {
+		atomic_dec(&gtpframe_pipe_wq_v);
+		add_preempt_count(HARDIRQ_OFFSET);
+		tasklet_schedule(&gtpframe_pipe_wq_tasklet);
+		sub_preempt_count(HARDIRQ_OFFSET);
+	}
+}
+#endif
+
+#ifdef CONFIG_X86
+/* while-stepping stop.  */
+
+static void
+gtp_step_stop(struct pt_regs *regs)
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+	regs->flags &= ~(X86_EFLAGS_TF);
+#else
+	regs->eflags &= ~(X86_EFLAGS_TF);
+#endif
+	if (__get_cpu_var(gtp_step).irq_need_open) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+		regs->flags |= X86_EFLAGS_IF;
+#else
+		regs->eflags |= X86_EFLAGS_IF;
+#endif
+	}
+	__get_cpu_var(gtp_step).step = 0;
+	__get_cpu_var(gtp_step).tpe = NULL;
+	__get_cpu_var(gtp_step).irq_need_open = 0;
+}
+#endif
+
+static void
+gtp_handler(struct gtp_trace_s *gts)
+{
+	struct action		*ae;
+
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_handler: tracepoint %d %p\n",
+	       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr);
+#endif
+#ifdef CONFIG_X86
+	if (gts->step == 0 && __get_cpu_var(gtp_step).step)
+		gtp_step_stop(gts->regs);
+#endif
+
+	gts->read_memory = (void *)probe_kernel_read;
+	if (gts->tpe->flags & GTP_ENTRY_FLAGS_CURRENT_TASK) {
+		gts->regs = task_pt_regs(get_current());
+		if (user_mode(gts->regs))
+			gts->read_memory = gtp_task_handler_read;
+	}
+
+	if ((gts->tpe->flags & GTP_ENTRY_FLAGS_REG) == 0)
+		return;
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (!gtp_pipe_trace && get_current()->pid == gtp_gtpframe_pipe_pid)
+		return;
+#endif
+
+	if ((gts->tpe->flags & GTP_ENTRY_FLAGS_SELF_TRACE) == 0
+	    && (get_current()->pid == gtp_gtp_pid
+		|| get_current()->pid == gtp_gtpframe_pid)) {
+			return;
+	}
+
+	if (gts->tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK) {
+		gts->printk_level = 8;
+		gts->printk_str = gts->tpe->printk_str;
+	}
+
+	/* Condition.  */
+	if (gts->tpe->cond) {
+		int	run;
+
+		gts->run = &run;
+		if (gtp_action_x(gts, gts->tpe->cond))
+			goto tpe_stop;
+		if (!run)
+			return;
+	}
+
+	gts->run = NULL;
+
+	/* Pass.  */
+	if (gts->step == 0 && gts->tpe->flags & GTP_ENTRY_FLAGS_HAVE_PASS) {
+		if (atomic_dec_return(&gts->tpe->current_pass) < 0)
+			goto tpe_stop;
+	}
+
+	/* Handle actions.  */
+	if (gts->step)
+		ae = gts->tpe->step_action_list;
+	else
+		ae = gts->tpe->action_list;
+	for (; ae; ae = ae->next) {
+		switch (ae->type) {
+		case 'R':
+			if (gtp_action_r(gts, ae))
+				goto tpe_stop;
+			break;
+		case 'X':
+		case 0xff:
+			if (gtp_action_x(gts, ae))
+				goto tpe_stop;
+			break;
+		case 'M':
+			if (gtp_action_memory_read(gts, ae->u.m.regnum,
+						   ae->u.m.offset,
+						   ae->u.m.size))
+				goto tpe_stop;
+			break;
+		}
+	}
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gts->next) {
+#ifdef GTP_RB
+		GTP_RB_UNLOCK(gts->next);
+#endif
+		gtp_handler_wakeup();
+	}
+#endif
+
+	return;
+
+tpe_stop:
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gts->next) {
+#ifdef GTP_RB
+		GTP_RB_UNLOCK(gts->next);
+#endif
+		gtp_handler_wakeup();
+	}
+#endif
+
+	gts->tpe->flags &= ~GTP_ENTRY_FLAGS_REG;
+
+	if (gts->tpe->type == gtp_entry_kprobe) {
+		/* Following code can insert this task into tasklet without
+		   wake up softirqd.  */
+		add_preempt_count(HARDIRQ_OFFSET);
+		tasklet_schedule(&gts->tpe->u.kp.stop_tasklet);
+		sub_preempt_count(HARDIRQ_OFFSET);
+	} else {
+		//XXX teawater
+	}
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_handler: tracepoint %d %p stop.\n",
+		(int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr);
+#endif
+	return;
+}
+
+static DEFINE_PER_CPU(int, gtp_handler_began);
+
+#ifdef CONFIG_X86
+static int	gtp_access_cooked_rdtsc;
+#endif
+static int	gtp_access_cooked_clock;
+#ifdef GTP_PERF_EVENTS
+static int	gtp_have_pc_pe;
+#endif
+
+static void
+gtp_handler_begin(void)
+{
+	if (!__get_cpu_var(gtp_handler_began)) {
+#ifdef CONFIG_X86
+		if (gtp_access_cooked_rdtsc) {
+			u64	a;
+
+			rdtscll(a);
+			__get_cpu_var(rdtsc_current) = a;
+		}
+#endif
+
+		if (gtp_access_cooked_clock)
+			__get_cpu_var(local_clock_current) = GTP_LOCAL_CLOCK;
+
+#ifdef GTP_PERF_EVENTS
+		if (gtp_have_pc_pe)
+			pc_pe_list_disable();
+#endif
+
+		__get_cpu_var(gtp_handler_began) = 1;
+	}
+}
+
+static void
+gtp_handler_end(void)
+{
+	if (__get_cpu_var(gtp_handler_began)) {
+#ifdef GTP_PERF_EVENTS
+		if (gtp_have_pc_pe)
+			pc_pe_list_enable();
+#endif
+
+		if (gtp_access_cooked_clock) {
+			__get_cpu_var(local_clock_offset) += GTP_LOCAL_CLOCK
+					- __get_cpu_var(local_clock_current);
+			__get_cpu_var(local_clock_current) = 0;
+		}
+
+#ifdef CONFIG_X86
+		if (gtp_access_cooked_rdtsc) {
+			u64	a;
+
+			rdtscll(a);
+			__get_cpu_var(rdtsc_offset) += a
+					- __get_cpu_var(rdtsc_current);
+			__get_cpu_var(rdtsc_current) = 0;
+		}
+#endif
+
+		__get_cpu_var(gtp_handler_began) = 0;
+	}
+}
+
+static inline void
+gtp_kp_pre_handler_1(struct kprobe *p, struct pt_regs *regs)
+{
+	struct kretprobe	*kpret;
+	struct gtp_kp		*gkp;
+	union gtp_entry_u	*u;
+	struct gtp_trace_s	gts;
+
+	memset(&gts, 0, sizeof(struct gtp_trace_s));
+
+	kpret = container_of(p, struct kretprobe, kp);
+	gkp = container_of(kpret, struct gtp_kp, kpret);
+	u = container_of(gkp, union gtp_entry_u, kp);
+	gts.tpe = container_of(u, struct gtp_entry, u);
+	gts.regs = regs;
+
+	gtp_handler(&gts);
+}
+
+static inline void
+gtp_kp_post_handler_1(struct kprobe *p, struct pt_regs *regs,
+		      unsigned long flags)
+{
+	struct kretprobe	*kpret;
+	struct gtp_kp		*gkp;
+	union gtp_entry_u	*u;
+	struct gtp_entry		*tpe;
+	struct gtp_trace_s	gts;
+
+	kpret = container_of(p, struct kretprobe, kp);
+	gkp = container_of(kpret, struct gtp_kp, kpret);
+	u = container_of(gkp, union gtp_entry_u, kp);
+	tpe = container_of(u, struct gtp_entry, u);
+
+	if (tpe->step == 1) {
+		memset(&gts, 0, sizeof(struct gtp_trace_s));
+
+		gts.tpe = tpe;
+		gts.regs = regs;
+		gts.step = tpe->step;
+
+		gtp_handler(&gts);
+	}
+
+#ifdef CONFIG_X86
+	if (tpe->step > 1) {
+		/* Let while-stepping begin.  */
+		/*XXX if there a another one, maybe we need add end frame to let reader know that this while step stop.  */
+		__get_cpu_var(gtp_step).step = tpe->step;
+		__get_cpu_var(gtp_step).tpe = tpe;
+		#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+		if (regs->flags & X86_EFLAGS_IF)
+		#else
+		if (regs->eflags & X86_EFLAGS_IF)
+		#endif
+			__get_cpu_var(gtp_step).irq_need_open = 1;
+		else
+			__get_cpu_var(gtp_step).irq_need_open = 0;
+		#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+		regs->flags |= X86_EFLAGS_TF;
+		regs->flags &= ~(X86_EFLAGS_IF);
+		#else
+		regs->eflags |= X86_EFLAGS_TF;
+		regs->eflags &= ~(X86_EFLAGS_IF);
+		#endif
+	}
+#endif
+}
+
+static inline void
+gtp_kp_ret_handler_1(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	struct gtp_trace_s	gts;
+	struct gtp_kp		*gkp;
+	union gtp_entry_u	*u;
+
+	memset(&gts, 0, sizeof(struct gtp_trace_s));
+
+	gkp = container_of(ri->rp, struct gtp_kp, kpret);
+	u = container_of(gkp, union gtp_entry_u, kp);
+	gts.tpe = container_of(u, struct gtp_entry, u);
+	gts.regs = regs;
+	gts.ri = ri;
+
+	gtp_handler(&gts);
+}
+
+static int
+gtp_kp_pre_handler_plus_step(struct kprobe *p, struct pt_regs *regs)
+{
+	gtp_handler_begin();
+
+	gtp_kp_pre_handler_1(p, regs);
+
+	return 0;
+}
+
+static int
+gtp_kp_pre_handler_plus(struct kprobe *p, struct pt_regs *regs)
+{
+	gtp_handler_begin();
+
+	gtp_kp_pre_handler_1(p, regs);
+
+	gtp_handler_end();
+
+	return 0;
+}
+
+static int
+gtp_kp_pre_handler(struct kprobe *p, struct pt_regs *regs)
+{
+	gtp_kp_pre_handler_1(p, regs);
+
+	return 0;
+}
+
+/* Only available when tpe->step is true.  */
+
+static void
+gtp_kp_post_handler_plus(struct kprobe *p, struct pt_regs *regs,
+			 unsigned long flags)
+{
+	gtp_kp_post_handler_1(p, regs, flags);
+
+	gtp_handler_end();
+}
+
+/* Only available when tpe->step is true.  */
+
+static void
+gtp_kp_post_handler(struct kprobe *p, struct pt_regs *regs,
+			 unsigned long flags)
+{
+	gtp_kp_post_handler_1(p, regs, flags);
+}
+
+static int
+gtp_kp_ret_handler_plus(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	gtp_handler_begin();
+
+	gtp_kp_ret_handler_1(ri, regs);
+
+	gtp_handler_end();
+
+	return 0;
+}
+
+static int
+gtp_kp_ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	gtp_kp_ret_handler_1(ri, regs);
+
+	return 0;
+}
+
+static struct action *
+gtp_action_alloc(char type)
+{
+	struct action	*ret;
+
+	ret = (struct action *)kzalloc(sizeof (struct action), GFP_KERNEL);
+	if (ret)
+		ret->type = type;
+
+	return ret;
+}
+
+static void
+gtp_action_release(struct action *ae)
+{
+	struct action	*ae2;
+
+	while (ae) {
+		ae2 = ae;
+		ae = ae->next;
+		/* Release ae2.  */
+		switch (ae2->type) {
+		case 'X':
+		case 0xff:
+			kfree(ae2->u.exp.buf);
+			break;
+		}
+		kfree(ae2);
+	}
+}
+
+static void
+gtp_src_release(struct gtpsrc *src)
+{
+	struct gtpsrc	*src2;
+
+	while (src) {
+		src2 = src;
+		src = src->next;
+		kfree(src2->src);
+		kfree(src2);
+	}
+}
+
+static void
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19))
+gtp_tracepoint_stop(struct work_struct *work)
+{
+	struct gtp_kp		*gkp = container_of(work,
+						    struct gtp_kp,
+						    stop_work);
+	union gtp_entry_u	*u = container_of(gkp,
+						  union gtp_entry_u,
+						  kp);
+	struct gtp_entry	*tpe = container_of(u,
+						    struct gtp_entry,
+						    u);
+#else
+gtp_tracepoint_stop(void *p)
+{
+	struct gtp_entry	*tpe = p;
+#endif
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_tracepoint_stop: tracepoint %d %p\n",
+	       (int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+#endif
+
+	
+	if (tpe->type == gtp_entry_kprobe) {
+		if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+			unregister_kretprobe(&tpe->u.kp.kpret);
+		else
+			unregister_kprobe(&tpe->u.kp.kpret.kp);
+	}
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+static void
+gtp_tracepoint_enable(struct work_struct *work)
+{
+	struct gtp_entry	*tpe = container_of(work,
+						    struct gtp_entry,
+						    enable_work);
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_tracepoint_enable: tracepoint %d %p\n",
+	       (int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+#endif
+
+	if (tpe->type == gtp_entry_kprobe) {
+		if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+			enable_kretprobe(&tpe->u.kp.kpret);
+		else
+			enable_kprobe(&tpe->u.kp.kpret.kp);
+	}
+}
+
+static void
+gtp_tracepoint_disable(struct work_struct *work)
+{
+	struct gtp_entry	*tpe = container_of(work,
+						    struct gtp_entry,
+						    disable_work);
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_tracepoint_disable: tracepoint %d %p\n",
+	       (int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+#endif
+
+	if (tpe->type == gtp_entry_kprobe) {
+		if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+			disable_kretprobe(&tpe->u.kp.kpret);
+		else
+			disable_kprobe(&tpe->u.kp.kpret.kp);
+	}
+}
+#endif
+
+static struct gtp_entry *
+gtp_list_add(ULONGEST num, ULONGEST addr)
+{
+	struct gtp_entry	*ret = kzalloc(sizeof(struct gtp_entry),
+					       GFP_KERNEL);
+
+	if (!ret)
+		goto out;
+	ret->num = num;
+	ret->addr = addr;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19))
+	INIT_WORK(&ret->u.kp.stop_work, gtp_tracepoint_stop);
+#else
+	INIT_WORK(&ret->u.kp.stop_work, gtp_tracepoint_stop, ret);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	INIT_WORK(&ret->enable_work, gtp_tracepoint_enable);
+	INIT_WORK(&ret->disable_work, gtp_tracepoint_disable);
+#endif
+
+	/* Add to gtp_list.  */
+	ret->next = gtp_list;
+	gtp_list = ret;
+
+out:
+	return ret;
+}
+
+static struct gtp_entry *
+gtp_list_find(ULONGEST num, ULONGEST addr)
+{
+	struct gtp_entry	*tpe;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->num == num && tpe->addr == addr)
+			return tpe;
+	}
+
+	return NULL;
+}
+
+/* If more than one gtp entry have same num, return NULL.  */
+
+static struct gtp_entry *
+gtp_list_find_without_addr_do_check(ULONGEST num)
+{
+	struct gtp_entry	*tpe, *ret = NULL;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->num == num) {
+			if (ret)
+				return NULL;
+			else
+				ret = tpe;
+		}
+	}
+
+	return ret;
+}
+
+static void
+gtp_list_release(void)
+{
+	struct gtp_entry	*tpe;
+
+	while (gtp_list) {
+		tpe = gtp_list;
+		gtp_list = gtp_list->next;
+		gtp_action_release(tpe->cond);
+		gtp_action_release(tpe->action_list);
+		gtp_action_release(tpe->step_action_list);
+		gtp_src_release(tpe->src);
+		gtp_src_release(tpe->action_cmd);
+		gtp_src_release(tpe->printk_str);
+		kfree(tpe);
+	}
+
+	current_gtp = NULL;
+	current_gtp_action_cmd = NULL;
+	current_gtp_src = NULL;
+}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)) || defined(GTP_SELF_RING_BUFFER)
+static void
+gtp_frame_iter_open(void)
+{
+	int	cpu;
+
+
+	for_each_online_cpu(cpu)
+		gtp_frame_iter[cpu] = ring_buffer_read_prepare(gtp_frame, cpu);
+	ring_buffer_read_prepare_sync();
+	for_each_online_cpu(cpu) {
+		ring_buffer_read_start(gtp_frame_iter[cpu]);
+	}
+}
+#else
+static void
+gtp_frame_iter_open(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		gtp_frame_iter[cpu] = ring_buffer_read_start(gtp_frame, cpu);
+		ring_buffer_iter_reset(gtp_frame_iter[cpu]);
+	}
+}
+#endif
+
+static void
+gtp_frame_iter_reset(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu)
+		ring_buffer_iter_reset(gtp_frame_iter[cpu]);
+	gtp_frame_current_num = -1;
+}
+
+static int
+gtp_frame_iter_peek_head(void)
+{
+	int	cpu;
+	int	ret = -1;
+	u64	min = 0;
+
+	for_each_online_cpu(cpu) {
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+		u64				ts;
+
+		while (1) {
+			rbe = ring_buffer_iter_peek(gtp_frame_iter[cpu], &ts);
+			if (rbe == NULL)
+				break;
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			ring_buffer_read(gtp_frame_iter[cpu], NULL);
+		}
+
+		if (rbe) {
+			if ((min && ts < min) || !min) {
+				min = ts;
+				ret = cpu;
+			}
+		}
+	}
+
+	if (ret < 0)
+		gtp_frame_current_num = -1;
+	else
+		gtp_frame_current_num++;
+	return ret;
+}
+
+static void
+gtp_frame_iter_close(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		if (gtp_frame_iter[cpu]) {
+			ring_buffer_read_finish(gtp_frame_iter[cpu]);
+			gtp_frame_iter[cpu] = NULL;
+		}
+	}
+}
+#endif
+
+static void
+gtp_frame_reset(void)
+{
+	gtp_frame_current_num = -1;
+#ifdef GTP_FRAME_SIMPLE
+	gtp_frame_r_start = gtp_frame;
+	gtp_frame_w_start = gtp_frame;
+	gtp_frame_end = gtp_frame + GTP_FRAME_SIZE;
+	gtp_frame_is_circular = 0;
+	gtp_frame_current = NULL;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	gtp_frame_iter_close();
+	if (gtp_frame)
+		ring_buffer_reset(gtp_frame);
+#endif
+#ifdef GTP_RB
+	gtp_rb_reset();
+#endif
+	atomic_set(&gtp_frame_create, 0);
+	if (gtp_frame_file) {
+		vfree(gtp_frame_file);
+		gtp_frame_file = NULL;
+		gtp_frame_file_size = 0;
+	}
+}
+
+static int
+hex2int(char hex, int *i)
+{
+	if ((hex >= '0') && (hex <= '9')) {
+		*i = hex - '0';
+		return 1;
+	}
+	if ((hex >= 'a') && (hex <= 'f')) {
+		*i = hex - 'a' + 10;
+		return 1;
+	}
+	if ((hex >= 'A') && (hex <= 'F')) {
+		*i = hex - 'A' + 10;
+		return 1;
+	}
+
+	return 0;
+}
+
+static char *
+hex2ulongest(char *pkg, ULONGEST *u64)
+{
+	int	i;
+
+	if (u64)
+		*u64 = 0;
+	while (hex2int(pkg[0], &i)) {
+		pkg++;
+		if (u64) {
+			*u64 = (*u64) << 4;
+			*u64 |= i & 0xf;
+		}
+	}
+
+	return pkg;
+}
+
+static char *
+hex2string(char *pkg, char *out)
+{
+	char	*ret = out;
+	int	i, j;
+
+	while (hex2int(pkg[0], &i) && hex2int(pkg[1], &j)) {
+		out[0] = i * 16 + j;
+		pkg += 2;
+		out += 1;
+	}
+	out[0] = '\0';
+
+	return ret;
+}
+
+static void
+gtpro_list_clear(void)
+{
+	struct gtpro_entry	*e;
+
+	while (gtpro_list) {
+		e = gtpro_list;
+		gtpro_list = gtpro_list->next;
+		kfree(e);
+	}
+}
+
+static struct gtpro_entry *
+gtpro_list_add(CORE_ADDR start, CORE_ADDR end)
+{
+	struct gtpro_entry	*e;
+
+	e = kmalloc(sizeof(struct gtpro_entry), GFP_KERNEL);
+	if (e == NULL)
+		goto out;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtpro_list_add: %p %p\n", (void *)start, (void *)end);
+#endif
+
+	e->start = start;
+	e->end = end;
+
+	e->next = gtpro_list;
+	gtpro_list = e;
+
+out:
+	return e;
+}
+
+static int
+gtp_src_add(char *begin, char *end, struct gtpsrc **src_list)
+{
+	struct gtpsrc	*src, *srctail;
+
+	src = kmalloc(sizeof(struct gtpsrc), GFP_KERNEL);
+	if (src == NULL)
+		return -ENOMEM;
+	src->next = NULL;
+	src->src = gtp_strdup(begin, end);
+	if (src->src == NULL) {
+		kfree(src);
+		return -ENOMEM;
+	}
+
+	if (*src_list) {
+		for (srctail = *src_list; srctail->next;
+		      srctail = srctail->next)
+			;
+		srctail->next = src;
+	} else
+		*src_list = src;
+
+	return 0;
+}
+
+#ifdef CONFIG_X86
+#define ADDR_PREFIX_OPCODE 0x67
+#define DATA_PREFIX_OPCODE 0x66
+#define LOCK_PREFIX_OPCODE 0xf0
+#define CS_PREFIX_OPCODE 0x2e
+#define DS_PREFIX_OPCODE 0x3e
+#define ES_PREFIX_OPCODE 0x26
+#define FS_PREFIX_OPCODE 0x64
+#define GS_PREFIX_OPCODE 0x65
+#define SS_PREFIX_OPCODE 0x36
+#define REPNE_PREFIX_OPCODE 0xf2
+#define REPE_PREFIX_OPCODE  0xf3
+
+static int
+gtp_step_check_insn(struct pt_regs *regs)
+{
+	uint32_t	opcode;
+	uint8_t		opcode8;
+	unsigned long	pc = GTP_REGS_PC(regs);
+
+	/* prefixes */
+	while (1) {
+		if (probe_kernel_read(&opcode8, (void *)pc, 1))
+			return -1;
+		pc++;
+		switch (opcode8) {
+		case REPE_PREFIX_OPCODE:
+		case REPNE_PREFIX_OPCODE:
+		case LOCK_PREFIX_OPCODE:
+		case CS_PREFIX_OPCODE:
+		case SS_PREFIX_OPCODE:
+		case DS_PREFIX_OPCODE:
+		case ES_PREFIX_OPCODE:
+		case FS_PREFIX_OPCODE:
+		case GS_PREFIX_OPCODE:
+		case DATA_PREFIX_OPCODE:
+		case ADDR_PREFIX_OPCODE:
+#ifndef CONFIG_X86_32
+		case 0x40 ... 0x4f:
+#endif
+			break;
+		default:
+			goto out_prefixes;
+		}
+	}
+out_prefixes:
+
+	opcode = (uint32_t)opcode8;
+reswitch:
+	switch (opcode) {
+	case 0x0f:
+		if (probe_kernel_read(&opcode8, (void *)pc, 1))
+			return -1;
+		opcode = (uint32_t) opcode8 | 0x0f00;
+		goto reswitch;
+		break;
+	case 0xfb:
+		/* sti */
+		__get_cpu_var(gtp_step).irq_need_open = 1;
+		GTP_REGS_PC(regs) = pc;
+		break;
+	case 0xfa:
+		/* cli */
+		__get_cpu_var(gtp_step).irq_need_open = 0;
+		GTP_REGS_PC(regs) = pc;
+		break;
+	case 0x0f07:
+		/* sysret */
+		return 1;
+		break;
+	};
+
+	return 0;
+}
+
+static int
+gtp_notifier_call(struct notifier_block *self, unsigned long cmd,
+		   void *ptr)
+{
+	int		ret = NOTIFY_DONE;
+	unsigned long	flags;
+	struct die_args *args;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	int		i;
+#endif
+	unsigned long	dr6;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+	unsigned long	*dr6_p;
+#endif
+
+	if (cmd != DIE_DEBUG)
+		return ret;
+
+	local_irq_save(flags);
+	args = ptr;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+	/* Get from X86 hw_breakpoint_handler.  */
+	dr6_p = (unsigned long *)ERR_PTR(args->err);
+	dr6 = *dr6_p;
+#else
+	dr6 = args->err;
+#endif
+	gtp_set_debugreg(GTP_HWB_DR7_DEF, 7);
+
+	/* Handle while-stepping.  */
+	spin_lock(&__get_cpu_var(gtp_step).lock);
+	if ((dr6 & 0x4000) != 0) {
+		/* Clear the bit that handle by KGTP.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+		(*dr6_p) &= ~(0x4000);
+#else
+ 		dr6 &= ~(0x4000);
+#endif
+		if (!__get_cpu_var(gtp_step).tpe || user_mode(args->regs))
+			gtp_step_stop(args->regs);
+		else {
+			int need_stop = gtp_step_check_insn(args->regs);
+			if (need_stop < 0)
+				printk(KERN_WARNING "KGTP: check insn in %p got error.",
+				       (void *)GTP_REGS_PC(args->regs));
+
+			preempt_disable();
+			{
+				struct gtp_trace_s	gts;
+
+				memset(&gts, 0, sizeof(struct gtp_trace_s));
+				gts.tpe = __get_cpu_var(gtp_step).tpe;
+				gts.regs = args->regs;
+				gts.step = __get_cpu_var(gtp_step).step;
+				gtp_handler(&gts);
+			}
+			preempt_enable_no_resched();
+
+			if (__get_cpu_var(gtp_step).step > 1 && !need_stop) {
+				/* XXX: not sure need set eflags each step.  */
+#if 0
+				#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+				args->regs->flags |= X86_EFLAGS_TF;
+				args->regs->flags &= ~(X86_EFLAGS_IF);
+				#else
+				args->regs->eflags |= X86_EFLAGS_TF;
+				args->regs->eflags &= ~(X86_EFLAGS_IF);
+				#endif
+#endif
+				__get_cpu_var(gtp_step).step--;
+			} else {
+				/*XXX: maybe need add a end frame.  */
+				gtp_step_stop(args->regs);
+			}
+		}
+	}
+	spin_unlock(&__get_cpu_var(gtp_step).lock);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	/* Handle watch traceppoint.  */
+	if ((dr6 & 0xf) == 0)
+		goto out;
+	read_lock(&gtp_hwb_lock);
+
+	for (i = 0; i < HWB_NUM; i++) {
+		if ((dr6 & (0x1 << i)) == 0)
+			continue;
+		/* Clear the bit that handle by KGTP.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+		(*dr6_p) &= ~(0x1 << i);
+#else
+		dr6 &= ~(0x1 << i);
+#endif
+		if (gtp_hwb[i].watch == NULL)
+			continue;
+		/* Check if gtp_hwb is updated in other CPU.  */
+		if (__get_cpu_var(gtp_hwb_sync_count_local) != gtp_hwb_sync_count) {
+			unsigned long	addr;
+
+			gtp_get_debugreg(addr, i);
+			if (addr != gtp_hwb[i].addr)
+				continue;
+		}
+		preempt_disable();
+		{
+			struct gtp_trace_s	gts;
+
+			memset(&gts, 0, sizeof(struct gtp_trace_s));
+			gts.tpe = gtp_hwb[i].watch;
+			gts.regs = args->regs;
+			gts.hwb = &gtp_hwb[i];
+			gtp_handler(&gts);
+		}
+		preempt_enable_no_resched();
+	}
+
+	/* If the HWB need update in this CPU, just update it.  */
+	if (__get_cpu_var(gtp_hwb_sync_count_local) != gtp_hwb_sync_count) {
+		gtp_set_debugreg(gtp_hwb_drx[0], 0);
+		gtp_set_debugreg(gtp_hwb_drx[1], 1);
+		gtp_set_debugreg(gtp_hwb_drx[2], 2);
+		gtp_set_debugreg(gtp_hwb_drx[3], 3);
+		__get_cpu_var(gtp_hwb_sync_count_local) = gtp_hwb_sync_count;
+	}
+
+	gtp_set_debugreg(gtp_hwb_dr7, 7);
+	read_unlock(&gtp_hwb_lock);
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+out:
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33))
+	gtp_set_debugreg(dr6, 6);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+	/* If have some other traps, let other handler handle it.  */
+	if (((*dr6_p) & GTP_HWB_DR6_MASK) == 0)
+		ret = NOTIFY_STOP;
+	current->thread.debugreg6 = *dr6_p;
+#else
+	if ((dr6 & GTP_HWB_DR6_MASK) == 0)
+		ret = NOTIFY_STOP;
+	current->thread.debugreg6 = dr6;
+#endif
+
+	local_irq_restore(flags);
+	return ret;
+}
+
+static struct notifier_block gtp_notifier = {
+	.notifier_call = gtp_notifier_call,
+	.priority = 0x7ffffffe /* we need to be notified after kprobe.  */
+};
+#endif
+
+#ifdef CONFIG_X86
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+static void
+gtp_hw_breakpoint_handler(int num, struct pt_regs *regs)
+{
+	read_lock(&gtp_hwb_lock);
+
+	if (gtp_hwb[num].watch == NULL)
+		return;
+	if (__get_cpu_var(gtp_hwb_sync_count_local) != gtp_hwb_sync_count) {
+		unsigned long	addr;
+
+		gtp_get_debugreg(addr, num);
+		if (addr != gtp_hwb[num].addr) {
+			gtp_set_debugreg(gtp_hwb[num].addr, num);
+			return;
+		}
+	}
+
+	preempt_disable();
+	{
+		struct gtp_trace_s	gts;
+
+		memset(&gts, 0, sizeof(struct gtp_trace_s));
+		gts.tpe = gtp_hwb[num].watch;
+		gts.regs = regs;
+		gts.hwb = &gtp_hwb[num];
+		gtp_handler(&gts);
+	}
+	preempt_enable_no_resched();
+
+	read_unlock(&gtp_hwb_lock);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0))
+static void
+gtp_hw_breakpoint_0_handler(struct perf_event *bp, struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[0].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_1_handler(struct perf_event *bp, struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[1].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_2_handler(struct perf_event *bp, struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[2].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_3_handler(struct perf_event *bp, struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[3].num, regs);
+}
+#else
+static void
+gtp_hw_breakpoint_0_handler(struct perf_event *bp, int nmi,
+			    struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[0].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_1_handler(struct perf_event *bp, int nmi,
+			    struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[1].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_2_handler(struct perf_event *bp, int nmi,
+			    struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[2].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_3_handler(struct perf_event *bp, int nmi,
+			    struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[3].num, regs);
+}
+#endif
+#endif
+
+static unsigned int
+gtp_hwb_size_to_arch(int size)
+{
+	unsigned int	ret;
+
+	switch (size) {
+	default:
+	case 1:
+		ret = 0;
+		break;
+	case 2:
+		ret = 1;
+		break;
+	case 4:
+		ret = 3;
+		break;
+	case 8:
+		ret = 2;
+		break;
+	}
+
+	return ret;
+}
+
+static unsigned int
+gtp_hwb_type_to_arch(int type)
+{
+	unsigned int	ret;
+
+	switch (type) {
+	default:
+	case gtp_watch_write:
+		ret = 1;
+		break;
+	case gtp_watch_exec:
+		ret = 0;
+		break;
+	case gtp_watch_read_write:
+		ret = 3;
+		break;
+	}
+
+	return ret;
+}
+
+static int
+gtp_register_hwb(const struct gtp_hwb_s *arg, int nowait)
+{
+	unsigned long		flags;
+	struct gtp_hwb_s	*hwb = NULL;
+	int			ret = -EBUSY;
+
+	write_lock_irqsave(&gtp_hwb_lock, flags);
+	if (!list_empty(&gtp_hwb_unused_list)) {
+		int	num;
+
+		hwb = list_first_entry(&gtp_hwb_unused_list, struct gtp_hwb_s, node);
+		list_del_init(&hwb->node);
+		list_add(&hwb->node, &gtp_hwb_used_list);
+		num = hwb->num;
+		memcpy((void *)&arg->node, (void *)&hwb->node, sizeof (hwb->node));
+		memcpy(hwb, arg, sizeof(struct gtp_hwb_s));
+		hwb->num = num;
+
+		/* Update gtp_hwb_dr7 and gtp_hwb_drx[num].  */
+		/* Set Gx.  */
+		gtp_hwb_dr7 |= 2 << (num << 1);
+		/* Clear RWx and LENx.  */
+		gtp_hwb_dr7 &= ~(0xf0000 << (num << 2));
+		/* Set RWx and LENx.  */
+		gtp_hwb_dr7 |= ((gtp_hwb_size_to_arch(hwb->size) << 2)
+				| gtp_hwb_type_to_arch(hwb->type))
+			       << ((num << 2) + 16);
+		/* Update DRx.  */
+		gtp_hwb_drx[num] = hwb->addr;
+
+		/* Set gtp_hwb_dr7 and gtp_hwb_drx[num] to hwb.  */
+		gtp_set_debugreg(gtp_hwb_drx[num], num);
+		gtp_set_debugreg(gtp_hwb_dr7, 7);
+
+		gtp_hwb_sync_count++;
+		hwb->count = gtp_hwb_sync_count;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		if (nowait) {
+			/* Send ipi to let other cpu update.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+			arch_send_call_function_ipi_mask(&__get_cpu_var(gtp_hwb_sync_cpu_mask));
+#else
+			arch_send_call_function_ipi(&__get_cpu_var(gtp_hwb_sync_cpu_mask));
+#endif
+		}
+#endif
+
+		ret = 0;
+	}
+	write_unlock_irqrestore(&gtp_hwb_lock, flags);
+
+	if (ret == 0 && !nowait)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		smp_call_function(gtp_hwb_sync, NULL, 1);
+#else
+		smp_call_function(gtp_hwb_sync, NULL, 0, 1);
+#endif
+
+	return ret;
+}
+
+static int
+gtp_unregister_hwb(CORE_ADDR addr, int sync)
+{
+	unsigned long		flags;
+	struct list_head	*pos;
+	struct gtp_hwb_s	*hwb = NULL;
+	int			ret = -ENXIO;
+
+	write_lock_irqsave(&gtp_hwb_lock, flags);
+	list_for_each(pos, &gtp_hwb_used_list) {
+		hwb = list_entry(pos, struct gtp_hwb_s, node);
+		if (hwb->addr == addr)
+			break;
+	}
+	if (hwb) {
+		list_del_init(&hwb->node);
+		list_add_tail(&hwb->node, &gtp_hwb_unused_list);
+		hwb->watch = NULL;
+
+		/* Update gtp_hwb_dr7.  */
+		/* Clear Gx.  */
+		gtp_hwb_dr7 &= ~(2 << (hwb->num << 1));
+
+		if (sync) {
+			gtp_hwb_sync_count++;
+
+			/* Sync gtp_hwb_dr7 update to hwb.  */
+			gtp_set_debugreg(gtp_hwb_dr7, 7);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+			/* Send ipi to let other cpu update.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+			arch_send_call_function_ipi_mask(&__get_cpu_var(gtp_hwb_sync_cpu_mask));
+#else
+			arch_send_call_function_ipi(&__get_cpu_var(gtp_hwb_sync_cpu_mask));
+#endif
+#endif
+		}
+
+		ret = 0;
+	}
+	write_unlock_irqrestore(&gtp_hwb_lock, flags);
+
+	return ret;
+}
+#endif
+
+static int
+gtp_gdbrsp_qtstop(void)
+{
+	struct gtp_entry	*tpe;
+#ifdef GTP_PERF_EVENTS
+	struct list_head	*cur;
+#endif
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtstop\n");
+#endif
+
+#ifdef FRAME_ALLOC_RECORD
+	printk(KERN_WARNING "frame_alloc_size = %llu, "
+			    "frame_alloc_size_hole = %llu\n",
+	       frame_alloc_size, frame_alloc_size_hole);
+	frame_alloc_size = 0;
+	frame_alloc_size_hole = 0;
+#endif
+
+	if (!gtp_start)
+		return -EBUSY;
+
+	flush_workqueue(gtp_wq);
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->type != gtp_entry_kprobe
+		    || (tpe->flags & GTP_ENTRY_FLAGS_REG) == 0)
+			continue;
+
+		if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+			unregister_kretprobe(&tpe->u.kp.kpret);
+		else
+			unregister_kprobe(&tpe->u.kp.kpret.kp);
+
+		tpe->flags &= ~GTP_ENTRY_FLAGS_REG;
+
+		tasklet_kill(&tpe->u.kp.stop_tasklet);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+		tasklet_kill(&tpe->disable_tasklet);
+		tasklet_kill(&tpe->enable_tasklet);
+#endif
+	}
+
+#ifdef CONFIG_X86
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	if (gtp_have_step || gtp_have_watch_tracepoint)
+#else
+	if (gtp_have_step)
+#endif
+		unregister_die_notifier(&gtp_notifier);
+
+	{
+		/* Init data of while-stepping.  */
+		int	cpu;
+		for_each_online_cpu(cpu) {
+			struct gtp_step_s	*step = &per_cpu(gtp_step, cpu);
+
+			spin_lock(&step->lock);
+			step->step = 0;
+			step->tpe = NULL;
+			spin_unlock(&step->lock);
+		}
+	}
+#endif
+
+#ifdef CONFIG_X86
+	/* Stop hwb.  */
+	if (gtp_have_watch_tracepoint) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+		{
+			int	i;
+
+			/* Register hw breakpoints.  */
+			for (i = 0; i < HWB_NUM; i++) {
+				unregister_wide_hw_breakpoint(breakinfo[i].pev);
+				breakinfo[i].pev = NULL;
+			}
+		}
+#endif
+
+		gtp_hwb_stop(NULL);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		smp_call_function(gtp_hwb_stop, NULL, 1);
+#else
+		smp_call_function(gtp_hwb_stop, NULL, 0, 1);
+#endif
+
+		for (tpe = gtp_list; tpe; tpe = tpe->next) {
+			if (tpe->type == gtp_entry_kprobe
+			    || (tpe->flags & GTP_ENTRY_FLAGS_REG) == 0
+			    || tpe->disable)
+				continue;
+
+			if (tpe->type == gtp_entry_watch_static)
+				gtp_unregister_hwb(tpe->addr, 0);
+
+			tpe->flags &= ~GTP_ENTRY_FLAGS_REG;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+			tasklet_kill(&tpe->disable_tasklet);
+			tasklet_kill(&tpe->enable_tasklet);
+#endif
+		}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		unregister_kprobe(&gtp_ipi_kp);
+#endif
+	}
+#endif
+
+#ifdef GTP_PERF_EVENTS
+	list_for_each(cur, &gtp_var_list) {
+		struct gtp_var		*var;
+		struct gtp_var_pe	*pe;
+
+		var = list_entry(cur, struct gtp_var, node);
+		if (var->type != gtp_var_perf_event
+		    && var->type != gtp_var_perf_event_per_cpu)
+			continue;
+		if (var->type == gtp_var_perf_event_per_cpu
+		    && var->u.pc.cpu < 0)
+			continue;
+
+		pe = gtp_var_get_pe(var);
+		if (pe->pe->event == NULL)
+			continue;
+
+		pe->pe->val = perf_event_read_value(pe->pe->event,
+						      &(pe->pe->enabled),
+						      &(pe->pe->running));
+		perf_event_release_kernel(pe->pe->event);
+		pe->pe->event = NULL;
+	}
+#endif
+
+	if (gtp_var_array) {
+		kfree(gtp_var_array);
+		gtp_var_array = NULL;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (gtp_frame) {
+		gtp_frame_iter_open();
+		gtp_frame_iter_reset();
+	}
+#endif
+
+	gtp_start = 0;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (atomic_read(&gtpframe_pipe_wq_v) > 0) {
+		atomic_dec(&gtpframe_pipe_wq_v);
+		tasklet_schedule(&gtpframe_pipe_wq_tasklet);
+	}
+	tasklet_kill(&gtpframe_pipe_wq_tasklet);
+#endif
+	wake_up_interruptible_nr(&gtpframe_wq, 1);
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qtinit(void)
+{
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtinit\n");
+#endif
+
+	if (gtp_start)
+		gtp_gdbrsp_qtstop();
+
+	gtp_list_release();
+
+#ifdef GTP_RB
+	if (!GTP_RB_PAGE_IS_EMPTY)
+#elif defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (gtp_frame)
+#endif
+		gtp_frame_reset();
+
+	gtpro_list_clear();
+#ifdef CONFIG_X86
+	gtp_have_watch_tracepoint = 0;
+	gtp_have_step = 0;
+#endif
+
+	gtp_var_release(0);
+
+#ifdef CONFIG_X86
+	gtp_access_cooked_rdtsc = 0;
+#endif
+	gtp_access_cooked_clock = 0;
+#ifdef GTP_PERF_EVENTS
+	gtp_have_pc_pe = 0;
+#endif
+
+	return 0;
+}
+
+struct gtp_x_loop {
+	struct gtp_x_loop	*next;
+	unsigned int		addr;
+	int			non_goto_done;
+};
+
+static struct gtp_x_loop *
+gtp_x_loop_find(struct gtp_x_loop *list, unsigned int pc)
+{
+	struct gtp_x_loop	*ret = NULL;
+
+	for (ret = list; ret; ret = ret->next) {
+		if (ret->addr == pc)
+			break;
+	}
+
+	return ret;
+}
+
+static struct gtp_x_loop *
+gtp_x_loop_add(struct gtp_x_loop **list, unsigned int pc, int non_goto_done)
+{
+	struct gtp_x_loop	*ret;
+
+	ret = kmalloc(sizeof(struct gtp_x_loop), GFP_KERNEL);
+	if (!ret)
+		goto out;
+
+	ret->addr = pc;
+	ret->non_goto_done = non_goto_done;
+
+	ret->next = *list;
+	*list = ret;
+
+out:
+	return ret;
+}
+
+struct gtp_x_if_goto {
+	struct gtp_x_if_goto	*next;
+	unsigned int		ip;
+	unsigned int		sp;
+};
+
+static struct gtp_x_if_goto *
+gtp_x_if_goto_add(struct gtp_x_if_goto **list, unsigned int pc, unsigned int sp)
+{
+	struct gtp_x_if_goto	*ret;
+
+	ret = kmalloc(sizeof(struct gtp_x_loop), GFP_KERNEL);
+	if (!ret)
+		goto out;
+
+	ret->ip = pc;
+	ret->sp = sp;
+
+	ret->next = *list;
+	*list = ret;
+
+out:
+	return ret;
+}
+
+struct gtp_x_var {
+	struct gtp_x_var	*next;
+	unsigned int		num;
+	unsigned int		flags;
+};
+
+static int
+gtp_x_var_add(struct gtp_x_var **list, unsigned int num, unsigned int flag)
+{
+	struct gtp_x_var	*curv;
+
+	for (curv = *list; curv; curv = curv->next) {
+		if (curv->num == num)
+			break;
+	}
+
+	if (!curv) {
+		curv = kmalloc(sizeof(struct gtp_x_var), GFP_KERNEL);
+		if (!curv)
+			return -ENOMEM;
+		curv->num = num;
+		curv->flags = 0;
+		if (*list) {
+			curv->next = *list;
+			*list = curv;
+		} else {
+			curv->next = NULL;
+			*list = curv;
+		}
+	}
+
+	curv->flags |= flag;
+
+	return 0;
+}
+
+static int
+gtp_add_backtrace_actions(struct gtp_entry *tpe, int step)
+{
+	struct action	*ae, *new_ae;
+	int		got_r = 0, got_m = 0;
+
+	for (ae = step ? tpe->step_action_list : tpe->action_list;
+	     ae; ae = ae->next) {
+		if (ae->type == 'R')
+			got_r = 1;
+		else if (ae->type == 'M' && ae->u.m.regnum == GTP_SP_NUM
+			  && ae->u.m.offset == 0 && ae->u.m.size >= gtp_bt_size)
+			got_m = 1;
+
+		if (got_r && got_m)
+			return 1;
+
+		/* Let ae point to the last entry of action_list.  */
+		if (!ae->next)
+			break;
+	}
+
+	if (!got_r) {
+		new_ae = gtp_action_alloc('R');
+		if (!new_ae)
+			return -ENOMEM;
+		if (ae)
+			ae->next = new_ae;
+		else {
+			if (step)
+				tpe->step_action_list = ae;
+			else
+				tpe->action_list = ae;
+		}
+
+		/* Because new_ae is the new tail.  So set it to ae. */
+		ae = new_ae;
+	}
+
+	if (!got_m) {
+		new_ae = gtp_action_alloc('M');
+		if (!new_ae)
+			return -ENOMEM;
+		new_ae->u.m.regnum = GTP_SP_NUM;
+		new_ae->u.m.size = gtp_bt_size;
+		if (ae)
+			ae->next = new_ae;
+		else {
+			if (step)
+				tpe->step_action_list = ae;
+			else
+				tpe->action_list = ae;
+		}
+	}
+
+	return 1;
+}
+
+static int
+gtp_check_getv(struct gtp_entry *tpe, struct action *ae, int step, 
+	       uint8_t *ebuf, unsigned int pc,
+	       struct gtp_x_var **list)
+{
+	int		ret = -EINVAL;
+	int		arg;
+	struct gtp_var	*var;
+
+	if (pc + 1 >= ae->u.exp.size)
+		goto out;
+	arg = ebuf[pc++];
+	arg = (arg << 8) + ebuf[pc++];
+
+	var = gtp_var_find_num(arg);
+	if (var == NULL) {
+		printk(KERN_WARNING "Action try to get TSV %d that doesn't exist.\n",
+			arg);
+		goto out;
+	}
+
+	switch (var->type) {
+	case gtp_var_special:
+		if (arg == GTP_VAR_SELF_TRACE_ID) {
+			tpe->flags |= GTP_ENTRY_FLAGS_SELF_TRACE;
+			ret = 1;
+			goto out;
+		} else if (arg == GTP_VAR_BT_ID) {
+			ret = gtp_add_backtrace_actions (tpe, step);
+			goto out;
+		} else if (arg == GTP_VAR_CURRENT_ID) {
+			tpe->flags |= GTP_ENTRY_FLAGS_CURRENT_TASK;
+			ret = 1;
+			goto out;
+		}
+
+		if (arg == GTP_VAR_COOKED_CLOCK_ID)
+			gtp_access_cooked_clock = 1;
+#ifdef CONFIG_X86
+		else if (arg == GTP_VAR_COOKED_RDTSC_ID)
+			gtp_access_cooked_rdtsc = 1;
+#endif
+		if (!var->u.hooks || (var->u.hooks
+				      && !var->u.hooks->agent_get_val)) {
+			printk(KERN_WARNING "Action try to get special TSV %d that cannot be get.\n",
+				arg);
+			ret = -EINVAL;
+			goto out;
+		}
+		break;
+
+#ifdef GTP_PERF_EVENTS
+	case gtp_var_perf_event_per_cpu:
+	case gtp_var_perf_event: {
+			struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+
+			if (pe->ptid != pe_tv_val
+			    && pe->ptid != pe_tv_enabled
+			    && pe->ptid != pe_tv_running) {
+				printk(KERN_WARNING "Action try to get perf event TSV %d that cannot be get.\n",
+				arg);
+				goto out;
+			}
+			if (var->type == gtp_var_perf_event
+			    && gtp_x_var_add(list, arg, 1)) {
+				ret = -ENOMEM;
+				goto out;
+			}
+		}
+		break;
+#endif
+
+	case gtp_var_normal:
+		if (gtp_x_var_add(list, arg, 1)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		break;
+	}
+
+	/* Change the num of var to the num of gtp_var_array.
+	   It will make this insn speed up. */
+	arg = gtp_var_array_find_num(var);
+	if (arg < 0) {
+		printk(KERN_WARNING "Action try to set TSV %d that does't inside the gtp var array.\n",
+			var->num);
+		goto out;
+	}
+	ebuf[pc - 2] = (uint8_t)(arg >> 8);
+	ebuf[pc - 1] = (uint8_t)(arg & 0xff);
+	ret = 0;
+
+out:
+	return ret;
+}
+
+static int
+gtp_check_setv(struct gtp_entry *tpe, struct action *ae, int step,
+	       uint8_t *ebuf, unsigned int pc,
+	       struct gtp_x_var **list, int loop,
+	       ULONGEST *stack, ULONGEST top)
+{
+	int		arg;
+	struct gtp_var	*var;
+	int		ret = -EINVAL;
+
+	if (pc + 1 >= ae->u.exp.size)
+		goto out;
+	arg = ebuf[pc++];
+	arg = (arg << 8) + ebuf[pc++];
+
+	var = gtp_var_find_num(arg);
+	if (var == NULL) {
+		printk(KERN_WARNING "Action try to set TSV %d that doesn't exist.\n",
+			arg);
+		goto out;
+	}
+
+	switch (var->type) {
+	case gtp_var_special:
+		switch (arg) {
+		case GTP_VAR_SELF_TRACE_ID:
+			tpe->flags |= GTP_ENTRY_FLAGS_SELF_TRACE;
+			ret = 1;
+			goto out;
+			break;
+		case GTP_VAR_KRET_ID:
+			/* XXX: still not set it value to maxactive.  */
+			tpe->flags |= GTP_ENTRY_FLAGS_IS_KRETPROBE;
+			ret = 1;
+			goto out;
+			break;
+		case GTP_VAR_BT_ID:
+			ret = gtp_add_backtrace_actions (tpe, step);
+			goto out;
+			break;
+		case GTP_VAR_CURRENT_ID:
+			tpe->flags |= GTP_ENTRY_FLAGS_CURRENT_TASK;
+			ret = 1;
+			goto out;
+			break;
+		case GTP_VAR_PRINTK_LEVEL_ID:
+			if (loop || step) {
+				printk(KERN_WARNING "Loop or step action doesn't support printk.\n");
+				goto out;
+			} else
+				tpe->flags |= GTP_ENTRY_FLAGS_HAVE_PRINTK;
+			break;
+#ifdef CONFIG_X86
+		case GTP_WATCH_STATIC_ID:
+			if (stack == NULL || top > 1) {
+				printk(KERN_WARNING "$watch_static just support set to 0 or 1.\n");
+				goto out;
+			}
+			/* Init watch struct inside gtp_entry.  */
+			if (tpe->type != gtp_entry_watch_static
+			    && tpe->type != gtp_entry_watch_dynamic) {
+				tpe->type = gtp_entry_watch_dynamic;
+				tpe->u.watch.type = gtp_watch_write;
+				tpe->u.watch.size = 1;
+			}
+			gtp_have_watch_tracepoint = 1;
+			if (top == 1)
+				tpe->type = gtp_entry_watch_static;
+			else
+				tpe->type = gtp_entry_watch_dynamic;
+			ret = 1;
+			goto out;
+			break;
+		case GTP_WATCH_TYPE_ID:
+			if (stack && (tpe->type == gtp_entry_watch_static
+				      || tpe->type == gtp_entry_watch_dynamic)) {
+				if (top != gtp_watch_exec
+				    && top != gtp_watch_write
+				    && top != gtp_watch_read_write) {
+					printk(KERN_WARNING "$watch_type just support set to 0, 1 or 2.\n");
+					goto out;
+				}
+				tpe->u.watch.type = top;
+				ret = 1;
+				goto out;
+			}
+			break;
+		case GTP_WATCH_SIZE_ID:
+			if (stack && (tpe->type == gtp_entry_watch_static
+				      || tpe->type == gtp_entry_watch_dynamic)) {
+				if (top != 1 && top != 2 && top != 4
+				    && top != 8) {
+					printk(KERN_WARNING "$watch_size just support set to 1, 2, 4 or 8.\n");
+					goto out;
+				}
+				tpe->u.watch.size = top;
+				ret = 1;
+				goto out;
+			}
+			break;
+#endif
+		}
+
+		if (!var->u.hooks || (var->u.hooks
+				      && !var->u.hooks->agent_set_val)) {
+			printk(KERN_WARNING "Action try to set special TSV %d that cannot be get.\n",
+			       arg);
+			goto out;
+		}
+		break;
+
+#ifdef GTP_PERF_EVENTS
+	case gtp_var_perf_event_per_cpu:
+	case gtp_var_perf_event: {
+			struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+
+			if (pe->ptid != pe_tv_en
+			    && pe->ptid != pe_tv_val) {
+				printk(KERN_WARNING "Action try to set perf event TSV %d that cannot be set.\n",
+				arg);
+				goto out;
+			}
+			if (var->type == gtp_var_perf_event
+			    && gtp_x_var_add(list, arg, 2)) {
+				ret = -ENOMEM;
+				goto out;
+			}
+		}
+		break;
+#endif
+
+	case gtp_var_normal:
+		if (gtp_x_var_add(list, arg, 2)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		break;
+	}
+
+	/* Change the num of var to the num of gtp_var_array.
+	   It will make this insn speed up. */
+	arg = gtp_var_array_find_num(var);
+	if (arg < 0) {
+		printk(KERN_WARNING "Action try to set TSV %d that does't inside the gtp var array.\n",
+		       var->num);
+		goto out;
+	}
+	ebuf[pc - 2] = (uint8_t)(arg >> 8);
+	ebuf[pc - 1] = (uint8_t)(arg & 0xff);
+	ret = 0;
+
+out:
+	return ret;
+}
+
+/* This is the first check.
+   1. Get the max size of stack need (sp_max).
+      Check if it bigger than SP_MAX.
+   2. Check TSV.
+      Check if normal TSV id is right.
+      Check special TSV, if need change insn code to op_special_getv,
+      op_special_setv or op_special_tracev.
+   3. If this is loop, change ae->type to 0xff and return.  */
+
+static int
+gtp_check_x_simple(struct gtp_entry *tpe, struct action *ae, int step)
+{
+	int			ret = -EINVAL;
+	unsigned int		pc = 0, sp = 0;
+	struct gtp_x_if_goto	*glist = NULL, *gtmp;
+	struct gtp_x_var	*vlist = NULL, *vtmp;
+	uint8_t			*ebuf = ae->u.exp.buf;
+	int			last_trace_pc = -1;
+	unsigned int		sp_max = 0;
+	ULONGEST		top = 0;
+	ULONGEST		stack_space[STACK_MAX + 10];
+	ULONGEST		*stack = stack_space;
+
+reswitch:
+	while (pc < ae->u.exp.size) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_check_x_simple: cmd %u %x\n", pc,
+		       ebuf[pc]);
+#endif
+		if (stack) {
+			int	arg;
+
+			switch (ebuf[pc]) {
+			/* add */
+			case 0x02:
+				if (sp)
+					top += stack[sp - 1];
+				break;
+
+			/* sub */
+			case 0x03:
+				if (sp)
+					top = stack[sp - 1] - top;
+				break;
+
+			/* mul */
+			case 0x04:
+				if (sp)
+					top *= stack[sp - 1];
+				break;
+
+#ifndef CONFIG_MIPS
+			/* div_signed */
+			case 0x05:
+				if (top && sp) {
+					LONGEST l = (LONGEST) stack[sp - 1];
+					do_div(l, (LONGEST) top);
+					top = l;
+				} else if (top == 0) {
+					printk(KERN_WARNING "gtp_check_x_simple: div_signed "
+							    "0 in %d.\n", pc);
+					goto release_out;
+				}
+				break;
+
+			/* div_unsigned */
+			case 0x06:
+				if (top && sp) {
+					ULONGEST ul = stack[sp - 1];
+					do_div(ul, top);
+					top = ul;
+				} else if (top == 0) {
+					printk(KERN_WARNING "gtp_check_x_simple: div_unsigned "
+							    "0 in %d.\n", pc);
+					goto release_out;
+				}
+				break;
+
+			/* rem_signed */
+			case 0x07:
+				if (top && sp) {
+					LONGEST l1 = (LONGEST) stack[sp - 1];
+					LONGEST l2 = (LONGEST) top;
+					top = do_div(l1, l2);
+				} else if (top == 0) {
+					printk(KERN_WARNING "gtp_check_x_simple: rem_signed "
+							    "0 in %d.\n", pc);
+					goto release_out;
+				}
+				break;
+
+			/* rem_unsigned */
+			case 0x08:
+				if (top && sp) {
+					ULONGEST ul1 = stack[sp - 1];
+					ULONGEST ul2 = top;
+					top = do_div(ul1, ul2);
+				} else if (top == 0) {
+					printk(KERN_WARNING "gtp_check_x_simple: rem_unsigned "
+							    "0 in %d.\n", pc);
+					goto release_out;
+				}
+				break;
+#endif
+			/* lsh */
+			case 0x09:
+				if (sp)
+					top = stack[sp - 1] << top;
+				break;
+
+			/* rsh_signed */
+			case 0x0a:
+				if (sp)
+					top = ((LONGEST) stack[sp - 1]) >> top;
+				break;
+
+			/* rsh_unsigned */
+			case 0x0b:
+				if (sp)
+					top = stack[sp - 1] >> top;
+				break;
+
+			/* log_not */
+			case 0x0e:
+				top = !top;
+				break;
+
+			/* bit_and */
+			case 0x0f:
+				if (sp)
+					top &= stack[sp - 1];
+				break;
+
+			/* bit_or */
+			case 0x10:
+				if (sp)
+					top |= stack[sp - 1];
+				break;
+
+			/* bit_xor */
+			case 0x11:
+				if (sp)
+					top ^= stack[sp - 1];
+				break;
+
+			/* bit_not */
+			case 0x12:
+				top = ~top;
+				break;
+
+			/* equal */
+			case 0x13:
+				if (sp)
+					top = (stack[sp - 1] == top);
+				break;
+
+			/* less_signed */
+			case 0x14:
+				if (sp)
+					top = (((LONGEST) stack[sp - 1])
+						< ((LONGEST) top));
+				break;
+
+			/* less_unsigned */
+			case 0x15:
+				if (sp)
+					top = (stack[sp - 1] < top);
+				break;
+
+			/* ext */
+			case 0x16:
+ 				arg = ebuf[pc + 1];
+				if (arg < (sizeof(LONGEST)*8)) {
+					LONGEST mask = 1 << (arg - 1);
+					top &= ((LONGEST) 1 << arg) - 1;
+					top = (top ^ mask) - mask;
+				}
+				break;
+
+			/* const8 */
+			case 0x22:
+				stack[sp + 1] = top;
+				top = ebuf[pc + 1];
+				break;
+
+			/* const16 */
+			case 0x23:
+				stack[sp + 1] = top;
+				top = ebuf[pc + 1];
+				top = (top << 8) + ebuf[pc + 2];
+				break;
+
+			/* const32 */
+			case 0x24:
+				stack[sp + 1] = top;
+				top = ebuf[pc + 1];
+				top = (top << 8) + ebuf[pc + 2];
+				top = (top << 8) + ebuf[pc + 3];
+				top = (top << 8) + ebuf[pc + 4];
+				break;
+
+			/* const64 */
+			case 0x25:
+				stack[sp + 1] = top;
+				top = ebuf[pc + 1];
+				top = (top << 8) + ebuf[pc + 2];
+				top = (top << 8) + ebuf[pc + 3];
+				top = (top << 8) + ebuf[pc + 4];
+				top = (top << 8) + ebuf[pc + 5];
+				top = (top << 8) + ebuf[pc + 6];
+				top = (top << 8) + ebuf[pc + 7];
+				top = (top << 8) + ebuf[pc + 8];
+				break;
+
+			/* dup */
+			case 0x28:
+				stack[sp + 1] = top;
+				break;
+
+			/* pop */
+			case 0x29:
+				if (sp)
+					top = stack[sp - 1];
+				break;
+
+			/* zero_ext */
+			case 0x2a:
+				arg = ebuf[pc + 1];
+				if (arg < (sizeof(LONGEST)*8))
+					top &= ((LONGEST) 1 << arg) - 1;
+				break;
+
+			/* swap */
+			case 0x2b:
+				if (sp) {
+					stack[sp] = top;
+					top = stack[sp - 1];
+					stack[sp - 1] = stack[sp];
+				}
+				break;
+
+			/* trace */
+			case 0x0c:
+			/* trace_quick */
+			case 0x0d:
+			/* ref8 */
+			case 0x17:
+			/* ref16 */
+			case 0x18:
+			/* ref32 */
+			case 0x19:
+			/* ref64 */
+			case 0x1a:
+			/* if_goto */
+			case 0x20:
+			/* reg */
+			case 0x26:
+			/* getv */
+			case 0x2c:
+				stack = NULL;
+				break;
+			}
+		}
+		switch (ebuf[pc++]) {
+		/* add */
+		case 0x02:
+		/* sub */
+		case 0x03:
+		/* mul */
+		case 0x04:
+		/* lsh */
+		case 0x09:
+		/* rsh_signed */
+		case 0x0a:
+		/* rsh_unsigned */
+		case 0x0b:
+		/* bit_and */
+		case 0x0f:
+		/* bit_or */
+		case 0x10:
+		/* bit_xor */
+		case 0x11:
+		/* equal */
+		case 0x13:
+		/* less_signed */
+		case 0x14:
+		/* less_unsigned */
+		case 0x15:
+		/* pop */
+		case 0x29:
+		/* swap */
+		case 0x2b:
+			if (sp < 1) {
+				printk(KERN_WARNING "gtp_check_x_simple: stack "
+						    "overflow in %d.\n",
+				       pc - 1);
+				goto release_out;
+			} else {
+				if (ebuf[pc - 1] != 0x2b)
+					sp--;
+			}
+			break;
+
+		/* trace */
+		case 0x0c:
+			if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)
+				last_trace_pc = pc - 1;
+
+			if (sp < 2) {
+				printk(KERN_WARNING "gtp_check_x_simple: stack "
+						    "overflow in %d.\n",
+				       pc - 1);
+				goto release_out;
+			} else
+				sp -= 2;
+			break;
+
+		/* log_not */
+		case 0x0e:
+		/* bit_not */
+		case 0x12:
+		/* ref8 */
+		case 0x17:
+		/* ref16 */
+		case 0x18:
+		/* ref32 */
+		case 0x19:
+		/* ref64 */
+		case 0x1a:
+			break;
+
+		/* dup */
+		case 0x28:
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* const8 */
+		case 0x22:
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+		/* ext */
+		case 0x16:
+		/* zero_ext */
+		case 0x2a:
+			if (pc >= ae->u.exp.size)
+				goto release_out;
+			pc++;
+			break;
+
+		/* trace_quick */
+		case 0x0d:
+			if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)
+				last_trace_pc = pc - 1;
+
+			if (pc >= ae->u.exp.size)
+				goto release_out;
+			pc++;
+			break;
+
+		/* const16 */
+		case 0x23:
+		/* reg */
+		case 0x26:
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+			pc += 2;
+
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* const32 */
+		case 0x24:
+			if (pc + 3 >= ae->u.exp.size)
+				goto release_out;
+			pc += 4;
+
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* const64 */
+		case 0x25:
+			if (pc + 7 >= ae->u.exp.size)
+				goto release_out;
+			pc += 8;
+
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* if_goto */
+		case 0x20:
+			if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK) {
+				printk(KERN_WARNING "If_goto action doesn't"
+				       "support printk.\n");
+				goto release_out;
+			}
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+
+			{
+				unsigned int	dpc = (ebuf[pc] << 8)
+						      + ebuf[pc + 1];
+
+				if (dpc < pc) {
+					/* This action X include loop. */
+					ae->type = 0xff;
+					ret = 0;
+					goto release_out;
+				}
+
+				if (!gtp_x_if_goto_add(&glist, dpc, sp)) {
+					ret = -ENOMEM;
+					goto release_out;
+				}
+			}
+
+			pc += 2;
+			break;
+
+		/* goto */
+		case 0x21:
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+
+			{
+				unsigned int	dpc = (ebuf[pc] << 8)
+						      + ebuf[pc + 1];
+
+				if (dpc < pc) {
+					/* This action X include loop. */
+					ae->type = 0xff;
+					ret = 0;
+					goto release_out;
+				}
+
+				pc = dpc;
+			}
+			break;
+
+		/* end */
+		case 0x27:
+			goto out;
+			break;
+
+		/* getv */
+		case 0x2c:
+			ret = gtp_check_getv(tpe, ae, step, ebuf, pc, &vlist);
+			if (ret != 0)
+				goto release_out;
+			pc += 2;
+
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* setv */
+		case 0x2d:
+			ret = gtp_check_setv(tpe, ae, step, ebuf, pc, &vlist,
+					     0, stack, top);
+			if (ret != 0)
+				goto release_out;
+			pc += 2;
+			break;
+
+		/* tracev */
+		case 0x2e:
+			if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)
+				last_trace_pc = pc - 1;
+
+			ret = gtp_check_getv(tpe, ae, step, ebuf, pc, &vlist);
+			if (ret != 0)
+				goto release_out;
+			pc += 2;
+			break;
+
+		/* div_signed */
+		case 0x05:
+		/* div_unsigned */
+		case 0x06:
+		/* rem_signed */
+		case 0x07:
+		/* rem_unsigned */
+		case 0x08:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			goto release_out;
+#endif
+			if (sp < 1) {
+				printk(KERN_WARNING "gtp_check_x_simple: stack "
+						    "overflow in %d.\n",
+				       pc - 1);
+				goto release_out;
+			} else
+				sp--;
+			break;
+
+		/* float */
+		case 0x01:
+		/* ref_float */
+		case 0x1b:
+		/* ref_double */
+		case 0x1c:
+		/* ref_long_double */
+		case 0x1d:
+		/* l_to_d */
+		case 0x1e:
+		/* d_to_l */
+		case 0x1f:
+		/* trace16 */
+		case 0x30:
+		default:
+			goto release_out;
+			break;
+		}
+	}
+	goto release_out;
+
+out:
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "sp_max = %d\n", sp_max);
+#endif
+	if (sp_max >= STACK_MAX) {
+		printk(KERN_WARNING "gtp_check_x_simple: stack overflow, "
+				    "current %d, max %d.\n",
+		       sp_max, STACK_MAX);
+		goto release_out;
+	}
+	if (glist) {
+		pc = glist->ip;
+		sp = glist->sp;
+		gtmp = glist;
+		glist = glist->next;
+		kfree(gtmp);
+		goto reswitch;
+	}
+	ret = 0;
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_check_x_simple: Code is OK. sp_max is %d.\n",
+	       sp_max);
+#endif
+
+release_out:
+	while (glist) {
+		gtmp = glist;
+		glist = glist->next;
+		kfree(gtmp);
+	}
+	while (vlist) {
+		vtmp = vlist;
+		vlist = vlist->next;
+
+		if ((vtmp->flags & 1) && (vtmp->flags & 2))
+			ae->u.exp.need_var_lock = 1;
+		kfree(vtmp);
+	}
+
+	if ((tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK) && last_trace_pc > -1) {
+		/* Set the last trace code to printk code.  */
+		switch (ebuf[last_trace_pc]) {
+		/* trace */
+		case 0x0c:
+			ebuf[last_trace_pc] = op_trace_printk;
+			break;
+		/* trace_quick */
+		case 0x0d:
+			ebuf[last_trace_pc] = op_trace_quick_printk;
+			break;
+		/* tracev */
+		case 0x2e:
+			ebuf[last_trace_pc] = op_tracev_printk;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/* The second check.
+   Special check for loop.
+   Different with gtp_check_x_simple is it will not check sp_max.  */
+
+static int
+gtp_check_x_loop(struct gtp_entry *tpe, struct action *ae, int step)
+{
+	int			ret = -EINVAL;
+	unsigned int		pc = 0;
+	struct gtp_x_loop	*glist = NULL, *gtmp;
+	struct gtp_x_var	*vlist = NULL, *vtmp;
+	uint8_t			*ebuf = ae->u.exp.buf;
+
+	printk(KERN_WARNING "Action of tracepoint %d have loop.\n",
+	       (int)tpe->num);
+
+	tpe->flags &= ~GTP_ENTRY_FLAGS_HAVE_PRINTK;
+
+reswitch:
+	while (pc < ae->u.exp.size) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_check_x_loop: cmd %x\n", ebuf[pc]);
+#endif
+		switch (ebuf[pc++]) {
+		/* add */
+		case 0x02:
+			ebuf[pc - 1] = op_check_add;
+			break;
+		/* sub */
+		case 0x03:
+			ebuf[pc - 1] = op_check_sub;
+			break;
+		/* mul */
+		case 0x04:
+			ebuf[pc - 1] = op_check_mul;
+			break;
+		/* lsh */
+		case 0x09:
+			ebuf[pc - 1] = op_check_lsh;
+			break;
+		/* rsh_signed */
+		case 0x0a:
+			ebuf[pc - 1] = op_check_rsh_signed;
+			break;
+		/* rsh_unsigned */
+		case 0x0b:
+			ebuf[pc - 1] = op_check_rsh_unsigned;
+			break;
+		/* bit_and */
+		case 0x0f:
+			ebuf[pc - 1] = op_check_bit_and;
+			break;
+		/* bit_or */
+		case 0x10:
+			ebuf[pc - 1] = op_check_bit_or;
+			break;
+		/* bit_xor */
+		case 0x11:
+			ebuf[pc - 1] = op_check_bit_xor;
+			break;
+		/* equal */
+		case 0x13:
+			ebuf[pc - 1] = op_check_equal;
+			break;
+		/* less_signed */
+		case 0x14:
+			ebuf[pc - 1] = op_check_less_signed;
+			break;
+		/* less_unsigned */
+		case 0x15:
+			ebuf[pc - 1] = op_check_less_unsigned;
+			break;
+		/* pop */
+		case 0x29:
+			ebuf[pc - 1] = op_check_pop;
+			break;
+		/* swap */
+		case 0x2b:
+			ebuf[pc - 1] = op_check_swap;
+			break;
+
+		/* trace */
+		case 0x0c:
+			ebuf[pc - 1] = op_check_trace;
+			break;
+
+		/* log_not */
+		case 0x0e:
+		/* bit_not */
+		case 0x12:
+		/* ref8 */
+		case 0x17:
+		/* ref16 */
+		case 0x18:
+		/* ref32 */
+		case 0x19:
+		/* ref64 */
+		case 0x1a:
+		/* dup */
+		case 0x28:
+			break;
+
+		/* const8 */
+		case 0x22:
+		/* ext */
+		case 0x16:
+		/* zero_ext */
+		case 0x2a:
+		/* trace_quick */
+		case 0x0d:
+			if (pc >= ae->u.exp.size)
+				goto release_out;
+			pc++;
+			break;
+
+		/* const16 */
+		case 0x23:
+		/* reg */
+		case 0x26:
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+			pc += 2;
+			break;
+
+		/* const32 */
+		case 0x24:
+			if (pc + 3 >= ae->u.exp.size)
+				goto release_out;
+			pc += 4;
+			break;
+
+		/* const64 */
+		case 0x25:
+			if (pc + 7 >= ae->u.exp.size)
+				goto release_out;
+			pc += 8;
+			break;
+
+		/* if_goto */
+		case 0x20:
+		case op_check_if_goto:
+			ebuf[pc - 1] = op_check_if_goto;
+
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+
+			gtmp = gtp_x_loop_find(glist, pc);
+			if (gtmp) {
+				if (gtmp->non_goto_done)
+					goto out;
+				else {
+					gtmp->non_goto_done = 1;
+					pc += 2;
+				}
+			} else {
+				if (!gtp_x_loop_add(&glist, pc, 0)) {
+					ret = -ENOMEM;
+					goto release_out;
+				}
+				pc = (ebuf[pc] << 8) + ebuf[pc + 1];
+			}
+			break;
+
+		/* goto */
+		case 0x21:
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+
+			gtmp = gtp_x_loop_find(glist, pc);
+			if (gtmp)
+				goto out;
+			else {
+				if (!gtp_x_loop_add(&glist, pc, 1)) {
+					ret = -ENOMEM;
+					goto release_out;
+				}
+			}
+
+			pc = (ebuf[pc] << 8) + (ebuf[pc + 1]);
+			break;
+
+		/* end */
+		case 0x27:
+			goto out;
+			break;
+
+		/* getv */
+		case 0x2c:
+		/* tracev */
+		case 0x2e:
+			ret = gtp_check_getv(tpe, ae, step, ebuf, pc, &vlist);
+			if (ret != 0)
+				goto release_out;
+			pc += 2;
+			break;
+
+		/* setv */
+		case 0x2d:
+			ret = gtp_check_setv(tpe, ae, step, ebuf, pc, &vlist,
+					     1, NULL, 0);
+			if (ret != 0)
+				goto release_out;
+			pc += 2;
+			break;
+
+		/* div_signed */
+		case 0x05:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			printk(KERN_WARNING "MIPS don't have 64 bit div.\n");
+			goto release_out;
+#endif
+			ebuf[pc - 1] = op_check_div_signed;
+			break;
+		/* div_unsigned */
+		case 0x06:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			printk(KERN_WARNING "MIPS don't have 64 bit div.\n");
+			goto release_out;
+#endif
+			ebuf[pc - 1] = op_check_div_unsigned;
+			break;
+		/* rem_signed */
+		case 0x07:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			printk(KERN_WARNING "MIPS don't have 64 bit div.\n");
+			goto release_out;
+#endif
+			ebuf[pc - 1] = op_check_rem_signed;
+			break;
+		/* rem_unsigned */
+		case 0x08:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			printk(KERN_WARNING "MIPS don't have 64 bit div.\n");
+			goto release_out;
+#endif
+			ebuf[pc - 1] = op_check_rem_unsigned;
+			break;
+
+		/* float */
+		case 0x01:
+		/* ref_float */
+		case 0x1b:
+		/* ref_double */
+		case 0x1c:
+		/* ref_long_double */
+		case 0x1d:
+		/* l_to_d */
+		case 0x1e:
+		/* d_to_l */
+		case 0x1f:
+		/* trace16 */
+		case 0x30:
+		default:
+			goto release_out;
+			break;
+		}
+	}
+	goto release_out;
+
+out:
+	for (gtmp = glist; gtmp; gtmp = gtmp->next) {
+		if (!gtmp->non_goto_done)
+			break;
+	}
+	if (gtmp) {
+		pc = gtmp->addr + 2;
+		gtmp->non_goto_done = 1;
+		goto reswitch;
+	}
+	ret = 0;
+
+release_out:
+	while (glist) {
+		gtmp = glist;
+		glist = glist->next;
+		kfree(gtmp);
+	}
+	while (vlist) {
+		vtmp = vlist;
+		vlist = vlist->next;
+
+		if ((vtmp->flags & 2)
+		    && ((vtmp->flags & 1) || (vtmp->flags & 4)))
+			ae->u.exp.need_var_lock = 1;
+		kfree(vtmp);
+	}
+
+	return ret;
+}
+
+static int
+gtp_check_x(struct gtp_entry *tpe, struct action *ae, int step)
+{
+	int	ret = gtp_check_x_simple(tpe, ae, step);
+
+	if (ret != 0 || ae->type == 'X')
+		return ret;
+
+	return gtp_check_x_loop(tpe, ae, step);
+}
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+static void
+gtpframe_pipe_wq_wake_up(unsigned long data)
+{
+	/* About why KGTP use a tasklet to wake up:
+	   When a tracepoint that is inserted to "schedule" function
+	   call wake up inside its handler, the kernel maybe will deadlock.
+	   "tasklet_schedule" is a small function and it can be
+	   very easy controlled to wake up softirqd or not
+	   (add_preempt_count(HARDIRQ_OFFSET) can control it). 
+	   So KGTP just use it to wake up a task.  */
+	wake_up_interruptible_nr(&gtpframe_pipe_wq, 1);
+}
+#endif
+
+static void
+gtp_wq_add_work(unsigned long data)
+{
+	/* Same with prev function, queue_work will wake up sometimes.  */
+	queue_work(gtp_wq, (struct work_struct *)data);
+}
+
+static int
+gtp_gdbrsp_qtstart(void)
+{
+	int			ret = -EINVAL;
+	int			cpu;
+	struct gtp_entry	*tpe;
+	int			i;
+	struct gtp_var		*var;
+	struct list_head	*cur;
+#ifdef CONFIG_X86
+	unsigned long		flags;
+#endif
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtstart\n");
+#endif
+
+	if (gtp_start)
+		return -EBUSY;
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (!tracing_is_on()) {
+		printk(KERN_WARNING "qtstart: Ring buffer is off.  Please use "
+		       "command "
+		       "\"echo 1 > /sys/kernel/debug/tracing/tracing_on\" "
+		       "open it.\n");
+		return -EIO;
+	}
+#endif
+
+	/* Setup the gtp_var_array.
+	   It must be setup before action because action need it.  */
+	gtp_var_array = kcalloc(gtp_var_num, sizeof(struct gtp_var *),
+				GFP_KERNEL);
+	if (!gtp_var_array)
+		return -ENOMEM;
+	i = 0;
+	list_for_each(cur, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		gtp_var_array[i] = var;
+		i++;
+	}
+#ifdef GTP_RB
+	var = gtp_var_find_num(GTP_STEP_ID_ID);
+	if (var == NULL) {
+		printk(KERN_WARNING "KGTP: cannot get $step_id.\n");
+		return -EINVAL;
+	}
+	gtp_var_array_step_id_id = gtp_var_array_find_num(var);
+	if (gtp_var_array_step_id_id < 0) {
+		printk(KERN_WARNING "KGTP: cannot get $step_id.\n");
+		return -EINVAL;
+	}
+#endif
+
+	/* Check and setup actions.  */
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		struct action	*ae, *prev_ae;
+		int		check_step = 0;
+
+		/* Check tpe->step for old version GDB without patch
+		   http://sourceware.org/ml/gdb-cvs/2013-04/msg00044.html  */
+		if (tpe->step != 0 && tpe->step_action_list == NULL)
+			tpe->step = 0;
+
+		/* Check cond.  */
+		if (tpe->cond) {
+			ret = gtp_check_x(tpe, tpe->cond, 0);
+			if (ret > 0) {
+				kfree(tpe->cond->u.exp.buf);
+				kfree(tpe->cond);
+				tpe->cond = NULL;
+			} else if (ret < 0) {
+				printk(KERN_WARNING "gtp_check_x get error %d\n",
+				       ret);
+				goto out;
+			}
+		}
+
+		/* Check X.  */
+next_list:
+		prev_ae = NULL;
+		for (ae = check_step ? tpe->step_action_list : tpe->action_list;
+		     ae; ae = ae->next) {
+re_check:
+			if (ae->type == 'X' || ae->type == 0xff) {
+				ret = gtp_check_x(tpe, ae, check_step);
+				if (ret > 0) {
+					struct action	*old_ae = ae;
+
+					/* Remove ae from action_list.  */
+					ae = ae->next;
+					if (prev_ae)
+						prev_ae->next = ae;
+					else {
+						if (check_step)
+							tpe->step_action_list = ae;
+						else
+							tpe->action_list = ae;
+					}
+
+					kfree(old_ae->u.exp.buf);
+					kfree(old_ae);
+
+					if (ae)
+						goto re_check;
+					else
+						break;
+				} else if (ret < 0) {
+					printk(KERN_WARNING "KGTP: gtp_check_x get error %d\n",
+					       ret);
+					goto out;
+				}
+			}
+
+			prev_ae = ae;
+		}
+		if (check_step == 0) {
+			/* Begin to check step_action_list.  */
+			check_step = 1;
+			goto next_list;
+		}	
+
+		/* Check the tracepoint that have printk.  */
+		if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK) {
+			struct action	*ae, *prev_ae = NULL;
+			struct gtpsrc	*src, *srctail = NULL;
+
+restart:
+			for (ae = tpe->action_list; ae;
+			     prev_ae = ae, ae = ae->next) {
+				switch (ae->type) {
+				case 'R':
+					/* Remove it. */
+					if (prev_ae)
+						prev_ae->next = ae->next;
+					else
+						tpe->action_list = ae->next;
+					kfree(ae);
+					if (prev_ae)
+						ae = prev_ae;
+					else
+						goto restart;
+					break;
+				case 'M':
+					printk(KERN_WARNING "qtstart: action "
+					       "of tp %d %p is not right.  "
+					       "Please put global variable to "
+					       "trace state variable "
+					       "$printk_tmp before print it.\n",
+					       (int)tpe->num,
+					       (void *)(CORE_ADDR)tpe->addr);
+					ret = -EINVAL;
+					goto out;
+					break;
+				}
+			}
+
+			for (src = tpe->src; src; src = src->next) {
+				int		i;
+				char		str[strlen(src->src) >> 1];
+				char		*var = NULL;
+				ULONGEST	num;
+				char		tmp[30];
+				struct gtpsrc	*ksrc;
+
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_qtstart: action "
+						 "%s\n", src->src);
+#endif
+				/* Get the action in str.  */
+				if (strncmp("cmd:0:", src->src,
+					    strlen("cmd:0:")))
+					continue;
+				var = hex2ulongest(src->src + 6, &num);
+				if (var[0] == '\0')
+					goto out;
+				var++;
+				hex2string(var, str);
+				if (strlen(str) != num)
+					goto out;
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_qtstart: action "
+						 "command %s\n", str);
+#endif
+
+				if (strncmp("collect ", str,
+					    strlen("collect ")))
+					continue;
+				for (i = strlen("collect "); ; i++) {
+					if (str[i] != ' ') {
+						var = str + i;
+						break;
+					}
+					if (str[i] == '\0')
+						break;
+				}
+				if (!var) {
+					printk(KERN_WARNING "qtstart: cannot "
+							    "get the var name "
+							    "from tp %d %p"
+							    "command %s.\n",
+					       (int)tpe->num,
+					       (void *)(CORE_ADDR)tpe->addr,
+					       str);
+					goto out;
+				}
+				if (strcmp(var, "$args") == 0
+				    || strcmp(var, "$local") == 0) {
+					printk(KERN_WARNING "qtstart: cannot "
+							    "print $args and "
+							    "$local.\n");
+					goto out;
+				}
+				if (strcmp(var, "$reg") == 0)
+					continue;
+
+				if (var[0] == '$') {
+					/* Check if var is TSV that cannot get in action.  */
+					char		src[3 + strlen(var) * 2];
+					struct gtp_var	*tsv;
+
+					strcpy(src, "1:");
+					string2hex (var + 1, src + 2);
+					tsv = gtp_var_find_src(src);
+					if (tsv
+					    && tsv->type == gtp_var_special
+					    && !tsv->u.hooks->agent_get_val)
+						continue;
+				}
+
+				ksrc = kmalloc(sizeof(struct gtpsrc),
+					       GFP_KERNEL);
+				if (ksrc == NULL) {
+					ret = -ENOMEM;
+					goto out;
+				}
+				ksrc->next = NULL;
+
+				snprintf(tmp, 30, "gtp %d %p:", (int)tpe->num,
+					 (void *)(CORE_ADDR)tpe->addr);
+				ksrc->src = kmalloc(strlen(tmp)
+						   + strlen(var) + 2,
+						   GFP_KERNEL);
+				if (ksrc->src == NULL) {
+					kfree(ksrc);
+					ret = -ENOMEM;
+					goto out;
+				}
+				sprintf(ksrc->src, "%s%s=", tmp, var);
+
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_qtstart: new "
+						 "printk var %s\n", ksrc->src);
+#endif
+
+				if (tpe->printk_str)
+					srctail->next = ksrc;
+				else
+					tpe->printk_str = ksrc;
+				srctail = ksrc;
+			}
+		}
+	}
+
+#if defined(GTP_FTRACE_RING_BUFFER)			\
+    && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))	\
+    && !defined(GTP_SELF_RING_BUFFER)
+	if (gtp_frame && gtp_circular_is_changed) {
+		ring_buffer_free(gtp_frame);
+		gtp_frame = NULL;
+	}
+	gtp_circular_is_changed = 0;
+#endif
+
+#ifdef GTP_RB
+	if (GTP_RB_PAGE_IS_EMPTY) {
+		if (gtp_rb_page_alloc(GTP_FRAME_SIZE) != 0) {
+			ret = -ENOMEM;
+			goto out;
+		}
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (!gtp_frame) {
+#ifdef GTP_FRAME_SIMPLE
+		gtp_frame = vmalloc(GTP_FRAME_SIZE);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		gtp_frame = ring_buffer_alloc(GTP_FRAME_SIZE,
+					      gtp_circular ? RB_FL_OVERWRITE
+							     : 0);
+#endif
+		if (!gtp_frame) {
+			ret = -ENOMEM;
+			goto out;
+		}
+#endif
+
+		gtp_frame_reset();
+	}
+
+	for_each_online_cpu(cpu) {
+#ifdef CONFIG_X86
+		per_cpu(rdtsc_current, cpu) = 0;
+		per_cpu(rdtsc_offset, cpu) = 0;
+#endif
+		per_cpu(local_clock_current, cpu) = 0;
+		per_cpu(local_clock_offset, cpu) = 0;
+		per_cpu(gtp_handler_began, cpu) = 0;
+	}
+
+	gtp_start = 1;
+
+#ifdef GTP_PERF_EVENTS
+	/* Clear pc_pe_list.  */
+	for_each_online_cpu(cpu) {
+		per_cpu(pc_pe_list, cpu) = NULL;
+		per_cpu(pc_pe_list_all_disabled, cpu) = 1;
+	}
+	list_for_each(cur, &gtp_var_list) {
+		struct gtp_var_perf_event	*pe;
+		var = list_entry(cur, struct gtp_var, node);
+
+		if (var->type != gtp_var_perf_event
+		    && var->type != gtp_var_perf_event_per_cpu)
+			continue;
+		if (var->type == gtp_var_perf_event_per_cpu
+		    && var->u.pc.cpu < 0)
+			continue;
+		pe = gtp_var_get_pe(var)->pe;
+		if (pe->event)
+			continue;
+
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_gdbrsp_qtstart:"
+			         "create perf_event CPU%d %d %d.\n",
+		       (int)pe->cpu, (int)pe->attr.type, (int)pe->attr.config);
+#endif
+		
+		/* Get event.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0)) \
+       || (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,3))
+		pe->event = perf_event_create_kernel_counter(&(pe->attr),
+							     pe->cpu,
+							     NULL, NULL,
+							     NULL);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)) \
+       || (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,1))
+		pe->event =
+			perf_event_create_kernel_counter(&(pe->attr),
+							 pe->cpu,
+							 NULL, NULL);
+#else
+		pe->event =
+			perf_event_create_kernel_counter(&(pe->attr),
+							 pe->cpu,
+							 -1, NULL);
+#endif
+		if (IS_ERR(pe->event)) {
+			int	ret = PTR_ERR(pe->event);
+
+			printk(KERN_WARNING "gtp_gdbrsp_qtstart:"
+			       "create perf_event CPU%d %d %d got error.\n",
+			       (int)pe->cpu, (int)pe->attr.type,
+			       (int)pe->attr.config);
+			pe->event = NULL;
+			gtp_gdbrsp_qtstop();
+			return ret;
+		}
+
+		/* Add event to pc_pe_list.  */
+		if (pe->cpu >= 0) {
+			struct gtp_var_perf_event *ppl = per_cpu(pc_pe_list,
+								 pe->cpu);
+			if (ppl == NULL) {
+				per_cpu(pc_pe_list, pe->cpu) = pe;
+				pe->pc_next = NULL;
+			} else {
+				pe->pc_next = ppl;
+				per_cpu(pc_pe_list,
+					pe->cpu) = pe;
+			}
+			if (pe->en)
+				per_cpu(pc_pe_list_all_disabled, pe->cpu)
+					= 0;
+		}
+	}
+#endif
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	tasklet_init(&gtpframe_pipe_wq_tasklet, gtpframe_pipe_wq_wake_up, 0);
+#endif
+
+	/* Init tracepoint and do last tracepoint check. */
+#ifdef CONFIG_X86
+	if (gtp_have_step && gtp_have_watch_tracepoint) {
+		printk(KERN_WARNING "KGTP: watch tracepoint cannot work together with while-stepping.\n");
+		gtp_gdbrsp_qtstop();
+		return -EINVAL;
+	}
+#endif
+
+	gtp_start_last_errno = 0;
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if ((tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+		    && (tpe->step || tpe->type != gtp_entry_kprobe
+#ifdef CONFIG_X86
+		    || gtp_have_step)) {
+#else
+		    )) {
+#endif
+			printk(KERN_WARNING "KGTP: $kret cannot use with while-stepping or watch.\n");
+			gtp_gdbrsp_qtstop();
+			return -EINVAL;
+		}
+		tpe->reason = gtp_stop_normal;
+		if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PASS)
+			atomic_set(&tpe->current_pass, tpe->pass);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+		tasklet_init(&tpe->enable_tasklet, gtp_wq_add_work,
+			     (unsigned long)&tpe->enable_work);
+		tasklet_init(&tpe->disable_tasklet, gtp_wq_add_work,
+			     (unsigned long)&tpe->disable_work);
+#endif
+	}
+
+#ifdef CONFIG_X86
+	/* Start hwb.  */
+	if (gtp_have_watch_tracepoint) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+		{
+			struct perf_event_attr attr;
+
+			hw_breakpoint_init(&attr);
+			attr.bp_len = HW_BREAKPOINT_LEN_1;
+			attr.bp_type = HW_BREAKPOINT_W;
+
+			/* Register hw breakpoints.  */
+			for (i = 0; i < HWB_NUM; i++) {
+				perf_overflow_handler_t	triggered;
+				attr.bp_addr = i;
+				switch (i) {
+				case 0:
+					triggered = gtp_hw_breakpoint_0_handler;
+					break;
+				case 1:
+					triggered = gtp_hw_breakpoint_1_handler;
+					break;
+				case 2:
+					triggered = gtp_hw_breakpoint_2_handler;
+					break;
+				case 3:
+					triggered = gtp_hw_breakpoint_3_handler;
+					break;
+				}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0))
+				breakinfo[i].pev = register_wide_hw_breakpoint(&attr, triggered, NULL);
+#else
+				breakinfo[i].pev = register_wide_hw_breakpoint(&attr, triggered);
+#endif
+				if (IS_ERR((void * __force)breakinfo[i].pev)) {
+					printk(KERN_WARNING "KGTP: Could not allocate hw breakpoints.\n");
+					breakinfo[i].pev = NULL;
+					gtp_gdbrsp_qtstop();
+					return PTR_ERR((void * __force)breakinfo[i].pev);
+				}
+			}
+
+			/* Make sure breakinfo[i] is which hw breakpoint and set
+			it to breakinfo[i].num.  */
+			for (i = 0; i < HWB_NUM; i++) {
+				unsigned long	num;
+
+				gtp_get_debugreg(num, i);
+				breakinfo[num].num = i;
+			}
+		}
+#endif
+
+		gtp_hwb_stop(NULL);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		smp_call_function(gtp_hwb_stop, NULL, 1);
+#else
+		smp_call_function(gtp_hwb_stop, NULL, 0, 1);
+#endif
+
+		write_lock_irqsave(&gtp_hwb_lock, flags);
+		INIT_LIST_HEAD(&gtp_hwb_used_list);
+		INIT_LIST_HEAD(&gtp_hwb_unused_list);
+		for (i = 0; i < HWB_NUM; i++) {
+			gtp_hwb[i].num = i;
+			gtp_hwb[i].watch = NULL;
+			gtp_hwb_drx[i] = 0;
+			list_add(&(gtp_hwb[i].node), &gtp_hwb_unused_list);
+		}
+		gtp_hwb_dr7 = GTP_HWB_DR7_DEF;
+
+		gtp_hwb_sync_count = 0;
+		for_each_online_cpu(cpu) {
+			per_cpu(gtp_hwb_sync_count_local, cpu) = gtp_hwb_sync_count;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+			cpumask_copy(&(per_cpu(gtp_hwb_sync_cpu_mask, cpu)),
+				     cpu_online_mask);
+			cpumask_clear_cpu(cpu, &(per_cpu(gtp_hwb_sync_cpu_mask, cpu)));
+#endif
+		}
+		write_unlock_irqrestore(&gtp_hwb_lock, flags);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		/* Register kprobe handler for IPI.  */
+		memset (&gtp_ipi_kp, '\0', sizeof(gtp_ipi_kp));
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0))
+		gtp_ipi_kp.symbol_name = "generic_smp_call_function_single_interrupt";
+#else
+		gtp_ipi_kp.symbol_name = "generic_smp_call_function_interrupt";
+#endif
+		gtp_ipi_kp.pre_handler = gtp_ipi_handler;
+		ret = register_kprobe(&gtp_ipi_kp);
+		if (ret) {
+			printk(KERN_WARNING "KGTP: try to register handler on IPI got error.\n");
+			gtp_gdbrsp_qtstop();
+			return ret;
+		}
+#endif
+
+		/* Register static watch.  */
+		for (tpe = gtp_list; tpe; tpe = tpe->next) {
+			struct gtp_hwb_s	arg;
+
+			if (tpe->type == gtp_entry_kprobe || tpe->disable)
+				continue;
+
+			if (tpe->type == gtp_entry_watch_static) {
+				arg.addr = tpe->addr;
+				arg.size = tpe->u.watch.size;
+				arg.type = tpe->u.watch.type;
+				arg.trace_num = tpe->num;
+				arg.trace_addr = tpe->addr;
+				arg.watch = tpe;
+				ret = gtp_register_hwb(&arg, 0);
+				if (ret < 0) {
+					printk(KERN_WARNING "gtp_gdbrsp_qtstart: register watchpoint %d %p got error.\n",
+					(int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+					if (gtp_start_ignore_error) {
+						gtp_start_last_errno = (uint64_t)ret;
+						continue;
+					} else {
+						gtp_gdbrsp_qtstop();
+						return ret;
+					}
+				}
+			}
+
+			tpe->flags |= GTP_ENTRY_FLAGS_REG;
+		}
+	}
+#endif
+
+#ifdef CONFIG_X86
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	if (gtp_have_step || gtp_have_watch_tracepoint) {
+#else
+	if (gtp_have_step) {
+#endif
+		/* Register notifier.  */
+		ret = register_die_notifier(&gtp_notifier);
+		if (ret) {
+			gtp_gdbrsp_qtstop();
+			return ret;
+		}
+	}
+#endif
+
+	/* Register kprobe.  */
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->type != gtp_entry_kprobe)
+			continue;
+
+		tasklet_init(&tpe->u.kp.stop_tasklet, gtp_wq_add_work,
+			     (unsigned long)&tpe->u.kp.stop_work);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+		if (tpe->disable)
+			tpe->u.kp.kpret.kp.flags |= KPROBE_FLAG_DISABLED;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+		if (tpe->addr != 0) {
+#else
+		if (tpe->disable == 0 && tpe->addr != 0) {
+#endif
+			tpe->u.kp.kpret.kp.addr = (kprobe_opcode_t *) (CORE_ADDR)tpe->addr;
+			if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE) {
+				if (gtp_access_cooked_clock
+#ifdef CONFIG_X86
+				    || gtp_access_cooked_rdtsc
+#endif
+#ifdef GTP_PERF_EVENTS
+				    || gtp_have_pc_pe
+#endif
+				)
+					tpe->u.kp.kpret.handler = gtp_kp_ret_handler_plus;
+				else
+					tpe->u.kp.kpret.handler = gtp_kp_ret_handler;
+
+				ret = register_kretprobe(&tpe->u.kp.kpret);
+			} else {
+				if (gtp_access_cooked_clock
+#ifdef CONFIG_X86
+				    || gtp_access_cooked_rdtsc
+#endif
+#ifdef GTP_PERF_EVENTS
+				    || gtp_have_pc_pe
+#endif
+				) {
+#ifdef CONFIG_X86
+					if (tpe->step || gtp_have_step) {
+#else
+					if (tpe->step) {
+#endif
+						tpe->u.kp.kpret.kp.pre_handler = gtp_kp_pre_handler_plus_step;
+						tpe->u.kp.kpret.kp.post_handler = gtp_kp_post_handler_plus;
+					} else
+						tpe->u.kp.kpret.kp.pre_handler = gtp_kp_pre_handler_plus;
+				} else {
+					tpe->u.kp.kpret.kp.pre_handler = gtp_kp_pre_handler;
+#ifdef CONFIG_X86
+					if (tpe->step || gtp_have_step)
+#else
+					if (tpe->step)
+#endif
+						tpe->u.kp.kpret.kp.post_handler = gtp_kp_post_handler;
+				}
+				ret = register_kprobe(&tpe->u.kp.kpret.kp);
+			}
+			if (ret < 0) {
+				printk(KERN_WARNING "gtp_gdbrsp_qtstart: register tracepoint %d %p got error.\n",
+				(int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+				if (gtp_start_ignore_error) {
+					gtp_start_last_errno = (uint64_t)ret;
+					continue;
+				} else {
+					gtp_gdbrsp_qtstop();
+					return ret;
+				}
+			}
+			tpe->flags |= GTP_ENTRY_FLAGS_REG;
+		}
+	}
+	ret = 0;
+out:
+	if (ret != 0) {
+		kfree(gtp_var_array);
+		gtp_var_array = NULL;
+	}
+	return ret;
+}
+
+static int
+gtp_parse_x(struct gtp_entry *tpe, struct action *ae, char **pkgp)
+{
+	ULONGEST	size;
+	int		ret = 0, i, h, l;
+	char		*pkg = *pkgp;
+
+	if (pkg[0] == '\0') {
+		ret = -EINVAL;
+		goto out;
+	}
+	pkg = hex2ulongest(pkg, &size);
+	if (pkg[0] != ',') {
+		ret = -EINVAL;
+		goto out;
+	}
+	ae->u.exp.size = (unsigned int)size;
+	pkg++;
+
+	ae->u.exp.buf = kmalloc(ae->u.exp.size, GFP_KERNEL);
+	if (!ae->u.exp.buf)
+		return -ENOMEM;
+
+	for (i = 0; i < ae->u.exp.size
+		    && hex2int(pkg[0], &h) && hex2int(pkg[1], &l);
+	     i++) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_parse_x: %s %d %d\n", pkg, h, l);
+#endif
+		ae->u.exp.buf[i] = (h << 4) | l;
+		pkg += 2;
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_parse_x: %x\n", ae->u.exp.buf[i]);
+#endif
+	}
+	if (i != ae->u.exp.size) {
+		kfree(ae->u.exp.buf);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ae->u.exp.need_var_lock = 0;
+
+out:
+	*pkgp = pkg;
+	return ret;
+}
+
+static int
+gtp_gdbrsp_qtdp(char *pkg)
+{
+	int			addnew = 1;
+	ULONGEST		num, addr;
+	struct gtp_entry	*tpe;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtdp: %s\n", pkg);
+#endif
+
+	if (gtp_start)
+		return -EBUSY;
+
+	if (pkg[0] == '-') {
+		pkg++;
+		addnew = 0;
+	}
+
+	/* Get num and addr.  */
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &num);
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &addr);
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg++;
+
+	tpe = gtp_list_find(num, addr);
+	if (addnew) {
+		ULONGEST	ulongtmp;
+
+		if (tpe)
+			return -EINVAL;
+
+		tpe = gtp_list_add(num, addr);
+		if (tpe == NULL)
+			return -ENOMEM;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		if (pkg[0] == 'D')
+			tpe->disable = 1;
+		pkg++;
+
+		/* Get step.  */
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg++;
+		pkg = hex2ulongest(pkg, &ulongtmp);
+		if (pkg[0] == '\0')
+			return -EINVAL;
+#ifndef CONFIG_X86
+		if (ulongtmp > 1) {
+			printk(KERN_WARNING "KGTP in this ARCH support one step, X86 support more than one step.\n");
+			return -EINVAL;
+		}
+#endif
+		tpe->step = (int)ulongtmp;
+#ifdef CONFIG_X86
+		if (tpe->step > 1)
+			gtp_have_step = 1;
+#else
+		if (tpe->step > 1)
+			tpe->step = 1;
+#endif
+
+		/* Get pass.  */
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg++;
+		pkg = hex2ulongest(pkg, &tpe->pass);
+		if (tpe->pass != 0)
+			tpe->flags |= GTP_ENTRY_FLAGS_HAVE_PASS;
+	}
+
+	if (tpe) {
+		/* Add action to tpe.  */
+		int	step_action = 0;
+
+		if (pkg[0] == 'S') {
+			if (tpe->step == 0)
+				return -EINVAL;
+			pkg++;
+			step_action = 1;
+		} else if (tpe->step_action_list)
+			step_action = 1;
+		while (pkg[0]) {
+			struct action	*ae = NULL, *atail = NULL;
+			char *pkg_cmd = pkg;
+
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtp_gdbrsp_qtdp: %s\n", pkg);
+#endif
+			switch (pkg[0]) {
+			case ':':
+				pkg++;
+				break;
+			case 'M': {
+					int		is_neg = 0;
+					ULONGEST	ulongtmp;
+
+					ae = gtp_action_alloc(pkg[0]);
+					if (!ae)
+						return -ENOMEM;
+					pkg++;
+					if (pkg[0] == '-') {
+						is_neg = 1;
+						pkg++;
+					}
+					pkg = hex2ulongest(pkg, &ulongtmp);
+					ae->u.m.regnum = (int)ulongtmp;
+					if (is_neg)
+						ae->u.m.regnum
+						  = -ae->u.m.regnum;
+					if (pkg[0] == '\0') {
+						kfree(ae);
+						return -EINVAL;
+					}
+					pkg++;
+					pkg = hex2ulongest(pkg, &ulongtmp);
+					ae->u.m.offset = (CORE_ADDR)ulongtmp;
+					if (pkg[0] == '\0') {
+						kfree(ae);
+						return -EINVAL;
+					}
+					pkg++;
+					pkg = hex2ulongest(pkg, &ulongtmp);
+					ae->u.m.size = (size_t)ulongtmp;
+				}
+				break;
+			case 'R':
+				/* XXX: reg_mask is ignore.  */
+				ae = gtp_action_alloc(pkg[0]);
+				if (!ae)
+					return -ENOMEM;
+				pkg++;
+				pkg = hex2ulongest(pkg,
+						   &ae->u.reg_mask);
+				break;
+			case 'X': {
+					int	ret;
+
+					ae = gtp_action_alloc(pkg[0]);
+					if (!ae)
+						return -ENOMEM;
+					pkg++;
+					ret = gtp_parse_x(tpe, ae, &pkg);
+					if (ret) {
+						kfree(ae);
+						ae = NULL;
+
+						if (ret < 0)
+							return ret;
+					}
+				}
+				break;
+			case '-':
+				pkg++;
+				break;
+			default:
+				/* XXX: Not support.  */
+				return 1;
+			}
+
+			if (ae) {
+				/* Save the cmd.  */
+				if (gtp_src_add (pkg_cmd, pkg, &(tpe->action_cmd))) {
+					kfree(ae);
+					return -ENOMEM;
+				}
+				/* Add ae to tpe.  */
+				if ((ae->type == 'X' || ae->type == 0xff)
+				    && addnew && !tpe->cond) {
+					tpe->cond = ae;
+					tpe->cond->next = NULL;
+				} else if (!step_action && !tpe->action_list) {
+					tpe->action_list = ae;
+					atail = ae;
+				} else if (step_action
+					   && !tpe->step_action_list) {
+					tpe->step_action_list = ae;
+					atail = ae;
+				} else {
+					if (atail == NULL) {
+						if (step_action)
+							atail =
+							  tpe->step_action_list;
+						else
+							atail =
+							  tpe->action_list;
+						for (; atail->next;
+						     atail = atail->next)
+							;
+					}
+					atail->next = ae;
+					atail = ae;
+				}
+			}
+		}
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qtdpsrc(char *pkg)
+{
+	ULONGEST		num, addr;
+	struct gtp_entry	*tpe;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtdpsrc: %s\n", pkg);
+#endif
+
+	if (gtp_start)
+		return -EBUSY;
+
+	/* Get num and addr.  */
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &num);
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &addr);
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg++;
+	tpe = gtp_list_find(num, addr);
+	if (tpe == NULL)
+		return -EINVAL;
+
+	return gtp_src_add(pkg, NULL, &(tpe->src));
+}
+
+static void gtp_plugin_mod_get(void);
+static void gtp_plugin_mod_put(void);
+
+static int
+gtp_gdbrsp_qtdisconnected(char *pkg)
+{
+	ULONGEST setting;
+
+	if (pkg[0] == '\0')
+		return -EINVAL;
+
+	hex2ulongest(pkg, &setting);
+
+	if (gtp_disconnected_tracing != (int)setting) {
+		if (setting)
+			gtp_plugin_mod_get();
+		else
+			gtp_plugin_mod_put();
+
+		gtp_disconnected_tracing = (int)setting;
+	}
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qtbuffer(char *pkg)
+{
+	if (strncmp("circular:", pkg, 9) == 0) {
+		ULONGEST setting;
+
+		pkg += 9;
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		hex2ulongest(pkg, &setting);
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,38)) \
+    || defined(GTP_SELF_RING_BUFFER)
+		gtp_circular = (int)setting;
+		if (gtp_frame)
+			ring_buffer_change_overwrite(gtp_frame, (int)setting);
+#else
+		if (gtp_circular != (int)setting)
+			gtp_circular_is_changed = 1;
+#endif
+#endif
+		gtp_circular = (int)setting;
+
+		return 0;
+	}
+
+	return 1;
+}
+
+static int
+gtp_frame_head_find_num(int num)
+{
+#ifdef GTP_FRAME_SIMPLE
+	int	tfnum = 0;
+	char	*tmp = gtp_frame_r_start;
+
+	do {
+		if (tmp == gtp_frame_end)
+			tmp = gtp_frame;
+
+		if (FID(tmp) == FID_HEAD) {
+			if (tfnum == num) {
+				gtp_frame_current_num = num;
+				gtp_frame_current = tmp;
+				return 0;
+			}
+			tfnum++;
+		}
+
+		tmp = gtp_frame_next(tmp);
+		if (!tmp)
+			break;
+	} while (tmp != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (gtp_frame_current_num >= num)
+		gtp_frame_iter_reset();
+
+	while (1) {
+		int	cpu;
+
+		cpu = gtp_frame_iter_peek_head();
+		if (cpu < 0)
+			break;
+
+		if (num == gtp_frame_current_num)
+			return cpu;
+
+		ring_buffer_read(gtp_frame_iter[cpu], NULL);
+	}
+#endif
+#ifdef GTP_RB
+	if (num < gtp_frame_current_num)
+		gtp_rb_read_reset();
+
+	while (1) {
+		if (gtp_frame_current_num == num)
+			return 0;
+
+		if (gtp_rb_read() != 0)
+			break;
+	}
+#endif
+
+	return -1;
+}
+
+static int
+gtp_frame_head_find_addr(int inside, unsigned long lo,
+			 unsigned long hi)
+{
+#ifdef GTP_FRAME_SIMPLE
+	int	tfnum = gtp_frame_current_num;
+	char	*tmp;
+
+	if (gtp_frame_current)
+		tmp = gtp_frame_current;
+	else
+		tmp = gtp_frame_r_start;
+
+	do {
+		if (tmp == gtp_frame_end)
+			tmp = gtp_frame;
+
+		if (FID(tmp) == FID_HEAD) {
+			if (tfnum != gtp_frame_current_num) {
+				char		*next;
+				struct pt_regs	*regs = NULL;
+
+				for (next = *(char **)(tmp + FID_SIZE); next;
+				     next = *(char **)(next + FID_SIZE)) {
+					if (FID(next) == FID_REG) {
+						regs = (struct pt_regs *)
+						       (next + FID_SIZE
+							+ sizeof(char *));
+						break;
+					}
+				}
+				if (regs
+				    && ((inside
+					 && GTP_REGS_PC(regs) >= lo
+					 && GTP_REGS_PC(regs) <= hi)
+					|| (!inside
+					    && (GTP_REGS_PC(regs) < lo
+						|| GTP_REGS_PC(regs) > hi)))) {
+					gtp_frame_current_num = tfnum;
+					gtp_frame_current = tmp;
+					return 0;
+				}
+			}
+			tfnum++;
+		}
+
+		tmp = gtp_frame_next(tmp);
+		if (!tmp)
+			break;
+	} while (tmp != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	while (1) {
+		int				cpu;
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+		struct pt_regs			*regs = NULL;
+
+		cpu = gtp_frame_iter_peek_head();
+		if (cpu < 0)
+			break;
+
+		while (1) {
+			ring_buffer_read(gtp_frame_iter[cpu], NULL);
+			rbe = ring_buffer_iter_peek(gtp_frame_iter[cpu], NULL);
+			if (rbe == NULL)
+				break;
+
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			if (FID(tmp) == FID_REG) {
+				regs = (struct pt_regs *)(tmp + FID_SIZE);
+				break;
+			}
+		}
+
+		if (regs
+		    && ((inside
+			  && GTP_REGS_PC(regs) >= lo
+			  && GTP_REGS_PC(regs) <= hi)
+			|| (!inside
+			    && (GTP_REGS_PC(regs) < lo
+				|| GTP_REGS_PC(regs) > hi))))
+			return gtp_frame_head_find_num(gtp_frame_current_num);
+	}
+#endif
+#ifdef GTP_RB
+	struct gtp_rb_walk_s	rbws;
+
+	if (gtp_frame_current_num < 0) {
+		if (gtp_rb_read() != 0)
+			return -1;
+	}
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END
+		     | GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_CHECK_TYPE;
+	rbws.type = FID_REG;
+
+	while (1) {
+		char	*tmp;
+
+		rbws.end = gtp_frame_current_rb->w;
+		rbws.id = gtp_frame_current_id;
+		tmp = gtp_rb_walk(&rbws, gtp_frame_current_rb->rp);
+		if (rbws.reason == gtp_rb_walk_type) {
+			struct pt_regs	*regs
+				= (struct pt_regs *)(tmp + FID_SIZE);
+
+			if ((inside && GTP_REGS_PC(regs) >= lo
+			     && GTP_REGS_PC(regs) <= hi)
+			    || (!inside && (GTP_REGS_PC(regs) < lo
+					    || GTP_REGS_PC(regs) > hi))) {
+				return 0;
+			}
+		}
+
+		if (gtp_rb_read() != 0)
+			break;
+	}
+#endif
+
+	return -1;
+}
+
+static int
+gtp_frame_head_find_trace(ULONGEST trace)
+{
+#ifdef GTP_FRAME_SIMPLE
+	int	tfnum = gtp_frame_current_num;
+	char	*tmp;
+
+	if (gtp_frame_current)
+		tmp = gtp_frame_current;
+	else
+		tmp = gtp_frame_r_start;
+
+	do {
+		if (tmp == gtp_frame_end)
+			tmp = gtp_frame;
+
+		if (FID(tmp) == FID_HEAD) {
+			if (tfnum != gtp_frame_current_num) {
+				if (trace == *(ULONGEST *) (tmp + FID_SIZE
+							    + sizeof(char *))) {
+					gtp_frame_current_num = tfnum;
+					gtp_frame_current = tmp;
+					return 0;
+				}
+			}
+			tfnum++;
+		}
+
+		tmp = gtp_frame_next(tmp);
+		if (!tmp)
+			break;
+	} while (tmp != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	while (1) {
+		int				cpu;
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+
+		cpu = gtp_frame_iter_peek_head();
+		if (cpu < 0)
+			break;
+
+		rbe = ring_buffer_iter_peek(gtp_frame_iter[cpu], NULL);
+		if (rbe == NULL) {
+			/* It will not happen, just for safe.  */
+			return -1;
+		}
+		tmp = ring_buffer_event_data(rbe);
+		if (trace == *(ULONGEST *) (tmp + FID_SIZE))
+			return cpu;
+
+		ring_buffer_read(gtp_frame_iter[cpu], NULL);
+	}
+#endif
+#ifdef GTP_RB
+	if (gtp_frame_current_num < 0) {
+		if (gtp_rb_read() != 0)
+			return -1;
+	}
+
+	while (1) {
+		if (gtp_frame_current_tpe == trace)
+			return 0;
+
+		if (gtp_rb_read() != 0)
+			break;
+	}
+#endif
+
+	return -1;
+}
+
+static int
+gtp_gdbrsp_qtframe(char *pkg)
+{
+	int	ret = -1;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	int	old_num = gtp_frame_current_num;
+#endif
+
+	if (gtp_start)
+		return -EBUSY;
+
+	if (gtp_gtpframe_pipe_pid >= 0)
+		return -EBUSY;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtframe: %s\n", pkg);
+#endif
+
+	if (atomic_read(&gtp_frame_create) == 0)
+		goto out;
+
+	if (strncmp(pkg, "pc:", 3) == 0) {
+		ULONGEST	addr;
+
+		pkg += 3;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		hex2ulongest(pkg, &addr);
+
+		ret = gtp_frame_head_find_addr(1, (unsigned long)addr,
+					       (unsigned long)addr);
+	} else if (strncmp(pkg, "tdp:", 4) == 0) {
+		ULONGEST	trace;
+
+		pkg += 4;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		hex2ulongest(pkg, &trace);
+
+		ret = gtp_frame_head_find_trace(trace);
+	} else if (strncmp(pkg, "range:", 6) == 0) {
+		ULONGEST	start, end;
+
+		pkg += 6;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg = hex2ulongest(pkg, &start);
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg++;
+		hex2ulongest(pkg, &end);
+
+		ret = gtp_frame_head_find_addr(1, (unsigned long)start,
+					       (unsigned long)end);
+	} else if (strncmp(pkg, "outside:", 8) == 0) {
+		ULONGEST	start, end;
+
+		pkg += 8;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg = hex2ulongest(pkg, &start);
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg++;
+		hex2ulongest(pkg, &end);
+
+		ret = gtp_frame_head_find_addr(0, (unsigned long)start,
+					       (unsigned long)end);
+	} else {
+		ULONGEST	num;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		hex2ulongest(pkg, &num);
+
+		if (((int) num) < 0) {
+			/* Return to current.  */
+#ifdef GTP_FRAME_SIMPLE
+			gtp_frame_current = NULL;
+			gtp_frame_current_num = -1;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+			gtp_frame_iter_reset();
+#endif
+#ifdef GTP_RB
+			gtp_rb_read_reset();
+#endif
+
+			return 0;
+		}
+		ret = gtp_frame_head_find_num((int) num);
+	}
+
+out:
+	if (ret < 0) {
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+		/* Set frame back to old_num.  */
+		if (old_num < 0)
+#ifdef GTP_FTRACE_RING_BUFFER
+			gtp_frame_iter_reset();
+#endif
+#ifdef GTP_RB
+			gtp_rb_read_reset();
+#endif
+		else
+			gtp_frame_head_find_num(old_num);
+#endif
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "F-1");
+		gtp_rw_bufp += 3;
+		gtp_rw_size += 3;
+	} else {
+#ifdef GTP_FRAME_SIMPLE
+		gtp_frame_current_tpe = *(ULONGEST *)(gtp_frame_current
+						      + FID_SIZE
+						      + sizeof(char *));
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+
+		rbe = ring_buffer_read(gtp_frame_iter[ret],
+				       &gtp_frame_current_clock);
+		if (rbe == NULL) {
+			/* It will not happen, just for safe.  */
+			ret = -1;
+			goto out;
+		}
+		gtp_frame_current_cpu = ret;
+		tmp = ring_buffer_event_data(rbe);
+		gtp_frame_current_tpe = *(ULONGEST *)(tmp + FID_SIZE);
+#endif
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "F%xT%x",
+			 gtp_frame_current_num,
+			 (unsigned int) gtp_frame_current_tpe);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+	}
+	return 1;
+}
+
+static int
+gtp_gdbrsp_qtro(char *pkg)
+{
+	ULONGEST	start, end;
+
+	gtpro_list_clear();
+
+	while (pkg[0]) {
+		pkg = hex2ulongest(pkg, &start);
+		if (pkg[0] != ',')
+			return -EINVAL;
+		pkg++;
+		pkg = hex2ulongest(pkg, &end);
+		if (pkg[0])
+			pkg++;
+
+		if (gtpro_list_add((CORE_ADDR)start, (CORE_ADDR)end) == NULL)
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qtdv(char *pkg)
+{
+	int				ret = -EINVAL;
+	ULONGEST			num, val;
+	struct gtp_var			*var = NULL;
+	char				*src;
+	int				src_size;
+	int				per_cpu_alloced = 0;
+#ifdef GTP_PERF_EVENTS
+	int				pe_alloced = 0;
+#endif
+
+	pkg = hex2ulongest(pkg, &num);
+	if (pkg[0] != ':')
+		goto error_out;
+	pkg++;
+	pkg = hex2ulongest(pkg, &val);
+	if (pkg[0] != ':')
+		goto error_out;
+
+	var = gtp_var_find_num(num);
+	if (var) {
+		if (var->type == gtp_var_special) {
+			if (var->u.hooks && var->u.hooks->gdb_set_val) {
+				ret = var->u.hooks->gdb_set_val(NULL,
+								var, val);
+				if (ret != 0)
+					goto error_out;
+			}
+			return 0;
+		} else
+			goto error_out;
+	}
+
+	pkg ++;
+	src = pkg;
+	src_size = strlen(src);
+
+	/* Remove "0:" for following code.  */
+	if (strlen(pkg) <= 2)
+		goto error_out;
+	pkg += 2;
+
+	/* Check if this is a "p_" or "per_cpu_" trace state variable.  */
+	if (strncasecmp(pkg, "705f", 4) == 0
+	    || strncasecmp(pkg, "7065725f6370755f", 16) == 0) {
+		int				name_size;
+		char				*id_s;
+		int				mul = 1;
+		struct list_head		*cur;
+		struct gtp_var			*cvar;
+		int				per_cpu_id = -1;
+
+		if (strncasecmp(pkg, "705f", 4) == 0)
+			pkg += 4;
+		else
+			pkg += 16;
+		name_size = strlen(pkg);
+
+		/* Get the cpu id of this variable.  */
+		if (name_size % 2 != 0)
+			goto error_out;
+		for (id_s = pkg + name_size - 2; id_s > pkg; id_s -= 2) {
+			int	i, j;
+
+			if (!hex2int(id_s[0], &i))
+				goto error_out;
+			if (!hex2int(id_s[1], &j))
+				goto error_out;
+			j |= (i << 4);
+			if (j < 0x30 || j > 0x39)
+				break;
+			j -= 0x30;
+			if (per_cpu_id < 0)
+				per_cpu_id = 0;
+			per_cpu_id += mul * j;
+			mul *= 10;
+			/* src_size will not include the cpu id.  */
+			src_size -= 2;
+		}
+		if (per_cpu_id >= gtp_cpu_number) {
+			printk(KERN_WARNING "gtp_gdbrsp_qtdv: id %d is bigger "
+					    "than cpu number %d.\n",
+			       per_cpu_id, gtp_cpu_number);
+			goto error_out;
+		}
+
+		var = gtp_var_alloc(per_cpu_id, (unsigned int)num, 0,
+				    (int64_t)val, src);
+		if (IS_ERR(var)) {
+			ret = PTR_ERR(var);
+			var = NULL;
+			goto error_out;
+		}
+
+		/* Setup var.  */
+		var->type = gtp_var_per_cpu;
+		var->u.pc.cpu = per_cpu_id;
+		/* Find the per cpu struct.  */
+		list_for_each(cur, &gtp_var_list) {
+			cvar = list_entry(cur, struct gtp_var, node);
+#ifdef GTP_PERF_EVENTS
+			if (cvar->type != gtp_var_per_cpu
+			    && cvar->type != gtp_var_perf_event_per_cpu)
+#else
+			if (cvar->type != gtp_var_per_cpu)
+#endif
+				continue;
+
+			if (strncmp (cvar->src, src, src_size) == 0) {
+				int	csize;
+
+				/* Following part code to make sure
+				   cvar->src without ID is same with
+				   var->src without id.  */
+				csize = strlen(cvar->src);
+				if (csize % 2 != 0) {
+					printk(KERN_WARNING "Src %s of TSR %u is not right.\n",
+					       cvar->src, cvar->num);
+					continue;
+				}
+				for (csize -= 2; csize >= src_size; csize -= 2) {
+					int	i, j;
+
+					if (!hex2int(cvar->src[csize], &i))
+						break;
+					if (!hex2int(cvar->src[csize + 1], &j))
+						break;
+					j |= (i << 4);
+					if (j < 0x30 || j > 0x39)
+						break;
+				}
+				if (csize >= src_size)
+					continue;
+
+				var->u.pc.pc = cvar->u.pc.pc;
+				break;
+			}
+		}
+		if (var->u.pc.pc == NULL) {
+			int	cpu;
+
+			var->u.pc.pc = alloc_percpu(struct gtp_var_per_cpu);
+			if (var->u.pc.pc == NULL) {
+				ret = -ENOMEM;
+				goto error_out;
+			}
+			for_each_online_cpu(cpu)
+				memset(per_cpu_ptr(var->u.pc.pc, cpu), '\0',
+				       sizeof(struct gtp_var_per_cpu));
+
+			per_cpu_alloced = 1;
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtp_gdbrsp_qtdv: Create a "
+					 "new per_cpu list for %s and set var "
+					 "to cpu %d.\n",
+			       src, var->u.pc.cpu);
+#endif
+		} else {
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtp_gdbrsp_qtdv: Find a "
+					 "per_cpu list for %s and set var "
+					 "to cpu %d.\n",
+			       src, var->u.pc.cpu);
+#endif
+		}
+		if (var->u.pc.cpu >= 0)
+			gtp_var_get_pc(var)->u.val = val;
+	} else {
+		var = gtp_var_alloc(-1, (unsigned int)num, 0, (int64_t)val,
+				    src);
+		if (IS_ERR(var)) {
+			ret = PTR_ERR(var);
+			var = NULL;
+			goto error_out;
+		}
+		/* Setup var.  */
+		var->type = gtp_var_normal;
+		var->u.val = val;
+	}
+
+	/* Check if this is a "pe_" OR "perf_event_" trace state variable.  */
+	if (strncasecmp(pkg, "70655f", 6) == 0
+	    || strncasecmp(pkg, "706572665f6576656e745f", 22) == 0) {
+#ifdef GTP_PERF_EVENTS
+		enum pe_tv_id		ptid;
+		struct list_head	*cur;
+		struct gtp_var_pe	*cpe = NULL, *pe;
+
+		if (strncasecmp(pkg, "70655f", 6) == 0)
+			pkg += 6;
+		else
+			pkg += 22;
+
+		if (strncasecmp(pkg, "6370755f", 8) == 0) {
+			/* "cpu_" */
+			pkg += 8;
+			ptid = pe_tv_cpu;
+		} else if (strncasecmp(pkg, "747970655f", 10) == 0) {
+			/* "type_" */
+			pkg += 10;
+			ptid = pe_tv_type;
+		} else if (strncasecmp(pkg, "636f6e6669675f", 14) == 0) {
+			/* "config_" */
+			pkg += 14;
+			ptid = pe_tv_config;
+		} else if (strncasecmp(pkg, "656e5f", 6) == 0) {
+			/* "en_" */
+			pkg += 6;
+			ptid = pe_tv_en;
+		} else if (strncasecmp(pkg, "76616c5f", 8) == 0) {
+			/* "val_" */
+			pkg += 8;
+			ptid = pe_tv_val;
+		} else if (strncasecmp(pkg, "656e61626c65645f", 16) == 0) {
+			/* "enabled_" */
+			pkg += 16;
+			ptid = pe_tv_enabled;
+		} else if (strncasecmp(pkg, "72756e6e696e675f", 16) == 0) {
+			/* "running_" */
+			pkg += 16;
+			ptid = pe_tv_running;
+		} else
+			goto error_out;
+
+		if (strlen(pkg) <= 0)
+			goto error_out;
+
+		if (var->type == gtp_var_per_cpu) {
+			var->type = gtp_var_perf_event_per_cpu;
+			if (var->u.pc.cpu < 0)
+				goto out;
+		}
+		else
+			var->type = gtp_var_perf_event;
+
+		/* Find the pe_tv that name is pkg.  */
+		list_for_each(cur, &gtp_var_list) {
+			struct gtp_var	*cvar = list_entry(cur,
+							   struct gtp_var,
+							   node);
+			if (var->type == cvar->type
+			    && !(cvar->type == gtp_var_perf_event_per_cpu
+				 && cvar->u.pc.cpu < 0)) {
+				cpe = gtp_var_get_pe(cvar);
+				if (strcmp(cpe->pe->name, pkg) == 0)
+					break;
+			}
+		}
+
+		pe = gtp_var_get_pe(var);
+		pe->ptid = ptid;
+
+		if (cur == &gtp_var_list) {
+			if (var->type == gtp_var_perf_event_per_cpu)
+				pe->pe = kzalloc(sizeof(struct gtp_var_perf_event),
+						 GFP_KERNEL);
+			else
+				pe->pe = kmalloc_node(sizeof(struct gtp_var_perf_event),
+						      GFP_KERNEL | __GFP_ZERO,
+						      cpu_to_node(var->u.pc.cpu));
+			if (pe->pe == NULL) {
+				ret = -ENOMEM;
+				goto error_out;
+			}
+
+			/* Init the value in pe to default value.  */
+			pe_alloced = 1;
+			pe->pe->name = gtp_strdup(pkg, NULL);
+			if (pe->pe->name == NULL) {
+				ret = -ENOMEM;
+				goto error_out;
+			}
+			pe->pe->en = 0;
+			pe->pe->attr.type = PERF_TYPE_HARDWARE;
+			pe->pe->attr.config = PERF_COUNT_HW_CPU_CYCLES;
+			pe->pe->attr.disabled = 1;
+			pe->pe->attr.pinned = 1;
+			pe->pe->attr.size = sizeof(struct perf_event_attr);
+			if (var->type == gtp_var_perf_event_per_cpu)
+				pe->pe->cpu = var->u.pc.cpu;
+		} else
+			pe->pe = cpe->pe;
+
+		/* Set current val to pe.  */
+		switch (ptid) {
+		case pe_tv_cpu:
+			pe->pe->cpu = (int)(LONGEST)val;
+			break;
+		case pe_tv_type:
+			pe->pe->attr.type = val;
+			break;
+		case pe_tv_config:
+			pe->pe->attr.config = val;
+			break;
+		case pe_tv_en:
+			if (val) {
+				pe->pe->attr.disabled = 0;
+				pe->pe->en = 1;
+			} else {
+				pe->pe->attr.disabled = 1;
+				pe->pe->en = 0;
+			}
+			break;
+		case pe_tv_val:
+		case pe_tv_enabled:
+		case pe_tv_running:
+			break;
+		default:
+			goto error_out;
+			break;
+		}
+
+		gtp_have_pc_pe = 1;
+#else
+		printk(KERN_WARNING "Current Kernel doesn't open "
+				    "GTP_PERF_EVENTS\n");
+		ret = -ENXIO;
+		goto error_out;
+#endif
+	}
+#ifdef GTP_PERF_EVENTS
+out:
+#endif
+	list_add(&var->node, &gtp_var_list);
+	gtp_var_num++;
+
+	return 0;
+
+error_out:
+#ifdef GTP_PERF_EVENTS
+	if (pe_alloced)
+		kfree(gtp_var_get_pe(var)->pe);
+#endif
+	if (per_cpu_alloced)
+		free_percpu(var->u.pc.pc);
+
+	if (var) {
+		kfree(var->src);
+		kfree(var);
+	}
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+static int
+gtp_gdbrsp_qtenable_qtdisable(char *pkg, int enable)
+{
+	ULONGEST		num, addr;
+	struct gtp_entry	*tpe;
+	int			ret = -ESRCH;
+
+	pkg = hex2ulongest(pkg, &num);
+	if (pkg[0] != ':')
+		return -EINVAL;
+	pkg++;
+	hex2ulongest(pkg, &addr);
+
+	tpe = gtp_list_find(num, addr);
+	if (tpe == NULL)
+		return -EINVAL;
+	if (tpe->type != gtp_entry_kprobe) {
+		printk(KERN_WARNING "gtp_write: this tracepoint doesn't support enable and disable.\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&gtp_handler_enable_disable_loc);
+
+	if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE) {
+		if (enable)
+			ret = enable_kretprobe(&(tpe->u.kp.kpret));
+		else
+			ret = disable_kretprobe(&(tpe->u.kp.kpret));
+	} else {
+		if (enable)
+			ret = enable_kprobe(&(tpe->u.kp.kpret.kp));
+		else
+			ret = disable_kprobe(&(tpe->u.kp.kpret.kp));
+	}
+
+	if (ret != 0)
+		tpe->disable = enable ? 0 : 1;
+
+	spin_unlock(&gtp_handler_enable_disable_loc);
+	return ret;
+}
+#endif
+
+static int
+gtp_gdbrsp_QT(char *pkg)
+{
+	int	ret = 1;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_QT: %s\n", pkg);
+#endif
+
+	if (strcmp("init", pkg) == 0)
+		ret = gtp_gdbrsp_qtinit();
+	else if (strcmp("Stop", pkg) == 0)
+		ret = gtp_gdbrsp_qtstop();
+	else if (strcmp("Start", pkg) == 0)
+		ret = gtp_gdbrsp_qtstart();
+	else if (strncmp("DP:", pkg, 3) == 0)
+		ret = gtp_gdbrsp_qtdp(pkg + 3);
+	else if (strncmp("DPsrc:", pkg, 6) == 0)
+		ret = gtp_gdbrsp_qtdpsrc(pkg + 6);
+	else if (strncmp("Disconnected:", pkg, 13) == 0)
+		ret = gtp_gdbrsp_qtdisconnected(pkg + 13);
+	else if (strncmp("Buffer:", pkg, 7) == 0)
+		ret = gtp_gdbrsp_qtbuffer(pkg + 7);
+	else if (strncmp("Frame:", pkg, 6) == 0)
+		ret = gtp_gdbrsp_qtframe(pkg + 6);
+	else if (strncmp("ro:", pkg, 3) == 0)
+		ret = gtp_gdbrsp_qtro(pkg + 3);
+	else if (strncmp("DV:", pkg, 3) == 0)
+		ret = gtp_gdbrsp_qtdv(pkg + 3);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	else if (strncmp("Enable:", pkg, 7) == 0)
+		ret = gtp_gdbrsp_qtenable_qtdisable(pkg + 7, 1);
+	else if (strncmp("Disable:", pkg, 8) == 0)
+		ret = gtp_gdbrsp_qtenable_qtdisable(pkg + 8, 0);
+#endif
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_QT: return %d\n", ret);
+#endif
+
+	return ret;
+}
+
+static int
+gtp_get_status(struct gtp_entry *tpe, char *buf, int bufmax)
+{
+	int			size = 0;
+	int			tfnum = 0;
+	CORE_ADDR		tmpaddr;
+
+#ifdef GTP_RB
+	if (GTP_RB_PAGE_IS_EMPTY) {
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (!gtp_frame) {
+#endif
+		snprintf(buf, bufmax, "tnotrun:0;");
+		buf += 10;
+		size += 10;
+		bufmax -= 10;
+	} else if (!tpe || (tpe && tpe->reason == gtp_stop_normal)) {
+		snprintf(buf, bufmax, "tstop:0;");
+		buf += 8;
+		size += 8;
+		bufmax -= 8;
+	} else {
+		char	outtmp[100];
+
+		switch (tpe->reason) {
+		case gtp_stop_frame_full:
+			snprintf(buf, bufmax, "tfull:%lx;",
+				 (unsigned long)tpe->num);
+			break;
+		case gtp_stop_efault:
+			snprintf(buf, bufmax, "terror:%s:%lx;",
+				 string2hex("read memory false", outtmp),
+				 (unsigned long)tpe->num);
+			break;
+		case gtp_stop_access_wrong_reg:
+			snprintf(buf, bufmax, "terror:%s:%lx;",
+				 string2hex("access wrong register", outtmp),
+				 (unsigned long)tpe->num);
+			break;
+		case gtp_stop_agent_expr_code_error:
+			snprintf(buf, bufmax, "terror:%s:%lx;",
+				 string2hex("agent expression code error",
+					    outtmp),
+				 (unsigned long)tpe->num);
+			break;
+		case gtp_stop_agent_expr_stack_overflow:
+			snprintf(buf, bufmax, "terror:%s:%lx;",
+				string2hex("agent expression stack overflow",
+					   outtmp),
+				(unsigned long)tpe->num);
+			break;
+		default:
+			buf[0] = '\0';
+			break;
+		}
+
+		size += strlen(buf);
+		bufmax -= strlen(buf);
+		buf += strlen(buf);
+	}
+
+	if (atomic_read(&gtp_frame_create)) {
+#ifdef GTP_FRAME_SIMPLE
+		char	*tmp = gtp_frame_r_start;
+
+		do {
+			if (tmp == gtp_frame_end)
+				tmp = gtp_frame;
+
+			if (FID(tmp) == FID_HEAD)
+				tfnum++;
+
+			tmp = gtp_frame_next(tmp);
+			if (!tmp)
+				break;
+		} while (tmp != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		if (gtp_start) {
+			/* XXX: It is just the number of entries.  */
+			tfnum = (int)ring_buffer_entries(gtp_frame);
+		} else {
+			int	old_num = gtp_frame_current_num;
+			int	cpu;
+
+			gtp_frame_iter_reset();
+
+			for_each_online_cpu(cpu) {
+				char				*tmp;
+				struct ring_buffer_event	*rbe;
+
+				while (1) {
+					rbe = ring_buffer_read
+						(gtp_frame_iter[cpu], NULL);
+					if (rbe == NULL)
+						break;
+					tmp = ring_buffer_event_data(rbe);
+					if (FID(tmp) == FID_HEAD)
+						tfnum++;
+				}
+			}
+
+			if (old_num == -1)
+				gtp_frame_iter_reset();
+			else if (old_num >= 0) {
+				gtp_frame_head_find_num(old_num);
+				ring_buffer_read
+					(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+			}
+		}
+#endif
+#ifdef GTP_RB
+		int			cpu;
+		struct gtp_rb_walk_s	rbws;
+
+		rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END;
+
+		for_each_online_cpu(cpu) {
+			struct gtp_rb_s	*rb
+				= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+			void		*tmp;
+			unsigned long	flags;
+
+			GTP_RB_LOCK_IRQ(rb, flags);
+			rbws.end = rb->w;
+			tmp = rb->r;
+			while (1) {
+				tmp = gtp_rb_walk(&rbws, tmp);
+				if (rbws.reason != gtp_rb_walk_new_entry)
+					break;
+				tfnum++;
+				tmp += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+			}
+			GTP_RB_UNLOCK_IRQ(rb, flags);
+		}
+#endif
+	}
+
+	snprintf(buf, bufmax, "tframes:%x;", tfnum);
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+	snprintf(buf, bufmax, "tcreated:%x;", atomic_read(&gtp_frame_create));
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+#ifdef GTP_FRAME_SIMPLE
+	snprintf(buf, bufmax, "tsize:%x;", GTP_FRAME_SIZE);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (gtp_frame)
+		snprintf(buf, bufmax, "tsize:%lx;",
+			 ring_buffer_size(gtp_frame));
+	else
+		snprintf(buf, bufmax, "tsize:%x;",
+			 GTP_FRAME_SIZE * num_online_cpus());
+#endif
+#ifdef GTP_RB
+	snprintf(buf, bufmax, "tsize:%lx;",
+		 gtp_rb_page_count * GTP_RB_DATA_MAX * num_online_cpus());
+#endif
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+#ifdef GTP_FRAME_SIMPLE
+	spin_lock(&gtp_frame_lock);
+	if (gtp_frame_is_circular)
+		tmpaddr = 0;
+	else
+		tmpaddr = GTP_FRAME_SIZE - (gtp_frame_w_start - gtp_frame);
+	spin_unlock(&gtp_frame_lock);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	/* XXX: Ftrace ring buffer don't have interface to get the size of free
+	   buffer. */
+	tmpaddr = 0;
+#endif
+#ifdef GTP_RB
+	if (atomic_read(&gtp_frame_create)) {
+		int			cpu;
+
+		tmpaddr = 0;
+		for_each_online_cpu(cpu) {
+			struct gtp_rb_s	*rb
+				= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+			void		*tmp;
+			unsigned long	flags;
+
+			GTP_RB_LOCK_IRQ(rb, flags);
+			tmpaddr += GTP_RB_END(rb->w) - rb->w;
+			for (tmp = GTP_RB_NEXT(rb->w);
+			     GTP_RB_HEAD(tmp) != GTP_RB_HEAD(rb->r);
+			     tmp = GTP_RB_NEXT(tmp))
+				tmpaddr += GTP_RB_DATA_MAX;
+			tmpaddr += rb->r - GTP_RB_DATA(rb->r);
+			GTP_RB_UNLOCK_IRQ(rb, flags);
+		}
+	} else {
+		tmpaddr = gtp_rb_page_count * GTP_RB_DATA_MAX
+			  * num_online_cpus();
+	}
+#endif
+	snprintf(buf, bufmax, "tfree:%lx;", (unsigned long)tmpaddr);
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+	snprintf(buf, bufmax, "circular:%x;", gtp_circular);
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+	snprintf(buf, bufmax, "disconn:%x", gtp_disconnected_tracing);
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+	return size;
+}
+
+static int
+gtp_gdbrsp_qtstatus(void)
+{
+	struct gtp_entry	*tpe;
+	int			tmp;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->reason != gtp_stop_normal)
+			break;
+	}
+
+	if (gtp_start && tpe)	/* Tpe is stop, stop all tpes.  */
+		gtp_gdbrsp_qtstop();
+
+	snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "T%x;", gtp_start ? 1 : 0);
+	gtp_rw_bufp += 3;
+	gtp_rw_size += 3;
+
+	tmp = gtp_get_status(tpe, gtp_rw_bufp, GTP_RW_BUFP_MAX);
+	gtp_rw_bufp += tmp;
+	gtp_rw_size += tmp;
+
+	return 1;
+}
+
+#define GTP_REPORT_TRACEPOINT_MAX	(1 + 16 + 1 + 16 + 1 + 1 + 1 + \
+					 20 + 1 + 16 + 1)
+
+static void
+gtp_report_tracepoint(struct gtp_entry *gtp, char *buf, int bufmax)
+{
+	snprintf(buf, bufmax, "T%lx:%lx:%c:%d:%lx", (unsigned long)gtp->num,
+		 (unsigned long)gtp->addr, (gtp->disable ? 'D' : 'E'),
+		 gtp->step, (unsigned long)gtp->pass);
+}
+
+static int
+gtp_report_action_max(struct gtp_entry *gtp, struct gtpsrc *action)
+{
+	return 1 + 16 + 1 + 16 + 1 + strlen(action->src) + 1;
+}
+
+static void
+gtp_report_action(struct gtp_entry *gtp, struct gtpsrc *action, char *buf,
+		  int bufmax)
+{
+	snprintf(buf, bufmax, "A%lx:%lx:%s", (unsigned long)gtp->num,
+		 (unsigned long)gtp->addr, action->src);
+}
+
+static int
+gtp_report_src_max(struct gtp_entry *gtp, struct gtpsrc *src)
+{
+	return 1 + 16 + 1 + 16 + 1 + strlen(src->src) + 1;
+}
+
+static void
+gtp_report_src(struct gtp_entry *gtp, struct gtpsrc *src, char *buf, int bufmax)
+{
+	snprintf(buf, bufmax, "Z%lx:%lx:%s", (unsigned long)gtp->num,
+		 (unsigned long)gtp->addr, src->src);
+}
+
+static void
+gtp_current_set_check(void)
+{
+	if (current_gtp_src == NULL)
+		current_gtp = current_gtp->next;
+}
+
+static void
+gtp_current_action_check(void)
+{
+	if (current_gtp_action_cmd == NULL) {
+		current_gtp_src = current_gtp->src;
+		gtp_current_set_check();
+	}
+}
+
+static int
+gtp_gdbrsp_qtfp(void)
+{
+	if (gtp_list) {
+		current_gtp = gtp_list;
+		gtp_report_tracepoint(current_gtp, gtp_rw_bufp,
+				      GTP_RW_BUFP_MAX);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+		current_gtp_action_cmd = current_gtp->action_cmd;
+		gtp_current_action_check();
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'l';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+
+	return 1;
+}
+
+static int
+gtp_gdbrsp_qtsp(void)
+{
+	if (current_gtp_action_cmd) {
+		gtp_report_action(current_gtp, current_gtp_action_cmd,
+				  gtp_rw_bufp, GTP_RW_BUFP_MAX);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+		current_gtp_action_cmd = current_gtp_action_cmd->next;
+		gtp_current_action_check();
+		goto out;
+	}
+
+	if (current_gtp_src) {
+		gtp_report_src(current_gtp, current_gtp_src, gtp_rw_bufp,
+			       GTP_RW_BUFP_MAX);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+		current_gtp_src = current_gtp_src->next;
+		gtp_current_set_check();
+		goto out;
+	}
+
+	if (current_gtp) {
+		gtp_report_tracepoint(current_gtp, gtp_rw_bufp,
+				      GTP_RW_BUFP_MAX);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+		current_gtp_action_cmd = current_gtp->action_cmd;
+		gtp_current_action_check();
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'l';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+out:
+	return 1;
+}
+
+static int
+gtp_gdbrsp_qtfsv(int f)
+{
+	if (f) {
+		if (list_empty(&gtp_var_list))
+			current_gtp_var = NULL;
+		else
+			current_gtp_var = list_first_entry(&gtp_var_list,
+							   struct gtp_var,
+							   node);
+	}
+
+	if (current_gtp_var) {
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "%x:%llx:%s",
+			 current_gtp_var->num,
+			 (unsigned long long)current_gtp_var->initial_val,
+			 current_gtp_var->src);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+
+		if (current_gtp_var->node.next != &gtp_var_list)
+			current_gtp_var = list_first_entry(&(current_gtp_var->node),
+							   struct gtp_var,
+							   node);
+		else
+			current_gtp_var = NULL;
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'l';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+
+	return 1;
+}
+
+#ifdef GTP_RB
+static int
+gtp_rb_traceframe_get_tv(void *buf, u64 id, unsigned int num, uint64_t *val)
+{
+	struct gtp_rb_walk_s	rbws;
+	char			*tmp;
+
+	/* Handle $cpu_id.  */
+	if (num == GTP_VAR_CPU_ID) {
+		*val = gtp_frame_current_rb->cpu;
+		return 0;
+	}
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END
+		     | GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_CHECK_TYPE;
+	rbws.end = gtp_frame_current_rb->w;
+	rbws.id = id;
+	rbws.type = FID_VAR;
+	tmp = buf;
+
+	while (1) {
+		struct gtp_frame_var	*vr;
+
+		tmp = gtp_rb_walk(&rbws, tmp);
+		if (rbws.reason != gtp_rb_walk_type)
+			break;
+
+		vr = (struct gtp_frame_var *)(tmp + FID_SIZE);
+		if (vr->num == num) {
+			*val = vr->val;
+			return 0;
+		}
+
+		tmp += FRAME_ALIGN(GTP_FRAME_VAR_SIZE);
+	}
+
+	return -1;
+}
+#endif
+
+static int
+gtp_gdbrsp_qtv(char *pkg)
+{
+	ULONGEST		num;
+	struct gtp_var		*var = NULL;
+	struct gtp_frame_var	*vr = NULL;
+	uint64_t		val = 0;
+	int			ret;
+
+	pkg = hex2ulongest(pkg, &num);
+
+#ifdef GTP_FRAME_SIMPLE
+	if (gtp_start || !gtp_frame_current) {
+#elif defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gtp_start || gtp_frame_current_num < 0) {
+#endif
+		var = gtp_var_find_num(num);
+		if (var == NULL)
+			goto out;
+
+		switch (var->type) {
+		case gtp_var_special:
+			if (var->u.hooks && var->u.hooks->gdb_get_val) {
+				ret = var->u.hooks->gdb_get_val(NULL,
+								var, &val);
+				if (ret)
+					return ret;
+			} else
+				var = NULL;
+			break;
+#ifdef GTP_PERF_EVENTS
+		case gtp_var_perf_event:
+		case gtp_var_perf_event_per_cpu: {
+			struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+			if (pe->ptid == pe_tv_val
+			    || pe->ptid == pe_tv_enabled
+			    || pe->ptid == pe_tv_running) {
+				if (gtp_start)
+					pe->pe->val = perf_event_read_value(pe->pe->event,
+									    &(pe->pe->enabled),
+									    &(pe->pe->running));
+			}
+			switch (pe->ptid) {
+			case pe_tv_val:
+				val = (uint64_t)(pe->pe->val);
+				break;
+			case pe_tv_enabled:
+				val = (uint64_t)(pe->pe->enabled);
+				break;
+			case pe_tv_running:
+				val = (uint64_t)(pe->pe->running);
+				break;
+			default:
+				break;
+			}
+		}
+			break;
+#endif
+		case gtp_var_per_cpu:
+			val = gtp_var_get_pc(var)->u.val;
+			break;
+		default:
+			val = var->u.val;
+			break;
+		}
+	} else {
+#ifdef GTP_FRAME_SIMPLE
+		char	*next;
+
+		for (next = *(char **)(gtp_frame_current + FID_SIZE); next;
+		     next = *(char **)(next + FID_SIZE)) {
+			if (FID(next) == FID_VAR) {
+				vr = (struct gtp_frame_var *)
+				     (next + FID_SIZE + sizeof(char *));
+				if (vr->num == (unsigned int)num)
+					goto while_stop;
+			}
+		}
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		int				is_first = 1;
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+
+		/* Handle $cpu_id and $clock.  */
+		if (num == GTP_VAR_CLOCK_ID) {
+			val = gtp_frame_current_clock;
+			goto output_value;
+		}
+		else if (num == GTP_VAR_CPU_ID) {
+			val = gtp_frame_current_cpu;
+			goto output_value;
+		}
+re_find:
+		while (1) {
+			rbe = ring_buffer_iter_peek
+				(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+			if (rbe == NULL)
+				break;
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			if (FID(tmp) == FID_VAR) {
+				vr = (struct gtp_frame_var *)(tmp + FID_SIZE);
+				if (vr->num == (unsigned int)num)
+					goto while_stop;
+			}
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+		}
+		if (is_first) {
+			gtp_frame_head_find_num(gtp_frame_current_num);
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+			is_first = 0;
+			goto re_find;
+		}
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+		vr = NULL;
+while_stop:
+		if (vr)
+			val = vr->val;
+	}
+#endif
+#ifdef GTP_RB
+		if (gtp_rb_traceframe_get_tv(gtp_frame_current_rb->rp,
+					     gtp_frame_current_id,
+					     (unsigned int)num, &val) == 0)
+			goto output_value;
+	}
+#endif
+
+out:
+	if (var || vr) {
+output_value:
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "V%08x%08x",
+			 (unsigned int) (val >> 32),
+			 (unsigned int) (val & 0xffffffff));
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'U';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+
+	return 1;
+}
+
+static int
+gtp_gdbrsp_qT(char *pkg)
+{
+	int	ret = 1;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qT: %s\n", pkg);
+#endif
+
+	if (strcmp("Status", pkg) == 0)
+		ret = gtp_gdbrsp_qtstatus();
+	else if (strcmp("fP", pkg) == 0)
+		ret = gtp_gdbrsp_qtfp();
+	else if (strcmp("sP", pkg) == 0)
+		ret = gtp_gdbrsp_qtsp();
+	else if (strcmp("fV", pkg) == 0)
+		ret = gtp_gdbrsp_qtfsv(1);
+	else if (strcmp("sV", pkg) == 0)
+		ret = gtp_gdbrsp_qtfsv(0);
+	else if (strncmp("V:", pkg, 2) == 0)
+		ret = gtp_gdbrsp_qtv(pkg + 2);
+
+	return ret;
+}
+
+#ifdef GTP_RB
+static char		*gtp_traceframe_info;
+static unsigned int	gtp_traceframe_info_len;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+/* The 2.6.30 and older version have __module_address.  */
+
+static int		gtp_modules_traceframe_info_need_get;
+static char		*gtp_modules_traceframe_info;
+static unsigned int	gtp_modules_traceframe_info_len;
+
+static int
+gtp_modules_traceframe_info_get(void)
+{
+	struct module		*mod;
+	struct gtp_realloc_s	grs;
+	int			ret = 0;
+
+	gtp_realloc_alloc(&grs, 0);
+
+	if (gtp_modules_traceframe_info_len > 0) {
+		vfree(gtp_modules_traceframe_info);
+		gtp_modules_traceframe_info = NULL;
+		gtp_modules_traceframe_info_len = 0;
+	}
+
+	mutex_lock(&module_mutex);
+	list_for_each_entry_rcu(mod, &(THIS_MODULE->list), list) {
+		if (__module_address((unsigned long)mod)) {
+			char	buf[70];
+
+			snprintf(buf, 70,
+				 "<memory start=\"0x%lx\" length=\"0x%lx\"/>\n",
+				 (unsigned long)mod->module_core,
+				 (unsigned long)mod->core_text_size);
+			ret = gtp_realloc_str(&grs, buf, 0);
+			if (ret)
+				goto out;
+		}
+	}
+	gtp_modules_traceframe_info = grs.buf;
+	gtp_modules_traceframe_info_len = grs.size;
+out:
+	mutex_unlock(&module_mutex);
+	return ret;
+}
+#endif
+
+static int
+gtp_traceframe_info_get(void)
+{
+	struct gtp_realloc_s	grs;
+	int			ret;
+	struct gtp_rb_walk_s	rbws;
+	char			*tmp;
+
+	if (gtp_traceframe_info_len > 0) {
+		vfree(gtp_traceframe_info);
+		gtp_traceframe_info = NULL;
+		gtp_traceframe_info_len = 0;
+	}
+	/* 40 is size for "<traceframe-info>\n</traceframe-info>\n" */
+	ret = gtp_realloc_alloc(&grs, 40);
+	if (ret != 0)
+		return ret;
+
+	ret = gtp_realloc_str(&grs, "<traceframe-info>\n", 0);
+	if (ret != 0)
+		return ret;
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE
+			| GTP_RB_WALK_CHECK_END
+			| GTP_RB_WALK_CHECK_ID
+			| GTP_RB_WALK_CHECK_TYPE;
+	rbws.end = gtp_frame_current_rb->w;
+	rbws.id = gtp_frame_current_id;
+	rbws.type = FID_MEM;
+	tmp = gtp_frame_current_rb->rp;
+
+	while (1) {
+		struct gtp_frame_mem	*mr;
+		char			buf[70];
+
+		tmp = gtp_rb_walk(&rbws, tmp);
+		if (rbws.reason != gtp_rb_walk_type)
+			break;
+		mr = (struct gtp_frame_mem *) (tmp + FID_SIZE);
+		snprintf(buf, 70,
+				"<memory start=\"0x%llx\" length=\"0x%llx\"/>\n",
+				(ULONGEST)mr->addr, (ULONGEST)mr->size);
+		ret = gtp_realloc_str(&grs, buf, 0);
+		if (ret != 0)
+			return ret;
+		tmp += FRAME_ALIGN(GTP_FRAME_MEM_SIZE + mr->size);
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	if (gtp_modules_traceframe_info_need_get) {
+		int	ret = gtp_modules_traceframe_info_get();
+		if (ret != 0)
+			return ret;
+		gtp_modules_traceframe_info_need_get = 0;
+	}
+	if (gtp_modules_traceframe_info_len > 0) {
+		tmp = gtp_realloc(&grs, gtp_modules_traceframe_info_len, 0);
+		if (tmp == NULL)
+			return -ENOMEM;
+		memcpy(tmp, gtp_modules_traceframe_info,
+		       gtp_modules_traceframe_info_len);
+	}
+#endif
+
+	ret = gtp_realloc_str(&grs, "</traceframe-info>\n", 1);
+	if (ret != 0)
+		return ret;
+
+	gtp_traceframe_info = grs.buf;
+	gtp_traceframe_info_len = grs.size;
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qxfer_traceframe_info_read(char *pkg)
+{
+	ULONGEST	offset, len;
+
+	if (gtp_start || gtp_frame_current_num < 0)
+		return -EINVAL;
+
+	pkg = hex2ulongest(pkg, &offset);
+	if (pkg[0] != ',')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &len);
+	if (len == 0)
+		return -EINVAL;
+
+	if (GTP_RW_BUFP_MAX < 10)
+		return -EINVAL;
+
+	if (offset == 0) {
+		int	ret = gtp_traceframe_info_get();
+		if (ret != 0)
+			return ret;
+	}
+
+	if (len > GTP_RW_BUFP_MAX - 1)
+		len = GTP_RW_BUFP_MAX - 1;
+
+	if (len >= gtp_traceframe_info_len - offset) {
+		len = gtp_traceframe_info_len - offset;
+		gtp_rw_bufp[0] = 'l';
+		gtp_rw_size += 1;
+		gtp_rw_bufp += 1;
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'm';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+
+	memcpy(gtp_rw_bufp, gtp_traceframe_info + offset, len);
+	gtp_rw_size += len;
+	gtp_rw_bufp += len;
+
+	return 1;
+}
+#endif
+
+static uint8_t	gtp_m_buffer[0xffff];
+
+static int
+gtp_gdbrsp_m(char *pkg)
+{
+	int		i;
+	ULONGEST	addr, len;
+
+	/* Get add and len.  */
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &addr);
+	if (pkg[0] != ',')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &len);
+	if (len == 0)
+		return -EINVAL;
+	len &= 0xffff;
+	len = (ULONGEST) min((int)(GTP_RW_BUFP_MAX / 2),
+			     (int)len);
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_m: addr = 0x%lx len = %d\n",
+		(unsigned long) addr, (int) len);
+#endif
+
+#ifdef GTP_FRAME_SIMPLE
+	if (gtp_start || !gtp_frame_current) {
+#elif defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gtp_start || gtp_frame_current_num < 0) {
+#endif
+		if (gtp_current_pid) {
+			int ret = gtp_task_read(gtp_current_pid, NULL, addr,
+						gtp_m_buffer, (int)len, 0);
+			if (ret < 0)
+				return ret;
+			if (ret != len)
+				return -EFAULT;
+
+			goto out;
+		} else {
+			if (probe_kernel_read(gtp_m_buffer,
+					      (void *)(CORE_ADDR)addr,
+					      (size_t)len))
+				return -EFAULT;
+		}
+	} else {
+#ifdef GTP_FRAME_SIMPLE
+		char	*next;
+#endif
+		int	ret;
+
+		/* XXX: Issue 1: The following part is for gtpro support.
+		   It is not available because it make disassemble cannot
+		   work when select a trace frame. */
+#if 0
+		struct gtpro_entry	*gtroe;
+
+		memset(gtp_m_buffer, 0, len);
+
+		/* Read the gtpro.  */
+		for (gtroe = gtpro_list; gtroe; gtroe = gtroe->next) {
+			CORE_ADDR	cur_start, cur_end;
+
+			cur_start = max(gtroe->start, (CORE_ADDR)addr);
+			cur_end = min(gtroe->end, ((CORE_ADDR)(addr + len)));
+			if (cur_start < cur_end) {
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: ro read "
+						 "start = 0x%lx end = 0x%lx\n",
+				       (unsigned long) cur_start,
+				       (unsigned long) cur_end);
+#endif
+				if (probe_kernel_read(gtp_m_buffer,
+						       (void *)cur_start,
+						       (size_t)(cur_end
+								- cur_start)))
+					return -EFAULT;
+			}
+		}
+#endif
+		ret = probe_kernel_read(gtp_m_buffer, (void *)(CORE_ADDR)addr,
+					(size_t)len);
+#ifdef GTP_FRAME_SIMPLE
+		for (next = *(char **)(gtp_frame_current + FID_SIZE); next;
+		     next = *(char **)(next + FID_SIZE)) {
+			if (FID(next) == FID_MEM) {
+				struct gtp_frame_mem	*mr;
+				ULONGEST		cur_start, cur_end;
+				uint8_t			*buf;
+
+				mr = (struct gtp_frame_mem *)
+				     (next + FID_SIZE + sizeof(char *));
+				buf = next + GTP_FRAME_MEM_SIZE;
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: section "
+						 "addr = 0x%lx size = %lu\n",
+				       (unsigned long) mr->addr,
+				       (unsigned long) mr->size);
+#endif
+				cur_start = max(((ULONGEST)mr->addr), addr);
+				cur_end = min(((ULONGEST)mr->addr
+						+ mr->size),
+					       (addr + len));
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: read "
+						 "start = 0x%lx end = 0x%lx\n",
+				       (unsigned long) cur_start,
+				       (unsigned long) cur_end);
+#endif
+				if (cur_start < cur_end) {
+					memcpy(gtp_m_buffer,
+						buf + cur_start - mr->addr,
+						cur_end - cur_start);
+					ret = 0;
+				}
+			}
+		}
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		gtp_frame_head_find_num(gtp_frame_current_num);
+		ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+
+		while (1) {
+			struct ring_buffer_event	*rbe;
+			char				*tmp;
+
+			rbe = ring_buffer_iter_peek
+				(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+			if (rbe == NULL)
+				break;
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			if (FID(tmp) == FID_MEM) {
+				struct gtp_frame_mem	*mr;
+				ULONGEST		cur_start, cur_end;
+				uint8_t			*buf;
+
+				mr = (struct gtp_frame_mem *)
+				     (tmp + FID_SIZE);
+				buf = tmp + GTP_FRAME_MEM_SIZE;
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: section "
+						 "addr = 0x%lx size = %lu\n",
+				       (unsigned long) mr->addr,
+				       (unsigned long) mr->size);
+#endif
+				cur_start = max(((ULONGEST)mr->addr), addr);
+				cur_end = min(((ULONGEST)mr->addr
+						+ mr->size),
+					       (addr + len));
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: read "
+						 "start = 0x%lx end = 0x%lx\n",
+				       (unsigned long) cur_start,
+				       (unsigned long) cur_end);
+#endif
+				if (cur_start < cur_end) {
+					memcpy(gtp_m_buffer,
+						buf + cur_start - mr->addr,
+						cur_end - cur_start);
+					ret = 0;
+				}
+			}
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+		}
+#endif
+#ifdef GTP_RB
+		{
+			struct gtp_rb_walk_s	rbws;
+			char			*tmp;
+
+			rbws.flags = GTP_RB_WALK_PASS_PAGE
+				     | GTP_RB_WALK_CHECK_END
+				     | GTP_RB_WALK_CHECK_ID
+				     | GTP_RB_WALK_CHECK_TYPE;
+			rbws.end = gtp_frame_current_rb->w;
+			rbws.id = gtp_frame_current_id;
+			rbws.type = FID_MEM;
+			tmp = gtp_frame_current_rb->rp;
+
+			while (1) {
+				struct gtp_frame_mem	*mr;
+				ULONGEST		cur_start, cur_end;
+				uint8_t			*buf;
+
+				tmp = gtp_rb_walk(&rbws, tmp);
+				if (rbws.reason != gtp_rb_walk_type)
+					break;
+
+				mr = (struct gtp_frame_mem *) (tmp + FID_SIZE);
+				buf = tmp + GTP_FRAME_MEM_SIZE;
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: section "
+						 "addr = 0x%lx size = %lu\n",
+				       (unsigned long) mr->addr,
+				       (unsigned long) mr->size);
+#endif
+				cur_start = max(((ULONGEST)mr->addr), addr);
+				cur_end = min(((ULONGEST)mr->addr
+						+ mr->size),
+					       (addr + len));
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: read "
+						 "start = 0x%lx end = 0x%lx\n",
+				       (unsigned long) cur_start,
+				       (unsigned long) cur_end);
+#endif
+				if (cur_start < cur_end) {
+					memcpy(gtp_m_buffer,
+						buf + cur_start - mr->addr,
+						cur_end - cur_start);
+					ret = 0;
+				}
+
+				tmp += FRAME_ALIGN(GTP_FRAME_MEM_SIZE
+						   + mr->size);
+			}
+		}
+#endif
+		if (ret)
+			return -EFAULT;
+	}
+
+out:
+	for (i = 0; i < (int)len; i++) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_gdbrsp_m: %d %02x\n", i, gtp_m_buffer[i]);
+#endif
+		sprintf(gtp_rw_bufp, "%02x", gtp_m_buffer[i]);
+		gtp_rw_bufp += 2;
+		gtp_rw_size += 2;
+	}
+
+	return 1;
+}
+
+#ifdef GTP_RB
+static struct pt_regs *
+gtp_rb_traceframe_get_regs(void)
+{
+	if (gtp_frame_current_regs == NULL) {
+		struct gtp_rb_walk_s	rbws;
+		char			*tmp;
+
+		rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END
+			     | GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_CHECK_TYPE;
+		rbws.end = gtp_frame_current_rb->w;
+		rbws.id = gtp_frame_current_id;
+		rbws.type = FID_REG;
+		tmp = gtp_rb_walk(&rbws, gtp_frame_current_rb->rp);
+		if (rbws.reason == gtp_rb_walk_type)
+			gtp_frame_current_regs = (struct pt_regs *)(tmp + FID_SIZE);
+	}
+
+	return gtp_frame_current_regs;
+}
+#endif
+
+static int
+gtp_gdbrsp_g(void)
+{
+#ifdef GTP_FRAME_SIMPLE
+	char		*next;
+#endif
+	struct pt_regs	*regs;
+
+	if (GTP_RW_BUFP_MAX < GTP_REG_ASCII_SIZE)
+		return -E2BIG;
+
+#ifdef GTP_FRAME_SIMPLE
+	if (gtp_start || !gtp_frame_current) {
+#elif defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gtp_start || gtp_frame_current_num < 0) {
+#endif
+		memset(gtp_rw_bufp, '0', GTP_REG_ASCII_SIZE);
+		goto out;
+	}
+
+	/* Get the regs.  */
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_FRAME_SIMPLE)
+	regs = NULL;
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	for (next = *(char **)(gtp_frame_current + FID_SIZE); next;
+	     next = *(char **)(next + FID_SIZE)) {
+		if (FID(next) == FID_REG) {
+			regs = (struct pt_regs *)
+			       (next + FID_SIZE + sizeof(char *));
+			break;
+		}
+	}
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	{
+		int				is_first = 1;
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+
+re_find:
+		while (1) {
+			rbe = ring_buffer_iter_peek
+				(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+			if (rbe == NULL)
+				break;
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			if (FID(tmp) == FID_REG) {
+				regs = (struct pt_regs *)(tmp + FID_SIZE);
+				is_first = 0;
+				break;
+			}
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+		}
+		if (is_first) {
+			gtp_frame_head_find_num(gtp_frame_current_num);
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+			is_first = 0;
+			goto re_find;
+		}
+	}
+#endif
+#ifdef GTP_RB
+	regs = gtp_rb_traceframe_get_regs();
+#endif
+	if (regs)
+		gtp_regs2ascii(regs, gtp_rw_bufp);
+	else {
+		struct pt_regs		pregs;
+		struct gtp_entry	*tpe;
+
+		memset(&pregs, '\0', sizeof(struct pt_regs));
+		tpe = gtp_list_find_without_addr_do_check(gtp_frame_current_tpe);
+		if (tpe)
+			GTP_REGS_PC(&pregs) = (unsigned long)tpe->addr;
+		gtp_regs2ascii(&pregs, gtp_rw_bufp);
+	}
+out:
+	gtp_rw_bufp += GTP_REG_ASCII_SIZE;
+	gtp_rw_size += GTP_REG_ASCII_SIZE;
+
+	return 1;
+}
+
+static int
+gtp_gdbrsp_vAttach(char *pkg)
+{
+	ULONGEST		pid;
+
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &pid);
+	if (pid == 0)
+		return -EINVAL;
+
+	gtp_current_pid = (pid_t)pid;
+
+	snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "S05");
+	gtp_rw_bufp += 3;
+	gtp_rw_size += 3;
+	return 1;
+}
+
+static void
+gtp_gdbrsp_D(char *pkg)
+{
+	if (pkg[0] == ';')
+		pkg++;
+	if (pkg[0] == 'p')
+		pkg++;
+
+	if (pkg[0] != '\0') {
+		/* Try to get pid.  */
+		ULONGEST	pid;
+
+		pkg = hex2ulongest(pkg, &pid);
+		if (gtp_current_pid == (pid_t)pid)
+			gtp_current_pid = 0;
+	} else
+		gtp_current_pid = 0;
+}
+
+#ifdef GTP_RB
+
+static uint64_t	gtp_replay_step_id = 0;
+static ULONGEST	gtp_replay_step_tpe = 0;
+/* Point to the first entry of step.  */
+static void	*gtp_replay_step_begin = NULL;
+/* Point to the address that after last entry.  */
+static void	*gtp_replay_step_end = NULL;
+
+static void
+gtp_replay_reset(void)
+{
+	gtp_replay_step_id = 0;
+	gtp_replay_step_tpe = 0;
+
+	gtp_rb_read_reset();
+}
+
+#endif
+
+/* Handle H + OP + thread-id packet. */
+
+static int
+gtp_gdbrsp_H(char *pkg)
+{
+	ULONGEST		pid;
+
+	if (pkg[0] != 'g')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &pid);
+
+#ifdef GTP_RB
+	if (gtp_replay_step_id)
+		gtp_replay_reset();
+#endif
+
+	gtp_current_pid = (pid_t)pid;
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qRcmd(char *pkg)
+{
+	int	buf_size = strlen(pkg) / 2;
+	char	buf[buf_size];
+
+	if (buf_size * 2 != strlen(pkg))
+		return -EINVAL;
+	hex2string(pkg, buf);
+
+#ifdef GTP_RB
+ 	if (strcmp(buf, "replay") == 0) {
+		if (gtp_replay_step_id) {
+			printk(KERN_WARNING "KGTP: already in step replay mode.\n");
+			return -EBUSY;
+		}
+
+		if (gtp_start || gtp_frame_current_num < 0) {
+			printk(KERN_WARNING "KGTP: cannot goto step replay mode because doesn't select any frame.\n");
+			return -EBUSY;
+		}
+
+		if (gtp_rb_traceframe_get_tv(gtp_frame_current_rb->rp,
+					     gtp_frame_current_id,
+					     GTP_STEP_ID_ID,
+					     &gtp_replay_step_id)) {
+			printk(KERN_WARNING "KGTP: cannot goto step replay mode because current frame doesn't have $step_id.\n");
+			return -EBUSY;
+		}
+
+		gtp_replay_step_tpe = gtp_frame_current_tpe;
+		gtp_replay_step_begin = NULL;
+		gtp_replay_step_end = NULL;
+
+		return 0;
+	} else if (strcmp(buf, "replay stop") == 0) {
+		if (gtp_replay_step_id == 0) {
+			printk(KERN_WARNING "KGTP: not in step replay mode.\n");
+			return -EBUSY;
+		}
+
+		gtp_replay_reset();
+
+		return 0;
+	}
+#endif
+
+	return 1;
+}
+
+struct gtp_breakpoints_s {
+	struct list_head	node;
+	ULONGEST		addr;
+};
+static LIST_HEAD(gtp_breakpoints);
+
+static void
+gtp_breakpoints_release(void)
+{
+	struct gtp_breakpoints_s	*b;
+	struct list_head		*cur, *tmp;
+
+	list_for_each_safe(cur, tmp, &gtp_breakpoints) {
+		b = list_entry(cur, struct gtp_breakpoints_s, node);
+		list_del(&b->node);
+		kfree(b);
+	}
+}
+
+static struct gtp_breakpoints_s *
+gtp_breakpoints_find(ULONGEST addr)
+{
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_breakpoints) {
+		struct gtp_breakpoints_s	*b;
+
+		b = list_entry(cur, struct gtp_breakpoints_s, node);
+		if (b->addr == addr)
+			return b;
+	}
+
+	return NULL;
+}
+
+static int
+gtp_gdbrsp_breakpoint(char *pkg, int insert)
+{
+	ULONGEST			addr;
+	struct gtp_breakpoints_s	*b = NULL;
+
+	/* Get addr.  */
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &addr);
+	if (pkg[0] != ',')
+		return -EINVAL;
+
+	if (insert) {
+		b = (struct gtp_breakpoints_s *)kmalloc(sizeof(*b), GFP_KERNEL);
+		if (b == NULL)
+			return -ENOMEM;
+		b->addr = addr;
+		list_add_tail(&b->node, &gtp_breakpoints);
+	} else {
+		b = gtp_breakpoints_find(addr);
+		if (b) {
+			list_del(&b->node);
+			kfree(b);
+		} else
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Get a new entry but still not have gtp_replay_step_end.
+   Check if ENTRY is belong to the current step entry list.
+   If yes, return true.  */
+
+static int
+gtp_traceframe_check(void *entry)
+{
+	if (*(u64 *)(entry + FID_SIZE + sizeof(u64)) != gtp_replay_step_tpe) {
+		/* Check the tracepoint id.  */
+		return 0;
+	} else {
+		uint64_t	val;
+
+		/* Check $step_id.  */
+		if (gtp_rb_traceframe_get_tv(entry + FRAME_ALIGN(GTP_FRAME_HEAD_SIZE),
+					     *(u64 *)(entry + FID_SIZE),
+					     GTP_STEP_ID_ID, &val))
+			return 0;
+		if (val != gtp_replay_step_id)
+			return 0;
+	}
+
+	return 1;
+}
+
+/* Step forward one step.
+   Return == 0 is OK.
+   Return > 0 is to the end.  */
+
+static int
+gtp_gdbrsp_step_forward(void)
+{
+	struct gtp_rb_walk_s	rbws;
+	void			*tmp;
+
+	if (gtp_replay_step_id == 0) {
+		printk(KERN_WARNING "KGTP: not in step replay mode.\n");
+		return -EBUSY;
+	}
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END;
+	if (gtp_replay_step_end)
+		rbws.end = gtp_replay_step_end;
+	else
+		rbws.end = gtp_frame_current_rb->w;
+	tmp = gtp_rb_walk(&rbws, gtp_frame_current_rb->rp);
+	if (rbws.reason != gtp_rb_walk_new_entry)
+		/* To the begin of gtp_frame_current_rb
+		   or to the begin of this step.
+		   Both of them can be set as the begin of this step.  */
+		goto end_out;
+	if (gtp_replay_step_end == NULL) {
+		/* Get a new entry but still not have gtp_replay_step_end.
+		   Need check if this is a entry of current step first.  */
+		if (!gtp_traceframe_check(tmp))
+			goto end_out;
+	}
+
+	gtp_frame_current_rb->rp = tmp;
+	gtp_rb_update_gtp_frame_current();
+	return 0;
+
+end_out:
+	/* Set it as gtp_replay_step_end if it is not belong to
+	   current step.  */
+	if (gtp_replay_step_end == NULL)
+		gtp_replay_step_end = tmp;
+	return 1;
+}
+
+/* Step reverse one step.
+   Return == 0 is OK.
+   Return > 0 is to the end.  */
+
+static int
+gtp_gdbrsp_step_reverse(void)
+{
+	void	*tmp;
+	void	*current_rp;
+
+	if (gtp_replay_step_id == 0) {
+		printk(KERN_WARNING "KGTP: not in step replay mode.\n");
+		return -EBUSY;
+	}
+
+	current_rp = gtp_frame_current_rb->rp - FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+	tmp = gtp_rb_walk_reverse(current_rp,
+				  gtp_replay_step_begin ? gtp_replay_step_begin
+							: gtp_frame_current_rb->r);
+	if (tmp == NULL)
+		goto end_out;
+	
+	if (gtp_replay_step_begin == NULL) {
+		/* Get a new entry but still not have gtp_replay_step_begin.
+		   Need check if this is a entry of current step first.  */
+		if (!gtp_traceframe_check(tmp))
+			goto end_out;
+	}
+
+	gtp_frame_current_rb->rp = tmp;
+	gtp_rb_update_gtp_frame_current();
+
+	return 0;
+
+end_out:
+	if (gtp_replay_step_begin == NULL)
+		gtp_replay_step_begin = current;
+	return 1;
+}
+
+static int
+gtp_gdbrsp_resume(int step, int reverse)
+{
+	int	ret = 0;
+
+	if (gtp_replay_step_id == 0) {
+		printk(KERN_WARNING "KGTP: not in step replay mode.\n");
+		return -EBUSY;
+	}
+
+	do {
+		if (reverse)
+			ret = gtp_gdbrsp_step_reverse();
+		else
+			ret = gtp_gdbrsp_step_forward();
+
+		/* Check if in the begin or end of entry list.  */
+		if (ret)
+			break;
+
+		/* Check if exec stop by breakpoints.  */
+		if (!step && !list_empty(&gtp_breakpoints)) {
+			struct pt_regs	*regs;
+
+			regs = gtp_rb_traceframe_get_regs();
+			if (regs == NULL)
+				printk(KERN_WARNING "KGTP: a traceframe doesn't include regs.\n");
+			else {
+				if (gtp_breakpoints_find(GTP_REGS_PC(regs)) != NULL)
+					break;
+			}
+		}
+	} while (!step);
+
+	if (ret)
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
+			 "T05replaylog:%s;", reverse ? "begin" : "end");
+	else
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "S05");
+	gtp_rw_size += strlen(gtp_rw_bufp);
+	gtp_rw_bufp += strlen(gtp_rw_bufp);
+
+	return 1;
+}
+
+static DEFINE_SEMAPHORE(gtp_rw_lock);
+static DECLARE_WAIT_QUEUE_HEAD(gtp_rw_wq);
+static unsigned int	gtp_rw_count;
+static unsigned int	gtp_frame_count;
+
+static void
+gtp_frame_count_get(void)
+{
+	if (gtp_frame_count == 0)
+		gtp_plugin_mod_get();
+	
+	gtp_frame_count++;
+}
+
+static void
+gtp_frame_count_put(void)
+{
+	gtp_frame_count--;
+	if (gtp_frame_count == 0) {
+		gtp_plugin_mod_put();
+
+		if (!gtp_disconnected_tracing) {
+			gtp_gdbrsp_qtstop();
+			gtp_gdbrsp_qtinit();
+#ifdef GTP_RB
+			if (!GTP_RB_PAGE_IS_EMPTY)
+				gtp_rb_page_free();
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+			if (gtp_frame) {
+#ifdef GTP_FRAME_SIMPLE
+				vfree(gtp_frame);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+				ring_buffer_free(gtp_frame);
+#endif
+				gtp_frame = NULL;
+			}
+#endif
+		}
+	}
+}
+
+static int
+gtp_open(struct inode *inode, struct file *file)
+{
+	int	ret = 0;
+
+	down(&gtp_rw_lock);
+	if (gtp_gtp_pid >= 0) {
+		if (get_current()->pid != gtp_gtp_pid) {
+			ret = -EBUSY;
+			goto out;
+		}
+	}
+	gtp_noack_mode = 0;
+
+	if (gtp_rw_count == 0) {
+		gtp_read_ack = 0;
+		gtp_rw_buf = vmalloc(GTP_RW_MAX);
+		if (!gtp_rw_buf) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+	gtp_rw_count++;
+
+	gtp_frame_count_get();
+
+	gtp_gtp_pid_count++;
+	if (gtp_gtp_pid < 0)
+		gtp_gtp_pid = get_current()->pid;
+
+out:
+	up(&gtp_rw_lock);
+	return ret;
+}
+
+static int
+gtp_release(struct inode *inode, struct file *file)
+{
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_release\n");
+#endif
+	down(&gtp_rw_lock);
+	gtp_rw_count--;
+	if (gtp_rw_count == 0) {
+		vfree(gtp_rw_buf);
+
+		if (gtp_replay_step_id)
+			gtp_replay_reset();
+
+		gtp_breakpoints_release();
+	}
+
+	gtp_frame_count_put();
+
+	gtp_gtp_pid_count--;
+	if (gtp_gtp_pid_count == 0) {
+		gtp_current_pid = 0;
+		gtp_gtp_pid = -1;
+	}
+
+	up(&gtp_rw_lock);
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+static int
+gtp_ioctl(struct inode *inode, struct file *file,
+	  unsigned int cmd, unsigned long arg)
+{
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_ioctl: %x\n", cmd);
+#endif
+
+	return 0;
+}
+#else
+static long
+gtp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_ioctl: %x\n", cmd);
+#endif
+
+	return 0;
+}
+#endif
+
+static ssize_t
+gtp_write(struct file *file, const char __user *buf, size_t size,
+	  loff_t *ppos)
+{
+	char		*rsppkg = NULL;
+	int		i, ret;
+	unsigned char	csum;
+	int		is_reverse;
+
+	if (down_interruptible(&gtp_rw_lock))
+		return -EINTR;
+
+	if (size == 0) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_write: try write 0 size.\n");
+#endif
+		goto error_out;
+	}
+
+	size = min_t(size_t, size, GTP_RW_MAX);
+	if (copy_from_user(gtp_rw_buf, buf, size)) {
+		size = -EFAULT;
+		goto error_out;
+	}
+
+	if (gtp_rw_buf[0] == '+' || gtp_rw_buf[0] == '-'
+	    || gtp_rw_buf[0] == '\3' || gtp_rw_buf[0] == '\n') {
+		if (gtp_rw_buf[0] == '+')
+			gtp_rw_size = 0;
+		size = 1;
+		goto out;
+	}
+
+	if (size < 4) {
+		size = -EINVAL;
+		goto error_out;
+	}
+	/* Check format and get the rsppkg.  */
+	for (i = 0; i < size - 2; i++) {
+		if (gtp_rw_buf[i] == '$')
+			rsppkg = gtp_rw_buf + i + 1;
+		else if (gtp_rw_buf[i] == '#')
+			break;
+	}
+	if (rsppkg && gtp_rw_buf[i] == '#') {
+		/* Format is OK.  Check crc.  */
+		if (gtp_noack_mode < 1)
+			gtp_read_ack = 1;
+		size = i + 3;
+		gtp_rw_buf[i] = '\0';
+	} else {
+		printk(KERN_WARNING "gtp_write: format error\n");
+		size = -EINVAL;
+		goto error_out;
+	}
+
+	wake_up_interruptible_nr(&gtp_rw_wq, 1);
+
+	up(&gtp_rw_lock);
+	if (down_interruptible(&gtp_rw_lock))
+		return -EINTR;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_write: %s\n", rsppkg);
+#endif
+
+	/* Handle rsppkg and put return to gtp_rw_buf.  */
+	gtp_rw_buf[0] = '$';
+	gtp_rw_bufp = gtp_rw_buf + 1;
+	gtp_rw_size = 0;
+	ret = 1;
+	is_reverse = 0;
+	switch (rsppkg[0]) {
+	case '?':
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "S05");
+		gtp_rw_bufp += 3;
+		gtp_rw_size += 3;
+		break;
+	case 'g':
+		ret = gtp_gdbrsp_g();
+		break;
+	case 'm':
+		ret = gtp_gdbrsp_m(rsppkg + 1);
+		break;
+	case 'Q':
+#ifdef GTP_RB
+		/* This check for "tfind -1" and let GDB into step replay.
+		   XXX: just test on X86_64.  */
+		if (gtp_replay_step_id) {
+			if (strcmp("QTFrame:ffffffff", rsppkg) == 0) {
+				ret = 0;
+				goto switch_done;
+			} else
+				gtp_replay_reset();
+		}
+#endif
+		if (rsppkg[1] == 'T')
+			ret = gtp_gdbrsp_QT(rsppkg + 2);
+		else if (strncmp("QStartNoAckMode", rsppkg, 15) == 0) {
+			ret = 0;
+			gtp_noack_mode = -1;
+		}
+		break;
+	case 'q':
+		if (rsppkg[1] == 'T')
+			ret = gtp_gdbrsp_qT(rsppkg + 2);
+		else if (rsppkg[1] == 'C') {
+			snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "QC%x",
+				 gtp_current_pid);
+			gtp_rw_size += strlen(gtp_rw_bufp);
+			gtp_rw_bufp += strlen(gtp_rw_bufp);
+			ret = 1;
+		} else if (strncmp("qSupported", rsppkg, 10) == 0) {
+#ifdef GTP_RB
+			snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
+				 "QStartNoAckMode+;ConditionalTracepoints+;"
+				 "TracepointSource+;DisconnectedTracing+;"
+				 "ReverseContinue+;ReverseStep+;"
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+				 "EnableDisableTracepoints+;"
+#endif
+				 "qXfer:traceframe-info:read+;");
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+			snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
+				 "QStartNoAckMode+;ConditionalTracepoints+;"
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+				 "EnableDisableTracepoints+;"
+#endif
+				 "TracepointSource+;DisconnectedTracing+;");
+#endif
+			gtp_rw_size += strlen(gtp_rw_bufp);
+			gtp_rw_bufp += strlen(gtp_rw_bufp);
+			ret = 1;
+		}
+#ifdef GTP_RB
+		else if (strncmp("qXfer:traceframe-info:read::",
+				   rsppkg, 28) == 0)
+			ret = gtp_gdbrsp_qxfer_traceframe_info_read(rsppkg
+								    + 28);
+#endif
+		else if (strncmp("qRcmd,", rsppkg, 6) == 0)
+			ret = gtp_gdbrsp_qRcmd(rsppkg + 6);
+		break;
+	case 'S':
+	case 'C':
+		ret = -1;
+		break;
+	case 'b':
+		rsppkg[0] = rsppkg[1];
+		is_reverse = 1;
+	case 's':
+	case 'c':
+		ret = gtp_gdbrsp_resume (rsppkg[0] == 's', is_reverse);
+		break;
+	case 'v':
+		if (strncmp("vAttach;", rsppkg, 8) == 0) {
+#ifdef GTP_RB
+			if (gtp_replay_step_id)
+				gtp_replay_reset();
+#endif
+			ret = gtp_gdbrsp_vAttach(rsppkg + 8);
+		}
+		break;
+	case 'D':
+#ifdef GTP_RB
+		if (gtp_replay_step_id)
+			gtp_replay_reset();
+#endif
+		gtp_gdbrsp_D(rsppkg + 1);
+		ret = 0;
+		break;
+	case 'H':
+		ret = gtp_gdbrsp_H(rsppkg + 1);
+		break;
+	case 'Z':
+	case 'z':
+		if (rsppkg[1] == '0')
+			ret = gtp_gdbrsp_breakpoint(rsppkg + 3,
+						    (rsppkg[0] == 'Z'));
+		break;
+	}
+switch_done:
+	if (ret == 0) {
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "OK");
+		gtp_rw_bufp += 2;
+		gtp_rw_size += 2;
+	} else if (ret < 0) {
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "E%02x", -ret);
+		gtp_rw_bufp += 3;
+		gtp_rw_size += 3;
+	}
+
+	gtp_rw_bufp[0] = '#';
+	csum = 0;
+	for (i = 1; i < gtp_rw_size + 1; i++)
+		csum += gtp_rw_buf[i];
+	gtp_rw_bufp[1] = INT2CHAR(csum >> 4);
+	gtp_rw_bufp[2] = INT2CHAR(csum & 0x0f);
+	gtp_rw_bufp = gtp_rw_buf;
+	gtp_rw_size += 4;
+
+out:
+	wake_up_interruptible_nr(&gtp_rw_wq, 1);
+error_out:
+	up(&gtp_rw_lock);
+	return size;
+}
+
+static ssize_t
+gtp_read(struct file *file, char __user *buf, size_t size,
+	 loff_t *ppos)
+{
+	int	err;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_read\n");
+#endif
+
+	if (size == 0)
+		return 0;
+
+	if (down_interruptible(&gtp_rw_lock))
+		return -EINTR;
+
+	if (gtp_noack_mode < 1 && gtp_read_ack) {
+		err = put_user('+', buf);
+		if (err) {
+			size = -err;
+			goto out;
+		}
+		gtp_read_ack = 0;
+		size = 1;
+		if (gtp_noack_mode < 0)
+			gtp_noack_mode = 1;
+		goto out;
+	}
+
+	size = min(gtp_rw_size, size);
+	if (size == 0)
+		goto out;
+	if (copy_to_user(buf, gtp_rw_bufp, size)) {
+		size = -EFAULT;
+		goto out;
+	}
+	gtp_rw_bufp += size;
+	gtp_rw_size -= size;
+
+out:
+	up(&gtp_rw_lock);
+	return size;
+}
+
+static unsigned int
+gtp_poll(struct file *file, poll_table *wait)
+{
+	unsigned int	mask = POLLOUT | POLLWRNORM;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_poll\n");
+#endif
+
+	down(&gtp_rw_lock);
+	poll_wait(file, &gtp_rw_wq, wait);
+	if (gtp_read_ack || gtp_rw_size)
+		mask |= POLLIN | POLLRDNORM;
+	up(&gtp_rw_lock);
+
+	return mask;
+}
+
+static int
+gtp_frame2file_r(struct gtp_realloc_s *grs, uint32_t *data_size, char *frame)
+{
+	char	*wbuf;
+
+	wbuf = gtp_realloc(grs, GTP_REG_BIN_SIZE + 1, 0);
+	if (!wbuf)
+		return -1;
+
+	wbuf[0] = 'R';
+#ifdef GTP_FRAME_SIMPLE
+	gtp_regs2bin((struct pt_regs *)(frame + FID_SIZE + sizeof(char *)),
+		     wbuf + 1);
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	gtp_regs2bin((struct pt_regs *)(frame + FID_SIZE), wbuf + 1);
+#endif
+
+	*data_size += GTP_REG_BIN_SIZE + 1;
+
+	return 0;
+}
+
+static int
+gtp_frame2file_m(struct gtp_realloc_s *grs, uint32_t *data_size, char *frame)
+{
+	struct gtp_frame_mem	*mr;
+	uint8_t			*buf;
+	ULONGEST		addr;
+	size_t			remaining;
+
+#ifdef GTP_FRAME_SIMPLE
+	mr = (struct gtp_frame_mem *) (frame + FID_SIZE + sizeof(char *));
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	mr = (struct gtp_frame_mem *) (frame + FID_SIZE);
+#endif
+	buf = frame + GTP_FRAME_MEM_SIZE;
+	addr = mr->addr;
+	remaining = mr->size;
+
+	while (remaining > 0) {
+		uint16_t	blocklen;
+		char		*wbuf;
+		size_t		sp;
+
+		blocklen = remaining > 65535 ? 65535 : remaining;
+
+		sp = 1 + sizeof(addr) + sizeof(blocklen) + blocklen;
+		wbuf = gtp_realloc(grs, sp, 0);
+		if (!wbuf)
+			return -1;
+
+		wbuf[0] = 'M';
+		wbuf += 1;
+
+		memcpy(wbuf, &addr, sizeof(addr));
+		wbuf += sizeof(addr);
+
+		memcpy(wbuf, &blocklen, sizeof(blocklen));
+		wbuf += sizeof(blocklen);
+
+		memcpy(wbuf, buf, blocklen);
+
+		addr += blocklen;
+		remaining -= blocklen;
+		buf += blocklen;
+
+		*data_size += sp;
+	}
+
+	return 0;
+}
+
+static int
+gtp_frame2file_v(struct gtp_realloc_s *grs, uint32_t *data_size, char *frame)
+{
+	struct gtp_frame_var	*vr;
+	size_t			sp = 1 + sizeof(unsigned int)
+				     + sizeof(uint64_t);
+	char			*wbuf;
+
+	wbuf = gtp_realloc(grs, sp, 0);
+	if (!wbuf)
+		return -1;
+
+#ifdef GTP_FRAME_SIMPLE
+	vr = (struct gtp_frame_var *) (frame + FID_SIZE + sizeof(char *));
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	vr = (struct gtp_frame_var *) (frame + FID_SIZE);
+#endif
+
+	wbuf[0] = 'V';
+	wbuf += 1;
+
+	memcpy(wbuf, &vr->num, sizeof(unsigned int));
+	wbuf += sizeof(unsigned int);
+
+	memcpy(wbuf, &vr->val, sizeof(uint64_t));
+	wbuf += sizeof(uint64_t);
+
+	*data_size += sp;
+
+	return 0;
+}
+
+static int
+#ifdef GTP_FRAME_SIMPLE
+gtp_frame2file(struct gtp_realloc_s *grs, char *frame)
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+gtp_frame2file(struct gtp_realloc_s *grs, int cpu)
+#endif
+#ifdef GTP_RB
+/* gtp_frame_current_rb will step inside this function.  */
+gtp_frame2file(struct gtp_realloc_s *grs)
+#endif
+{
+	int16_t				*tmp16p;
+	char				*next;
+	char				*wbuf;
+	uint32_t			data_size;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+	u64				clock;
+#endif
+#ifdef GTP_RB
+	struct gtp_rb_walk_s		rbws;
+#endif
+
+	/* Head.  */
+	tmp16p = (int16_t *)gtp_realloc(grs, 2, 0);
+	if (!tmp16p)
+		return -1;
+#ifdef GTP_FRAME_SIMPLE
+	*tmp16p = (int16_t)*(ULONGEST *)(frame + FID_SIZE + sizeof(char *));
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	rbe = ring_buffer_read(gtp_frame_iter[cpu], &clock);
+	if (rbe == NULL) {
+		/* It will not happen, just for safe.  */
+		return -1;
+	}
+	next = ring_buffer_event_data(rbe);
+	*tmp16p = (int16_t)*(ULONGEST *)(next + FID_SIZE);
+#endif
+#ifdef GTP_RB
+	*tmp16p = (int16_t)gtp_frame_current_tpe;
+#endif
+	/* This part is for the data_size.  */
+	wbuf = gtp_realloc(grs, 4, 0);
+	if (!wbuf)
+		return -1;
+
+	/* Body.  */
+	data_size = 0;
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	{
+		/* Handle $cpu_id and $clock.  */
+		struct gtp_frame_var	*vr;
+		char			frame[GTP_FRAME_VAR_SIZE];
+
+		vr = (struct gtp_frame_var *) (frame + FID_SIZE);
+		vr->num = GTP_VAR_CLOCK_ID;
+		vr->val = clock;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -1;
+		vr->num = GTP_VAR_CPU_ID;
+		vr->val = cpu;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -1;
+	}
+#endif
+
+#ifdef GTP_RB
+	{
+		/* Handle $cpu_id.  */
+		struct gtp_frame_var	*vr;
+		char			tmp[GTP_FRAME_VAR_SIZE];
+
+		vr = (struct gtp_frame_var *) (tmp + FID_SIZE);
+		vr->num = GTP_VAR_CPU_ID;
+		vr->val = gtp_frame_current_rb->cpu;
+		if (gtp_frame2file_v(grs, &data_size, tmp))
+			return -1;
+	}
+#endif
+
+#ifdef GTP_FRAME_SIMPLE
+	for (next = *(char **)(frame + FID_SIZE); next;
+	     next = *(char **)(next + FID_SIZE)) {
+#elif defined(GTP_FTRACE_RING_BUFFER)
+	while (1) {
+		rbe = ring_buffer_iter_peek(gtp_frame_iter[cpu], NULL);
+		if (rbe == NULL)
+			break;
+		next = ring_buffer_event_data(rbe);
+#endif
+#ifdef GTP_RB
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END
+		     | GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_STEP;
+	rbws.end = gtp_frame_current_rb->w;
+	rbws.id = gtp_frame_current_id;
+	rbws.step = 0;
+	next = gtp_rb_walk(&rbws, gtp_frame_current_rb->rp);
+	rbws.step = 1;
+	while (rbws.reason == gtp_rb_walk_step) {
+#endif
+		switch (FID(next)) {
+		case FID_REG:
+			if (gtp_frame2file_r(grs, &data_size, next))
+				return -1;
+			break;
+		case FID_MEM:
+			if (gtp_frame2file_m(grs, &data_size, next))
+				return -1;
+			break;
+		case FID_VAR:
+			if (gtp_frame2file_v(grs, &data_size, next))
+				return -1;
+			break;
+#ifdef GTP_FTRACE_RING_BUFFER
+		case FID_HEAD:
+			goto out;
+			break;
+#endif
+		}
+#ifdef GTP_FTRACE_RING_BUFFER
+		ring_buffer_read(gtp_frame_iter[cpu], NULL);
+#endif
+#ifdef GTP_RB
+		next = gtp_rb_walk(&rbws, next);
+#endif
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+out:
+#endif
+#ifdef GTP_RB
+	gtp_frame_current_rb->rp = next;
+#endif
+	/* Set the data_size.  */
+	memcpy(grs->buf + grs->size - data_size - 4,
+	       &data_size, 4);
+
+	return 0;
+}
+
+static int
+gtp_frame_file_header(struct gtp_realloc_s *grs, int is_end)
+{
+	char			*wbuf;
+	struct gtp_entry	*tpe;
+	struct gtp_var		*var;
+	struct list_head	*cur;
+	int			tmpsize;
+	int			ret = -1;
+
+	/* Head. */
+	wbuf = gtp_realloc(grs, 8, 0);
+	strcpy(wbuf, "\x7fTRACE0\n");
+
+	/* BUG: will be a new value.  */
+	wbuf = gtp_realloc(grs, 100, 0);
+	if (!wbuf)
+		goto out;
+	snprintf(wbuf, 100, "R %x\n", GTP_REG_BIN_SIZE);
+	gtp_realloc_sub_size(grs, 100 - strlen(wbuf));
+
+	if (gtp_realloc_str(grs, "status 0;", 0))
+		goto out;
+
+	wbuf = gtp_realloc(grs, 300, 0);
+	if (!wbuf)
+		goto out;
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->reason != gtp_stop_normal)
+			break;
+	}
+	tmpsize = gtp_get_status(tpe, wbuf, 300);
+	gtp_realloc_sub_size(grs, 300 - tmpsize);
+
+	if (gtp_realloc_str(grs, "\n", 0))
+		goto out;
+
+	/* Tval. */
+	list_for_each(cur, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		wbuf = gtp_realloc(grs, 200, 0);
+		if (!wbuf)
+			goto out;
+		snprintf(wbuf, 200, "tsv %x:%llx:%s\n", var->num,
+			 (unsigned long long)var->initial_val, var->src);
+		gtp_realloc_sub_size(grs, 200 - strlen(wbuf));
+	}
+
+	/* Tracepoint.  */
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		struct gtpsrc	*src;
+
+		/* Tpe.  */
+		if (gtp_realloc_str(grs, "tp ", 0))
+			goto out;
+		wbuf = gtp_realloc(grs, GTP_REPORT_TRACEPOINT_MAX, 0);
+		if (!wbuf)
+			goto out;
+		gtp_report_tracepoint(tpe, wbuf, GTP_REPORT_TRACEPOINT_MAX);
+		gtp_realloc_sub_size(grs,
+				     GTP_REPORT_TRACEPOINT_MAX - strlen(wbuf));
+		if (gtp_realloc_str(grs, "\n", 0))
+			goto out;
+		/* Action.  */
+		for (src = tpe->action_cmd; src; src = src->next) {
+			if (gtp_realloc_str(grs, "tp ", 0))
+				goto out;
+			tmpsize = gtp_report_action_max(tpe, src);
+			wbuf = gtp_realloc(grs, tmpsize, 0);
+			if (!wbuf)
+				goto out;
+			gtp_report_action(tpe, src, wbuf, tmpsize);
+			gtp_realloc_sub_size(grs, tmpsize - strlen(wbuf));
+			if (gtp_realloc_str(grs, "\n", 0))
+				goto out;
+		}
+		/* Src.  */
+		for (src = tpe->src; src; src = src->next) {
+			if (gtp_realloc_str(grs, "tp ", 0))
+				goto out;
+			tmpsize = gtp_report_src_max(tpe, src);
+			wbuf = gtp_realloc(grs, tmpsize, 0);
+			if (!wbuf)
+				goto out;
+			gtp_report_src(tpe, src, wbuf, tmpsize);
+			gtp_realloc_sub_size(grs, tmpsize - strlen(wbuf));
+			if (gtp_realloc_str(grs, "\n", 0))
+				goto out;
+		}
+	}
+
+	if (gtp_realloc_str(grs, "\n", is_end))
+		goto out;
+
+	ret = 0;
+out:
+	return ret;
+}
+
+static ssize_t
+gtpframe_read(struct file *file, char __user *buf, size_t size,
+	      loff_t *ppos)
+{
+	ssize_t	ret = -ENOMEM;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	/* -2 means don't need set the frame back old number.  */
+	int	old_num = -2;
+#endif
+
+recheck:
+	down(&gtp_rw_lock);
+	if (gtp_start) {
+		up(&gtp_rw_lock);
+		if (wait_event_interruptible(gtpframe_wq,
+					     !gtp_start) == -ERESTARTSYS)
+			return -EINTR;
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtpframe_read: goto recheck\n");
+#endif
+		goto recheck;
+	}
+
+	/* Set gtp_frame_file if need.  */
+	if (!gtp_frame_file) {
+		char			*wbuf;
+#ifdef GTP_FRAME_SIMPLE
+		char			*frame;
+#endif
+		struct gtp_realloc_s	gr;
+
+#ifdef GTP_FRAME_SIMPLE
+		if (gtp_frame_is_circular)
+			gr.real_size = GTP_FRAME_SIZE;
+		else
+			gr.real_size = gtp_frame_w_start - gtp_frame;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		gr.real_size =
+			ring_buffer_entries(gtp_frame) * GTP_FRAME_HEAD_SIZE;
+#endif
+#ifdef GTP_RB
+		if (atomic_read(&gtp_frame_create) != 0) {
+			int	cpu;
+
+			for_each_online_cpu(cpu) {
+				struct gtp_rb_s	*rb
+				= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+				void		*tmp;
+				unsigned long	flags;
+
+				GTP_RB_LOCK_IRQ(rb, flags);
+				gr.real_size = GTP_RB_END(rb->r) - rb->r;
+				for (tmp = GTP_RB_NEXT(rb->r);
+				     GTP_RB_HEAD(tmp) != GTP_RB_HEAD(rb->w);
+				     tmp = GTP_RB_NEXT(tmp))
+					gr.real_size += GTP_RB_DATA_MAX;
+				gr.real_size += rb->w - GTP_RB_DATA(rb->w);
+				GTP_RB_UNLOCK_IRQ(rb, flags);
+			}
+		}
+#endif
+		gr.real_size += 200;
+		ret = gtp_realloc_alloc(&gr, gr.real_size);
+		if (ret != 0)
+			goto out;
+
+		if (gtp_frame_file_header(&gr, 0))
+			goto out;
+
+		/* Frame.  */
+		if (atomic_read(&gtp_frame_create) == 0)
+			goto end;
+#ifdef GTP_FRAME_SIMPLE
+		frame = gtp_frame_r_start;
+		do {
+			if (frame == gtp_frame_end)
+				frame = gtp_frame;
+
+			if (FID(frame) == FID_HEAD) {
+				if (gtp_frame2file(&gr, frame))
+					goto out;
+			}
+
+			frame = gtp_frame_next(frame);
+			if (!frame)
+				break;
+		} while (frame != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		old_num = gtp_frame_current_num;
+		gtp_frame_iter_reset();
+		while (1) {
+			int	cpu;
+
+			cpu = gtp_frame_iter_peek_head();
+			if (cpu < 0)
+				break;
+
+			if (gtp_frame2file(&gr, cpu))
+				goto out;
+		}
+#endif
+#ifdef GTP_RB
+		old_num = gtp_frame_current_num;
+		gtp_rb_read_reset();
+		while (1) {
+			if (gtp_rb_read() != 0)
+				break;
+			gtp_frame2file(&gr);
+		}
+#endif
+
+end:
+		/* End.  */
+		wbuf = gtp_realloc(&gr, 2, 1);
+		if (!wbuf)
+			goto out;
+		wbuf[0] = '\0';
+		wbuf[1] = '\0';
+
+		gtp_frame_file = gr.buf;
+		gtp_frame_file_size = gr.size;
+	}
+
+	/* Set buf.  */
+	ret = size;
+	if (*ppos + ret > gtp_frame_file_size) {
+		ret = gtp_frame_file_size - *ppos;
+		if (ret <= 0) {
+			ret = 0;
+			goto out;
+		}
+	}
+	if (copy_to_user(buf, gtp_frame_file + *ppos, ret)) {
+		size = -EFAULT;
+		goto out;
+	}
+	*ppos += ret;
+
+out:
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (old_num == -1)
+		gtp_frame_iter_reset();
+	else if (old_num >= 0) {
+		gtp_frame_head_find_num(old_num);
+		ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+	}
+#endif
+#ifdef GTP_RB
+	if (old_num == -1)
+		gtp_rb_reset();
+	else if (old_num >= 0)
+		gtp_frame_head_find_num(old_num);
+#endif
+	up(&gtp_rw_lock);
+	return ret;
+}
+
+static int
+gtpframe_open(struct inode *inode, struct file *file)
+{
+recheck:
+	down(&gtp_rw_lock);
+#ifdef GTP_RB
+	if (GTP_RB_PAGE_IS_EMPTY) {
+#elif defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (!gtp_frame) {
+#endif
+		up(&gtp_rw_lock);
+#ifdef GTP_RB
+		if (wait_event_interruptible(gtpframe_wq,
+					     !GTP_RB_PAGE_IS_EMPTY)
+		    == -ERESTARTSYS)
+#elif defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+		if (wait_event_interruptible(gtpframe_wq,
+					     gtp_frame) == -ERESTARTSYS)
+#endif
+			return -EINTR;
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtpframe_open: goto recheck\n");
+#endif
+		goto recheck;
+	}
+
+	if (gtp_gtpframe_pipe_pid >= 0) {
+		up(&gtp_rw_lock);
+		return -EBUSY;
+	}
+
+	if (gtp_gtpframe_pid >= 0) {
+		if (get_current()->pid != gtp_gtpframe_pid) {
+			up(&gtp_rw_lock);
+			return -EBUSY;
+		}
+	}
+
+	gtp_frame_count_get();
+
+	gtp_gtpframe_pid_count++;
+	if (gtp_gtpframe_pid < 0)
+		gtp_gtpframe_pid = get_current()->pid;
+
+	up(&gtp_rw_lock);
+	return 0;
+}
+
+static int
+gtpframe_release(struct inode *inode, struct file *file)
+{
+	down(&gtp_rw_lock);
+	gtp_frame_count_put();
+
+	gtp_gtpframe_pid_count--;
+	if (gtp_gtpframe_pid_count == 0)
+		gtp_gtpframe_pid = -1;
+	up(&gtp_rw_lock);
+
+	return 0;
+}
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+struct gtpframe_pipe_s {
+	loff_t			begin;
+	struct gtp_realloc_s	*grs;
+	int			llseek_move;
+#ifdef GTP_RB
+	void			**page;
+	u64			*page_id;
+#endif
+};
+
+static int
+gtpframe_pipe_open(struct inode *inode, struct file *file)
+{
+	int			ret = -ENOMEM;
+	struct gtpframe_pipe_s	*gps = NULL;
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_current_num >= 0 || gtp_gtpframe_pipe_pid >= 0) {
+		ret = -EBUSY;
+		goto out;
+	}
+	gtp_gtpframe_pipe_pid = get_current()->pid;
+
+recheck:
+#ifdef GTP_RB
+	if (GTP_RB_PAGE_IS_EMPTY) {
+#elif defined(GTP_FTRACE_RING_BUFFER)
+	if (!gtp_frame) {
+#endif
+		up(&gtp_rw_lock);
+		atomic_inc(&gtpframe_pipe_wq_v);
+#ifdef GTP_RB
+		if (wait_event_interruptible(gtpframe_pipe_wq,
+			!GTP_RB_PAGE_IS_EMPTY) == -ERESTARTSYS) {
+#elif defined(GTP_FTRACE_RING_BUFFER)
+		if (wait_event_interruptible(gtpframe_pipe_wq,
+					     gtp_frame) == -ERESTARTSYS) {
+#endif
+			ret = -EINTR;
+			goto out;
+		}
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtpframe_pipe_open: goto recheck\n");
+#endif
+		down(&gtp_rw_lock);
+		goto recheck;
+	}
+
+	gps = kzalloc(sizeof(struct gtpframe_pipe_s), GFP_KERNEL);
+	if (gps == NULL)
+		goto out;
+	gps->grs = kzalloc(sizeof(struct gtp_realloc_s), GFP_KERNEL);
+	if (gps->grs == NULL)
+		goto out;
+#ifdef GTP_RB
+	gps->page = kcalloc(gtp_cpu_number, sizeof(void *), GFP_KERNEL);
+	if (gps->page == NULL)
+		goto out;
+	gps->page_id = kcalloc(gtp_cpu_number, sizeof(u64), GFP_KERNEL);
+	if (gps->page_id == NULL)
+		goto out;
+#endif
+
+	file->private_data = gps;
+
+	gtp_frame_count_get();
+
+	ret = 0;
+out:
+	if (ret) {
+		gtp_gtpframe_pipe_pid = -1;
+		if (gps) {
+			kfree(gps->grs);
+#ifdef GTP_RB
+			kfree(gps->page);
+			kfree(gps->page_id);
+#endif
+			kfree(gps);
+		}
+	}
+	up(&gtp_rw_lock);
+	return ret;
+}
+
+static int
+gtpframe_pipe_release(struct inode *inode, struct file *file)
+{
+	struct gtpframe_pipe_s	*gps = file->private_data;
+
+	down(&gtp_rw_lock);
+	gtp_frame_count_put();
+
+	gtp_gtpframe_pipe_pid = -1;
+
+	up(&gtp_rw_lock);
+
+	if (gps) {
+#ifdef GTP_RB
+		int	cpu;
+
+		for_each_online_cpu(cpu) {
+			struct gtp_rb_s	*rb
+				= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+			if (gps->page[cpu])
+				gtp_rb_put_page(rb, gps->page[cpu], 0);
+		}
+
+		kfree(gps->page);
+		kfree(gps->page_id);
+#endif
+		if (gps->grs) {
+			if (gps->grs->buf)
+				vfree(gps->grs->buf);
+			kfree(gps->grs);
+		}
+		kfree(gps);
+	}
+
+	return 0;
+}
+
+#ifdef GTP_RB
+static int
+gtpframe_pipe_peek(struct gtpframe_pipe_s *gps)
+{
+	int			cpu;
+	u64			min_id = ULLONG_MAX;
+	int			ret = -1;
+	struct gtp_rb_walk_s	rbws;
+
+	rbws.flags = 0;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+
+		if (gps->page_id[cpu] == 0) {
+			/* Get new page.  */
+			if (gps->page[cpu] == NULL) {
+get_new_page:
+				gps->page[cpu] = gtp_rb_get_page(rb);
+				if (gps->page[cpu] == NULL)
+					continue;
+			}
+			/* Get new entry.  */
+			gps->page[cpu] = gtp_rb_walk(&rbws, gps->page[cpu]);
+			if (rbws.reason != gtp_rb_walk_new_entry) {
+				/* Put the page back and get a new page.  */
+				gtp_rb_put_page(rb, gps->page[cpu], 1);
+				goto get_new_page;
+			}
+			/* Get id.  */
+			gps->page_id[cpu] = *(u64 *)(gps->page[cpu] + FID_SIZE);
+		}
+
+		if (gps->page_id[cpu] < min_id) {
+			min_id = gps->page_id[cpu];
+			ret = cpu;
+		}
+	}
+
+	return ret;
+}
+#else
+static int
+gtpframe_pipe_peek(void)
+{
+	u64				min = 0;
+	u64				ts;
+	int				cpu;
+	struct ring_buffer_event	*rbe;
+	char				*next;
+	int				ret = -1;
+
+	for_each_online_cpu(cpu) {
+		while (1) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) \
+    && !defined(GTP_SELF_RING_BUFFER)
+			rbe = ring_buffer_peek(gtp_frame, cpu, &ts);
+#else
+			rbe = ring_buffer_peek(gtp_frame, cpu, &ts, NULL);
+#endif
+			if (rbe == NULL)
+				break;
+			next = ring_buffer_event_data(rbe);
+			if (FID(next) == FID_HEAD)
+				break;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) \
+    && !defined(GTP_SELF_RING_BUFFER)
+			ring_buffer_consume(gtp_frame, cpu, &ts);
+#else
+			ring_buffer_consume(gtp_frame, cpu, &ts, NULL);
+#endif
+		}
+
+		if (rbe) {
+			if ((min && ts < min) || !min) {
+				min = ts;
+				ret = cpu;
+			}
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static int
+#ifdef GTP_RB
+gtpframe_pipe_get_entry(struct gtpframe_pipe_s *gps)
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+gtpframe_pipe_get_entry(struct gtp_realloc_s *grs)
+#endif
+{
+	int				cpu;
+	int16_t				*tmp16p;
+	uint32_t			data_size;
+#ifdef GTP_FTRACE_RING_BUFFER
+	char				*next;
+	struct ring_buffer_event	*rbe;
+	u64				ts;
+#endif
+
+#ifdef GTP_RB
+	struct gtp_rb_walk_s		rbws;
+	struct gtp_realloc_s		*grs = gps->grs;
+#endif
+	/* Because this function only be called when gtp_realloc_is_empty,
+	   so grs don't need reset. */
+
+#ifdef GTP_RB
+#define GTP_PIPE_PEEK	(cpu = gtpframe_pipe_peek(gps))
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+recheck:
+#define GTP_PIPE_PEEK	(cpu = gtpframe_pipe_peek())
+#endif
+	GTP_PIPE_PEEK;
+	if (cpu < 0) {
+		/* Didn't get the buffer that have event.
+		   Wait and recheck.*/
+		atomic_inc(&gtpframe_pipe_wq_v);
+		if (wait_event_interruptible(gtpframe_pipe_wq,
+					     GTP_PIPE_PEEK >= 0)
+			== -ERESTARTSYS)
+			return -EINTR;
+	}
+#undef GTP_PIPE_PEEK
+
+	/* Head.  */
+#ifdef GTP_FTRACE_RING_BUFFER
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) \
+    && !defined(GTP_SELF_RING_BUFFER)
+	rbe = ring_buffer_consume(gtp_frame, cpu, &ts);
+#else
+	rbe = ring_buffer_consume(gtp_frame, cpu, &ts, NULL);
+#endif
+	if (rbe == NULL)
+		goto recheck;
+	next = ring_buffer_event_data(rbe);
+	if (FID(next) != FID_HEAD)
+		goto recheck;
+#endif
+	tmp16p = (int16_t *)gtp_realloc(grs, 2, 0);
+	if (!tmp16p)
+		return -ENOMEM;
+#ifdef GTP_RB
+	*tmp16p = (int16_t)*(ULONGEST *)(gps->page[cpu] + FID_SIZE
+					 + sizeof(u64));
+	gps->page[cpu] += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	*tmp16p = (int16_t)*(ULONGEST *)(next + FID_SIZE);
+#endif
+	/* This part is for the data_size.  */
+	if (gtp_realloc(grs, 4, 0) == NULL)
+		return -ENOMEM;
+	data_size = 0;
+
+#ifdef GTP_RB
+	{
+		/* Handle $cpu_id.  */
+		struct gtp_frame_var	*vr;
+		char			frame[GTP_FRAME_VAR_SIZE];
+
+		vr = (struct gtp_frame_var *) (frame + FID_SIZE);
+		vr->num = GTP_VAR_CPU_ID;
+		vr->val = cpu;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -ENOMEM;
+	}
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	{
+		/* Handle $cpu_id and $clock.  */
+		struct gtp_frame_var	*vr;
+		char			frame[GTP_FRAME_VAR_SIZE];
+
+		vr = (struct gtp_frame_var *) (frame + FID_SIZE);
+		vr->num = GTP_VAR_CLOCK_ID;
+		vr->val = ts;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -ENOMEM;
+		vr->num = GTP_VAR_CPU_ID;
+		vr->val = cpu;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -ENOMEM;
+	}
+#endif
+
+#ifdef GTP_RB
+	rbws.flags = GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_STEP;
+	rbws.id = gps->page_id[cpu];
+re_walk:
+	rbws.step = 0;
+	gps->page[cpu] = gtp_rb_walk(&rbws, gps->page[cpu]);
+	rbws.step = 1;
+	while (rbws.reason == gtp_rb_walk_step) {
+		switch (FID(gps->page[cpu])) {
+		case FID_REG:
+			if (gtp_frame2file_r(grs, &data_size, gps->page[cpu]))
+				return -ENOMEM;
+			break;
+
+		case FID_MEM:
+			if (gtp_frame2file_m(grs, &data_size, gps->page[cpu]))
+				return -ENOMEM;
+			break;
+
+		case FID_VAR:
+			if (gtp_frame2file_v(grs, &data_size, gps->page[cpu]))
+				return -ENOMEM;
+			break;
+		}
+		gps->page[cpu] = gtp_rb_walk(&rbws, gps->page[cpu]);
+	}
+	if (rbws.reason == gtp_rb_walk_end_page
+	    || rbws.reason == gtp_rb_walk_error) {
+		/* Put this page back.  */
+		gtp_rb_put_page((struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu),
+				gps->page[cpu], 1);
+		gps->page[cpu] = gtp_rb_get_page((struct gtp_rb_s *)per_cpu_ptr
+							(gtp_rb, cpu));
+		if (gps->page[cpu])
+			goto re_walk;
+	}
+	gps->page_id[cpu] = 0;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	while (1) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) \
+    && !defined(GTP_SELF_RING_BUFFER)
+#define GTP_PIPE_CONSUME (rbe = ring_buffer_consume(gtp_frame, cpu, NULL))
+#else
+#define GTP_PIPE_CONSUME (rbe = ring_buffer_consume(gtp_frame, cpu, NULL, NULL))
+#endif
+		GTP_PIPE_CONSUME;
+		if (rbe == NULL) {
+			if (!gtp_start)
+				break;
+
+			atomic_inc(&gtpframe_pipe_wq_v);
+			if (wait_event_interruptible(gtpframe_pipe_wq,
+							GTP_PIPE_CONSUME
+							!= NULL)
+					== -ERESTARTSYS)
+				return -EINTR;
+			continue;
+		}
+#undef GTP_PIPE_CONSUME
+		next = ring_buffer_event_data(rbe);
+		switch (FID(next)) {
+		case FID_REG:
+			if (gtp_frame2file_r(grs, &data_size, next))
+				return -ENOMEM;
+			break;
+
+		case FID_MEM:
+			if (gtp_frame2file_m(grs, &data_size, next))
+				return -ENOMEM;
+			break;
+
+		case FID_VAR:
+			if (gtp_frame2file_v(grs, &data_size, next))
+				return -ENOMEM;
+			break;
+
+		case FID_HEAD:
+		case FID_END:
+			goto while_out;
+			break;
+		}
+	}
+while_out:
+#endif
+	/* Set the data_size.  */
+	memcpy(grs->buf + grs->size - data_size - 4, &data_size, 4);
+
+	return 0;
+}
+
+static ssize_t
+gtpframe_pipe_read(struct file *file, char __user *buf, size_t size,
+		   loff_t *ppos)
+{
+	ssize_t			ret = -ENOMEM;
+	struct gtpframe_pipe_s	*gps = file->private_data;
+	loff_t			entry_offset;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtpframe_pipe_read: size=%u *ppos=%lld\n",
+	       size, *ppos);
+#endif
+
+	if (!gtp_realloc_is_alloced(gps->grs)) {
+		ret = gtp_realloc_alloc(gps->grs, 200);
+		if (ret != 0)
+			goto out;
+	} else if (*ppos < gps->begin
+		   || *ppos >= (gps->begin + gps->grs->size)) {
+		gtp_realloc_reset(gps->grs);
+
+		if (gps->llseek_move) {
+			/* clear user will return NULL.
+			   Then GDB tfind got a fail.  */
+			if (size > 2)
+				size = 2;
+			if (clear_user(buf, size)) {
+				ret = -EFAULT;
+				goto out;
+			}
+			gps->begin = 0;
+			gps->llseek_move = 0;
+			ret = size;
+			goto out;
+		}
+	}
+
+	if (gtp_realloc_is_empty(gps->grs)) {
+		if (*ppos == 0) {
+			if (gtp_frame_file_header(gps->grs, 1))
+				goto out;
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtpframe_pipe_read: Get header.\n");
+#endif
+		} else {
+#ifdef GTP_RB
+			ret = gtpframe_pipe_get_entry(gps);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+			ret = gtpframe_pipe_get_entry(gps->grs);
+#endif
+			if (ret < 0)
+				goto out;
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtpframe_pipe_read: Get entry.\n");
+#endif
+		}
+		gps->begin = *ppos;
+	}
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtpframe_pipe_read: gps->begin=%lld "
+			 "gps->grs->size=%u\n",
+	       gps->begin, gps->grs->size);
+#endif
+
+	entry_offset = *ppos - gps->begin;
+	ret = size;
+	if (entry_offset + size > gps->grs->size)
+		ret = gps->grs->size - entry_offset;
+	if (copy_to_user(buf, gps->grs->buf + entry_offset, ret)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	*ppos += ret;
+
+out:
+	return ret;
+}
+
+static loff_t
+gtpframe_pipe_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct gtpframe_pipe_s	*gps = file->private_data;
+	loff_t			ret = default_llseek(file, offset, origin);
+
+	if (ret < 0)
+		return ret;
+
+	/* True means that GDB tfind to next frame entry.  */
+	if (ret >= gps->begin + gps->grs->size && gps->begin)
+		gps->llseek_move = 1;
+
+	return ret;
+}
+#endif
+
+static const struct file_operations gtp_operations = {
+	.owner		= THIS_MODULE,
+	.open		= gtp_open,
+	.release	= gtp_release,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	.ioctl		= gtp_ioctl,
+#else
+	.unlocked_ioctl	= gtp_ioctl,
+	.compat_ioctl	= gtp_ioctl,
+#endif
+	.read		= gtp_read,
+	.write		= gtp_write,
+	.poll		= gtp_poll,
+};
+
+static const struct file_operations gtpframe_operations = {
+	.owner		= THIS_MODULE,
+	.open		= gtpframe_open,
+	.release	= gtpframe_release,
+	.read		= gtpframe_read,
+	.llseek		= default_llseek,
+};
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+static const struct file_operations gtpframe_pipe_operations = {
+	.owner		= THIS_MODULE,
+	.open		= gtpframe_pipe_open,
+	.release	= gtpframe_pipe_release,
+	.read		= gtpframe_pipe_read,
+	.llseek		= gtpframe_pipe_llseek,
+};
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+static int
+gtp_modules_load_del_notify(struct notifier_block *self, unsigned long val,
+			    void *data)
+{
+	if (val == MODULE_STATE_COMING)
+		return 0;
+
+	down(&gtp_rw_lock);
+	gtp_modules_traceframe_info_need_get = 1;
+	up(&gtp_rw_lock);
+
+	return 0;
+}
+
+static struct notifier_block	gtp_modules_load_del_nb = {
+	.notifier_call = gtp_modules_load_del_notify,
+};
+#endif
+
+#ifndef USE_PROC
+struct dentry	*gtp_dir;
+struct dentry	*gtpframe_dir;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+struct dentry	*gtpframe_pipe_dir;
+#endif
+#endif
+
+struct gtp_plugin_mod
+{
+	struct list_head	node;
+	struct module 		*mod;
+};
+
+static LIST_HEAD(gtp_plugin_mod_list);
+
+static void
+gtp_plugin_mod_get(void)
+{
+	struct gtp_plugin_mod	*plugin;
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_plugin_mod_list) {
+		plugin = list_entry(cur, struct gtp_plugin_mod, node);
+		if (!try_module_get(plugin->mod))
+			printk(KERN_WARNING "Try to get KGTP plugin module fail.\n");
+	}
+}
+
+static void
+gtp_plugin_mod_put(void)
+{
+	struct gtp_plugin_mod	*plugin;
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_plugin_mod_list) {
+		plugin = list_entry(cur, struct gtp_plugin_mod, node);
+		module_put(plugin->mod);
+	}
+}
+
+int
+gtp_plugin_mod_register(struct module *mod)
+{
+	int 			ret = -EBUSY;
+	struct gtp_plugin_mod	*plugin;
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_count || gtp_disconnected_tracing)
+		goto out;
+
+	plugin = (struct gtp_plugin_mod *)kmalloc(sizeof(*plugin),
+						  GFP_KERNEL);
+	if (plugin == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	plugin->mod = mod;
+
+	list_add(&plugin->node, &gtp_plugin_mod_list);
+
+	ret = 0;
+out:
+	up(&gtp_rw_lock);
+	return ret;
+}
+EXPORT_SYMBOL(gtp_plugin_mod_register);
+
+int
+gtp_plugin_mod_unregister(struct module *mod)
+{
+	int 			ret = -EBUSY;
+	struct gtp_plugin_mod	*plugin;
+	struct list_head	*cur, *tmp;
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_count || gtp_disconnected_tracing)
+		goto out;
+
+	list_for_each_safe(cur, tmp, &gtp_plugin_mod_list) {
+		plugin = list_entry(cur, struct gtp_plugin_mod, node);
+		if (plugin->mod == mod) {
+			list_del(&plugin->node);
+			kfree(plugin);
+			ret = 0;
+			goto out;
+		}
+	}
+	ret = -EINVAL;
+
+out:
+	up(&gtp_rw_lock);
+	return ret;
+}
+EXPORT_SYMBOL(gtp_plugin_mod_unregister);
+
+struct gtp_var *
+gtp_plugin_var_add(char *name, int64_t val, struct gtp_var_hooks *hooks)
+{
+	struct gtp_var	*var = ERR_PTR(-EBUSY);
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_count || gtp_disconnected_tracing)
+		goto out;
+
+	var = gtp_var_special_add(0, 1, val, name, hooks);
+
+out:
+	up(&gtp_rw_lock);
+	return var;
+}
+EXPORT_SYMBOL(gtp_plugin_var_add);
+
+int
+gtp_plugin_var_del(struct gtp_var *var)
+{
+	int			ret = -EBUSY;
+	struct list_head	*cur, *tmp;
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_count || gtp_disconnected_tracing)
+		goto out;
+
+	list_for_each_safe(cur, tmp, &gtp_var_list) {
+		if (var == list_entry(cur, struct gtp_var, node)) {
+			list_del(&var->node);
+			gtp_var_num--;
+			kfree(var->src);
+			kfree(var);
+			ret = 0;
+			goto out;
+		}
+	}
+
+	ret = -EINVAL;
+
+out:
+	up(&gtp_rw_lock);
+	return ret;
+}
+EXPORT_SYMBOL(gtp_plugin_var_del);
+
+static void gtp_exit(void);
+
+static int __init gtp_init(void)
+{
+	int		ret = -ENOMEM;
+
+#ifdef CONFIG_X86
+	gtp_have_watch_tracepoint = 0;
+	gtp_have_step = 0;
+#endif
+	gtp_gtp_pid = -1;
+	gtp_gtp_pid_count = 0;
+	gtp_gtpframe_pid = -1;
+	gtp_gtpframe_pid_count = 0;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	gtp_gtpframe_pipe_pid = -1;
+#endif
+	gtp_list = NULL;
+	gtp_read_ack = 0;
+	gtp_rw_bufp = NULL;
+	gtp_rw_size = 0;
+	gtp_start = 0;
+	gtp_disconnected_tracing = 0;
+	gtp_circular = 0;
+#if defined(GTP_FTRACE_RING_BUFFER)			\
+    && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))	\
+    && !defined(GTP_SELF_RING_BUFFER)
+	gtp_circular_is_changed = 0;
+#endif
+	gtp_var_array = NULL;
+	current_gtp_var = NULL;
+	gtp_var_num = 0;
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	gtp_frame = NULL;
+#endif
+	gtp_frame_current_num = -1;
+	gtp_frame_current_tpe = 0;
+#ifdef GTP_FRAME_SIMPLE
+	gtp_frame_r_start = NULL;
+	gtp_frame_w_start = NULL;
+	gtp_frame_end = NULL;
+	gtp_frame_current = NULL;
+	gtp_frame_is_circular = 0;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	{
+		int	cpu;
+
+		for_each_online_cpu(cpu)
+			gtp_frame_iter[cpu] = NULL;
+	}
+	gtp_frame_current_cpu = 0;
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	atomic_set(&gtpframe_pipe_wq_v, 0);
+#endif
+	atomic_set(&gtp_frame_create, 0);
+	gtp_rw_count = 0;
+	gtp_frame_count = 0;
+	current_gtp = NULL;
+	current_gtp_action_cmd = NULL;
+	current_gtp_src = NULL;
+	gtpro_list = NULL;
+	gtp_frame_file = NULL;
+	gtp_frame_file_size = 0;
+#ifndef USE_PROC
+	gtp_dir = NULL;
+	gtpframe_dir = NULL;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	gtpframe_pipe_dir = NULL;
+#endif
+#endif
+	{
+		int	cpu;
+
+		gtp_cpu_number = 0;
+		for_each_online_cpu(cpu) {
+			if (cpu > gtp_cpu_number)
+				gtp_cpu_number = cpu;
+		}
+		gtp_cpu_number++;
+	}
+	gtp_start_last_errno = 0;
+	gtp_start_ignore_error = 0;
+	gtp_pipe_trace = 0;
+	gtp_bt_size = 512;
+	gtp_noack_mode = 0;
+	gtp_current_pid = 0;
+#ifdef GTP_RB
+	gtp_traceframe_info = NULL;
+	gtp_traceframe_info_len = 0;
+#endif
+
+#ifdef CONFIG_X86
+	{
+		/* Init data of while-stepping.  */
+		int	cpu;
+		for_each_online_cpu(cpu) {
+			struct gtp_step_s	*step = &per_cpu(gtp_step, cpu);
+			spin_lock_init(&step->lock);
+			step->step = 0;
+			step->tpe = NULL;
+		}
+	}
+#endif
+
+#ifdef GTP_RB
+	ret = gtp_rb_init();
+	if (ret != 0)
+		goto out;
+#endif
+
+	gtp_wq = create_singlethread_workqueue("gtpd");
+	if (gtp_wq == NULL)
+		goto out;
+#ifdef USE_PROC
+	if (proc_create("gtp", S_IFIFO | S_IRUSR | S_IWUSR, NULL,
+			&gtp_operations) == NULL)
+		goto out;
+	if (proc_create("gtpframe", S_IFIFO | S_IRUSR, NULL,
+			&gtpframe_operations) == NULL)
+		goto out;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (proc_create("gtpframe_pipe", S_IFIFO | S_IRUSR, NULL,
+			&gtpframe_pipe_operations) == NULL)
+		goto out;
+#endif
+#else
+	ret = -ENODEV;
+	gtp_dir = debugfs_create_file("gtp", S_IRUSR | S_IWUSR, NULL,
+				      NULL, &gtp_operations);
+	if (gtp_dir == NULL || gtp_dir == ERR_PTR(-ENODEV)) {
+		gtp_dir = NULL;
+		goto out;
+	}
+	gtpframe_dir = debugfs_create_file("gtpframe", S_IRUSR, NULL,
+					   NULL, &gtpframe_operations);
+	if (gtpframe_dir == NULL || gtpframe_dir == ERR_PTR(-ENODEV)) {
+		gtpframe_dir = NULL;
+		goto out;
+	}
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	gtpframe_pipe_dir = debugfs_create_file("gtpframe_pipe",
+						S_IRUSR, NULL, NULL,
+						&gtpframe_pipe_operations);
+	if (gtpframe_pipe_dir == NULL
+	    || gtpframe_pipe_dir == ERR_PTR(-ENODEV)) {
+		gtpframe_pipe_dir = NULL;
+		goto out;
+	}
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	gtp_modules_traceframe_info_need_get = 1;
+	gtp_modules_traceframe_info = NULL;
+	gtp_modules_traceframe_info_len = 0;
+	if (register_module_notifier(&gtp_modules_load_del_nb))
+		goto out;
+#endif
+
+	ret = gtp_var_special_add_all();
+	if (ret)
+		goto out;
+
+	ret = 0;
+out:
+	if (ret < 0)
+		gtp_exit();
+
+	return ret;
+}
+
+static void gtp_exit(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	unregister_module_notifier(&gtp_modules_load_del_nb);
+#endif
+
+#ifdef USE_PROC
+	remove_proc_entry("gtp", NULL);
+	remove_proc_entry("gtpframe", NULL);
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	remove_proc_entry("gtpframe_pipe", NULL);
+#endif
+#else
+	if (gtp_dir)
+		debugfs_remove(gtp_dir);
+	if (gtpframe_dir)
+		debugfs_remove(gtpframe_dir);
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gtpframe_pipe_dir)
+		debugfs_remove(gtpframe_pipe_dir);
+#endif
+#endif
+
+	gtp_gdbrsp_qtstop();
+	gtp_gdbrsp_qtinit();
+#ifdef GTP_RB
+	if (!GTP_RB_PAGE_IS_EMPTY)
+		gtp_rb_page_free();
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (gtp_frame) {
+#ifdef GTP_FRAME_SIMPLE
+		vfree(gtp_frame);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		ring_buffer_free(gtp_frame);
+#endif
+		gtp_frame = NULL;
+	}
+#endif
+
+	if (gtp_wq)
+		destroy_workqueue(gtp_wq);
+
+#ifdef GTP_RB
+	gtp_rb_release();
+#endif
+	gtp_var_release(1);
+
+#ifdef GTP_RB
+	if (gtp_traceframe_info)
+		vfree(gtp_traceframe_info);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	if (gtp_modules_traceframe_info)
+		vfree(gtp_modules_traceframe_info);
+#endif
+}
+
+module_init(gtp_init)
+module_exit(gtp_exit)
+
+MODULE_AUTHOR("Hui Zhu <teawater@gmail.com>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/lib/gtp.h
@@ -0,0 +1,144 @@
+#ifndef _GTP_PLUGIN_H_
+#define _GTP_PLUGIN_H_
+
+/* Follow part for ARCH.  */
+#ifdef CONFIG_X86
+#define ULONGEST		uint64_t
+#define LONGEST			int64_t
+#define CORE_ADDR		unsigned long
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+#define GTP_REGS_PC(regs)	((regs)->ip)
+#else
+#ifdef CONFIG_X86_32
+#define GTP_REGS_PC(regs)	((regs)->eip)
+#else
+#define GTP_REGS_PC(regs)	((regs)->rip)
+#endif
+#endif
+
+#ifdef CONFIG_X86_32
+#define GTP_REG_ASCII_SIZE	128
+#define GTP_REG_BIN_SIZE	64
+
+#define GTP_SP_NUM		4
+#define GTP_PC_NUM		8
+#else
+#define GTP_REG_ASCII_SIZE	296
+#define GTP_REG_BIN_SIZE	148
+
+#define GTP_SP_NUM		7
+#define GTP_PC_NUM		16
+#endif
+
+#define GTP_X86_NEED_ADJUST_PC(gts)	(!(gts)->step && !(gts)->hwb)
+#endif
+
+#ifdef CONFIG_MIPS
+#define ULONGEST		uint64_t
+#define LONGEST			int64_t
+#define CORE_ADDR		unsigned long
+
+#define GTP_REGS_PC(regs)	((regs)->cp0_epc)
+
+#ifdef CONFIG_32BIT
+#define GTP_REG_ASCII_SIZE	304
+#define GTP_REG_BIN_SIZE	152
+#else
+#define GTP_REG_ASCII_SIZE	608
+#define GTP_REG_BIN_SIZE	304
+#endif
+
+#define GTP_SP_NUM		29
+#define GTP_PC_NUM		37
+#endif
+
+#ifdef CONFIG_ARM
+#define ULONGEST		uint64_t
+#define LONGEST			int64_t
+#define CORE_ADDR		unsigned long
+
+#define GTP_REGS_PC(regs)	((regs)->uregs[15])
+
+#define GTP_REG_ASCII_SIZE	336
+#define GTP_REG_BIN_SIZE	168
+
+#define GTP_SP_NUM		13
+#define GTP_PC_NUM		15
+#endif
+
+struct gtp_var;
+
+struct gtp_trace_s {
+	struct gtp_entry		*tpe;
+	struct pt_regs			*regs;
+	long				(*read_memory)(void *dst,
+						       void *src,
+						       size_t size);
+#ifdef GTP_FRAME_SIMPLE
+	/* Next part set it to prev part.  */
+	char				**next;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	/* NULL means doesn't have head.  */
+	char				*next;
+#endif
+#ifdef GTP_RB
+	/* rb of current cpu.  */
+	struct gtp_rb_s			*next;
+	u64				id;
+#endif
+
+	/* Not 0 if this is step action.
+	   Its value is step number that need exec (include current step).
+	   For example, if a tracepoint have 1 step,
+	   its step action gts->step will be 1.  */
+	int				step;
+
+	struct kretprobe_instance	*ri;
+	int				*run;
+	struct timespec			xtime;
+
+	/* $watch_id will set to WATCH_TPE.  */
+	struct gtp_entry		*watch_tpe;
+	/* $watch_type will set to WATCH_TYPE.  */
+	int				watch_type;
+	/* $watch_size will set to WATCH_SIZE.  */
+	int				watch_size;
+	/* The return of $watch_start or $watch_stop.
+	   0 is success.  */
+	int				watch_start_ret;
+	int				watch_stop_ret;
+
+	/* If this is a session is for a hardware breakpoint.
+	   HWB point to the struct.
+	   If not, it will set to NULL.  */
+	struct gtp_hwb_s		*hwb;
+
+	int64_t				printk_tmp;
+	unsigned int			printk_level;
+	unsigned int			printk_format;
+	struct gtpsrc			*printk_str;
+};
+
+struct gtp_var_hooks {
+	int	(*gdb_set_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+			       int64_t val);
+	int	(*gdb_get_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+			       int64_t *val);
+	int	(*agent_set_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+				 int64_t val);
+	int	(*agent_get_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+				 int64_t *val);
+};
+
+extern int gtp_plugin_mod_register(struct module *mod);
+extern int gtp_plugin_mod_unregister(struct module *mod);
+
+extern struct gtp_var *gtp_plugin_var_add(char *name, int64_t val,
+					  struct gtp_var_hooks *hooks);
+extern int gtp_plugin_var_del(struct gtp_var *var);
+
+extern ULONGEST gtp_action_reg_read(struct gtp_trace_s *gts, int num);
+
+#endif /* _GTP_PLUGIN_H_ */
--- /dev/null
+++ b/lib/gtp_rb.c
@@ -0,0 +1,584 @@
+/*
+ * Ring buffer of kernel GDB tracepoint module.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright(C) KGTP team (https://code.google.com/p/kgtp/), 2011, 2012
+ *
+ */
+
+/* Following macros is for page of ring buffer.  */
+#define ADDR_SIZE		sizeof(size_t)
+#define GTP_RB_HEAD(addr)	((void *)((size_t)(addr) & PAGE_MASK))
+#define GTP_RB_DATA(addr)	(GTP_RB_HEAD(addr) + ADDR_SIZE)
+#define GTP_RB_END(addr)	(GTP_RB_HEAD(addr) + PAGE_SIZE - ADDR_SIZE)
+#define GTP_RB_PREV(addr)	(*(void **)GTP_RB_HEAD(addr))
+#define GTP_RB_NEXT(addr)	(*(void **)GTP_RB_END(addr))
+#define GTP_RB_DATA_MAX		(PAGE_SIZE - ADDR_SIZE - ADDR_SIZE - FID_SIZE \
+				 - sizeof(u64))
+
+struct gtp_rb_s {
+	spinlock_t	lock;
+
+	/* Pointer to the prev frame entry head.
+	   */
+	void		*prev_frame;
+
+	/* When write, this is the next address to be write.
+	   When read, this is the end of read.  */
+	void		*w;
+
+	/* When alloc memory from rb, record prev value W to PREV_W.
+	   When this memory doesn't need, set W back to PREV_W to release
+	   this memroy.  */
+	void		*prev_w;
+
+	/* Point to the begin of ring buffer.  Read will begin from R.  */
+	void		*r;
+
+	/* Point to the trace frame entry head of current read.  */
+	void		*rp;
+
+	/* This the id of rp point to.
+	   0 means rp doesn't point to a trace frame entry.
+	   So it need call gtp_rb_walk first.  */
+	u64		rp_id;
+
+	/* The cpu id.  */
+	int		cpu;
+};
+
+static struct gtp_rb_s __percpu	*gtp_rb;
+#if defined(CONFIG_ARM) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+static atomic_t				gtp_rb_count;
+#else
+static atomic64_t			gtp_rb_count;
+#endif
+static unsigned int		gtp_rb_page_count;
+static atomic_t			gtp_rb_discard_page_number;
+
+static int
+gtp_rb_init(void)
+{
+	int	cpu;
+
+	gtp_rb = alloc_percpu(struct gtp_rb_s);
+	if (!gtp_rb)
+		return -ENOMEM;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+		memset(rb, 0, sizeof(struct gtp_rb_s));
+		rb->lock = __SPIN_LOCK_UNLOCKED(rb->lock);
+		rb->cpu = cpu;
+	}
+	gtp_rb_page_count = 0;
+	atomic_set(&gtp_rb_discard_page_number, 0);
+
+	return 0;
+}
+
+static void
+gtp_rb_release(void)
+{
+	if (gtp_rb) {
+		free_percpu(gtp_rb);
+		gtp_rb = NULL;
+	}
+}
+
+static void
+gtp_rb_reset(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+		rb->w = GTP_RB_DATA(rb->w);
+		rb->r = rb->w;
+		rb->rp = NULL;
+		rb->rp_id = 0;
+		rb->prev_frame = NULL;
+	}
+
+#if defined(CONFIG_ARM) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+	atomic_set(&gtp_rb_count, 0);
+#else
+	atomic64_set(&gtp_rb_count, 0);
+#endif
+	atomic_set(&gtp_rb_discard_page_number, 0);
+}
+
+static inline u64
+gtp_rb_clock(void)
+{
+	u64	ret;
+
+re_inc:
+#if defined(CONFIG_ARM) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+	ret = (u64)atomic_inc_return(&gtp_rb_count);
+#else
+	ret = atomic64_inc_return(&gtp_rb_count);
+#endif
+	if (ret == 0)
+		goto re_inc;
+
+	return ret;
+}
+
+#define GTP_RB_PAGE_IS_EMPTY	(gtp_rb_page_count == 0)
+
+static int
+gtp_rb_page_alloc(int size)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+		void		*last = NULL, *next = NULL;
+		struct page	*page;
+		int		current_size;
+
+		gtp_rb_page_count = 0;
+		current_size = size;
+
+		while (1) {
+			if (current_size > 0)
+				current_size -= PAGE_SIZE;
+			else
+				break;
+
+			page = alloc_pages_node(cpu_to_node(cpu),
+						GFP_KERNEL, 0);
+			if (!page)
+				return -1;
+			gtp_rb_page_count++;
+			rb->w = GTP_RB_DATA(page_address(page));
+			GTP_RB_NEXT(rb->w) = next;
+			if (next)
+				GTP_RB_PREV(next) = rb->w;
+			next = rb->w;
+			if (!last)
+				last = rb->w;
+		}
+
+		GTP_RB_NEXT(last) = next;
+		GTP_RB_PREV(next) = last;
+		rb->r = rb->w;
+
+		if (gtp_rb_page_count < 3)
+			return -1;
+	}
+
+	return 0;
+}
+
+static void
+gtp_rb_page_free(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+		void		*need_free = NULL;
+		int		is_first = 1;
+
+		for (rb->r = rb->w = GTP_RB_DATA(rb->w);
+		     is_first || rb->w != rb->r;
+		     rb->w = GTP_RB_NEXT(rb->w)) {
+			if (need_free)
+				free_page((unsigned long)need_free);
+			need_free = GTP_RB_HEAD(rb->w);
+			is_first = 0;
+		}
+		if (need_free)
+			free_page((unsigned long)need_free);
+	}
+
+	gtp_rb_page_count = 0;
+}
+
+#define GTP_RB_LOCK(r)			spin_lock(&r->lock)
+#define GTP_RB_UNLOCK(r)		spin_unlock(&r->lock)
+#define GTP_RB_LOCK_IRQ(r, flags)	spin_lock_irqsave(&r->lock, flags)
+#define GTP_RB_UNLOCK_IRQ(r, flags)	spin_unlock_irqrestore(&r->lock, flags)
+#define GTP_RB_RELEASE(r)		(r->prev_w = r->w)
+
+static inline void *
+gtp_rb_prev_frame_get(struct gtp_rb_s *rb)
+{
+	return rb->prev_frame;
+}
+
+static inline void
+gtp_rb_prev_frame_set(struct gtp_rb_s *rb, void *prev_frame)
+{
+	rb->prev_frame = prev_frame;
+}
+
+static void *
+gtp_rb_alloc(struct gtp_rb_s *rb, size_t size, u64 id)
+{
+	void		*ret;
+
+	size = FRAME_ALIGN(size);
+
+	if (size > GTP_RB_DATA_MAX) {
+		printk(KERN_WARNING "gtp_rb_alloc: The size %zu is too big"
+				    "for the KGTP ring buffer.  "
+				    "The max size that KGTP ring buffer "
+				    "support is %lu (Need sub some size for "
+				    "inside structure).\n", size, GTP_RB_DATA_MAX);
+		return NULL;
+	}
+
+	rb->prev_w = rb->w;
+
+	if (rb->w + size > GTP_RB_END(rb->w)) {
+		/* Don't have enough size in current page, insert a
+		   FID_PAGE_END and try to get next page.  */
+		if (GTP_RB_END(rb->w) - rb->w >= FID_SIZE)
+			FID(rb->w) = FID_PAGE_END;
+
+		if (GTP_RB_HEAD(GTP_RB_NEXT(rb->w)) == GTP_RB_HEAD(rb->r)) {
+			if (gtp_circular) {
+				rb->r = GTP_RB_NEXT(rb->r);
+				atomic_inc(&gtp_rb_discard_page_number);
+			} else
+				return NULL;
+		}
+		rb->w = GTP_RB_NEXT(rb->w);
+
+		if (id) {
+			/* Need insert a FID_PAGE_BEGIN.  */
+			FID(rb->w) = FID_PAGE_BEGIN;
+			*((u64 *)(rb->w + FID_SIZE)) = id;
+			rb->w += FRAME_ALIGN(GTP_FRAME_PAGE_BEGIN_SIZE);
+		}
+	}
+
+	ret = rb->w;
+	rb->w += size;
+
+	return ret;
+}
+
+enum gtp_rb_walk_reason {
+	gtp_rb_walk_end = 0,
+	gtp_rb_walk_end_page,
+	gtp_rb_walk_end_entry,
+	gtp_rb_walk_new_entry,
+	gtp_rb_walk_type,
+	gtp_rb_walk_step,
+	gtp_rb_walk_error,
+};
+
+/* Check *end.  */
+#define GTP_RB_WALK_CHECK_END	0x1
+
+/* When to the end of a page, goto next one.  */
+#define GTP_RB_WALK_PASS_PAGE	0x2
+
+/* When to the end of a entry, goto next one.
+   If not set, stop in the first address of next entry and
+   set S->REASON to gtp_rb_walk_new_entry.  */
+#define GTP_RB_WALK_PASS_ENTRY	0x4
+
+/* Check with id and FID_PAGE_BEGIN to make sure this is the current frame.  */
+#define GTP_RB_WALK_CHECK_ID	0x8
+
+/* Return and set S->REASON to gtp_rb_walk_type if type is same entry type.  */
+#define GTP_RB_WALK_CHECK_TYPE	0x10
+
+/* Walk STEP step in ring_buffer, just record FID_REG, FID_MEM, FID_VAR.  */
+#define GTP_RB_WALK_STEP	0x20
+
+struct gtp_rb_walk_s {
+	unsigned int		flags;
+
+	/* Reason for return.  */
+	enum gtp_rb_walk_reason	reason;
+
+	/* GTP_RB_WALK_CHECK_END,
+	   it will point to the end of this ring buffer.  */
+	void			*end;
+
+	/* GTP_RB_WALK_CHECK_ID */
+	u64			id;
+
+	/* GTP_RB_WALK_CHECK_TYPE */
+	FID_TYPE		type;
+
+	/* GTP_RB_WALK_STEP */
+	int			step;
+};
+
+/* Walk in ring buffer RET according to S.  And return the new pointer.  */
+
+static void *
+gtp_rb_walk(struct gtp_rb_walk_s *s, void *ret)
+{
+	int	step;
+	void	*page_end = GTP_RB_END(ret);
+
+	if (s->flags & GTP_RB_WALK_STEP)
+		step = 0;
+
+	while (1) {
+		FID_TYPE	fid;
+
+		if ((s->flags & GTP_RB_WALK_CHECK_END) && ret == s->end) {
+			s->reason = gtp_rb_walk_end;
+			break;
+		}
+
+		if (ret == page_end || page_end - ret < FID_SIZE
+		    || FID(ret) == FID_PAGE_END) {
+			if (!(s->flags & GTP_RB_WALK_PASS_PAGE)) {
+				s->reason = gtp_rb_walk_end_page;
+				break;
+			}
+			ret = GTP_RB_NEXT(ret);
+			page_end = GTP_RB_END(ret);
+			continue;
+		}
+
+		fid = FID(ret);
+
+		if ((s->flags & GTP_RB_WALK_CHECK_TYPE) && s->type == fid) {
+			s->reason = gtp_rb_walk_type;
+			break;
+		}
+
+		if ((s->flags & GTP_RB_WALK_STEP)
+		    && (fid == FID_REG || fid == FID_MEM || fid == FID_VAR)) {
+			if (step >= s->step) {
+				s->reason = gtp_rb_walk_step;
+				break;
+			}
+			step++;
+		}
+
+		switch (fid) {
+		case FID_HEAD:
+			if (!(s->flags & GTP_RB_WALK_PASS_ENTRY)) {
+				s->reason = gtp_rb_walk_new_entry;
+				goto out;
+			}
+			ret += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+			break;
+		case FID_REG:
+			ret += FRAME_ALIGN(GTP_FRAME_REG_SIZE);
+			break;
+		case FID_MEM: {
+				struct gtp_frame_mem	*gfm;
+
+				gfm = (struct gtp_frame_mem *) (ret + FID_SIZE);
+				ret += FRAME_ALIGN(GTP_FRAME_MEM_SIZE
+						   + gfm->size);
+			}
+			break;
+		case FID_VAR:
+			ret += FRAME_ALIGN(GTP_FRAME_VAR_SIZE);
+			break;
+		case FID_PAGE_BEGIN:
+			if ((s->flags & GTP_RB_WALK_CHECK_ID)
+			    && s->id != *(u64 *)(ret + FID_SIZE)) {
+				s->reason = gtp_rb_walk_end_entry;
+				goto out;
+			}
+			ret += FRAME_ALIGN(GTP_FRAME_PAGE_BEGIN_SIZE);
+			break;
+		default:
+			printk(KERN_WARNING
+			       "Walk in gtp ring buffer got error id 0x%x "
+			       "in 0x%p.\n",
+			       fid, ret);
+			s->reason = gtp_rb_walk_error;
+			goto out;
+			break;
+		}
+	}
+
+out:
+	return ret;
+}
+
+static void *
+gtp_rb_walk_reverse(void *buf, void *begin)
+{
+	if (buf == begin)
+		return NULL;
+	buf = *(void **)(buf + FID_SIZE + sizeof(u64) + sizeof(ULONGEST));
+
+	return buf;
+}
+
+static struct gtp_rb_s	*gtp_frame_current_rb;
+static u64		gtp_frame_current_id;
+static struct pt_regs	*gtp_frame_current_regs;
+
+static void
+gtp_rb_read_reset(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+
+		rb->rp = rb->r;
+		rb->rp_id = 0;
+	}
+	gtp_frame_current_num = -1;
+	gtp_frame_current_rb = NULL;
+}
+
+static void
+gtp_rb_update_gtp_frame_current(void)
+{
+	gtp_frame_current_id = *(u64 *)(gtp_frame_current_rb->rp + FID_SIZE);
+	gtp_frame_current_tpe = *(ULONGEST *)(gtp_frame_current_rb->rp
+					      + FID_SIZE + sizeof(u64));
+	gtp_frame_current_rb->rp += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+	gtp_frame_current_regs = NULL;
+}
+
+static int
+gtp_rb_read(void)
+{
+	int			cpu;
+	u64			min_id = ULLONG_MAX;
+	struct gtp_rb_walk_s	rbws;
+
+	gtp_frame_current_rb = NULL;
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+
+		if (rb->rp == NULL)
+			rb->rp = rb->r;
+
+		if (rb->rp_id == 0) {
+			rbws.end = rb->w;
+			rb->rp = gtp_rb_walk(&rbws, rb->rp);
+			if (rbws.reason != gtp_rb_walk_new_entry)
+				continue;
+			rb->rp_id = *(u64 *)(rb->rp + FID_SIZE);
+		}
+		if (rb->rp_id < min_id) {
+			min_id = rb->rp_id;
+			gtp_frame_current_rb = rb;
+		}
+	}
+
+	if (gtp_frame_current_rb == NULL) {
+		gtp_rb_read_reset();
+		return -1;
+	}
+
+	gtp_frame_current_rb->rp_id = 0;
+	gtp_rb_update_gtp_frame_current();
+	gtp_frame_current_num += 1;
+
+	return 0;
+}
+
+static void *
+gtp_rb_get_page(struct gtp_rb_s *rb)
+{
+	void		*ret = NULL;
+	unsigned long	flags;
+
+	GTP_RB_LOCK_IRQ(rb, flags);
+
+	if (GTP_RB_HEAD(rb->r) == GTP_RB_HEAD(rb->w)) {
+		if (rb->r == rb->w)
+			goto out;
+		/* Move rb->w to next page.  */
+		if (GTP_RB_END(rb->w) - rb->w >= FID_SIZE)
+			FID(rb->w) = FID_PAGE_END;
+		rb->w = GTP_RB_NEXT(rb->w);
+	}
+
+	ret = rb->r;
+	{
+		/* Move this page out of ring.  */
+		void	*prev = GTP_RB_PREV(rb->r);
+		void	*next = GTP_RB_NEXT(rb->r);
+
+		GTP_RB_NEXT(prev) = next;
+		GTP_RB_PREV(next) = prev;
+		rb->r = next;
+	}
+
+out:
+	GTP_RB_UNLOCK_IRQ(rb, flags);
+	return ret;
+}
+
+static void
+gtp_rb_put_page(struct gtp_rb_s *rb, void *page, int page_is_empty)
+{
+	void	*prev, *next;
+	unsigned long	flags;
+
+	GTP_RB_LOCK_IRQ(rb, flags);
+
+	if (page_is_empty) {
+		page = GTP_RB_DATA(page);
+		if (rb->w == GTP_RB_DATA(rb->w)) {
+			/* Set page before rb->w and set it as rb->w.
+			   If need, set it as rb->r.  */
+			prev = GTP_RB_PREV(rb->w);
+			next = rb->w;
+			if (rb->r == rb->w)
+				rb->r = page;
+			rb->w = page;
+		} else {
+			/* Set page after rb->w.  */
+			prev = GTP_RB_DATA(rb->w);
+			next = GTP_RB_NEXT(rb->w);
+		}
+	} else {
+		if (rb->r == GTP_RB_DATA(rb->r)) {
+			/* Current rb->r page is point to the begin of a page.
+			   Set page before rb->r and set it as rb->r.  */
+			prev = GTP_RB_PREV(rb->r);
+			next = rb->r;
+		} else {
+			/* Current rb->r page is not point to the begin of a
+			   page, give up this data.
+			   Set page after rb->r and set it as rb->r.  */
+			prev = GTP_RB_DATA(rb->r);
+			next = GTP_RB_NEXT(rb->r);
+		}
+		rb->r = page;
+	}
+
+	GTP_RB_NEXT(prev) = GTP_RB_DATA(page);
+	GTP_RB_PREV(next) = GTP_RB_DATA(page);
+	GTP_RB_PREV(page) = prev;
+	GTP_RB_NEXT(page) = next;
+
+	GTP_RB_UNLOCK_IRQ(rb, flags);
+}
--- /dev/null
+++ b/scripts/gtp/add-ons/hotcode.py
@@ -0,0 +1,745 @@
+#!/usr/bin/python
+
+# This script is used to find the hotcode in some tasks
+# GPL
+# Copyright(C) Hui Zhu (teawater@gmail.com), 2012
+
+import gdb
+import tempfile
+import os
+import signal
+import sys
+import traceback
+import time
+
+class hotcode_list:
+	def __init__(self):
+		self.function_list = {}
+		self.file_list = {}
+		self.line_list = {}
+		self.function_list_line = {}
+		self.file_list_line = {}
+		self.num = 0
+
+class task:
+	def __init__(self, fid, user_dir):
+		self.fid = fid
+		self.user_dir = user_dir
+		self.kernel = hotcode_list()
+		self.user = hotcode_list()
+
+debug_dir = "/usr/lib/debug/"
+task_list = {}
+no_task = False
+kernel_hotcode_list = hotcode_list()
+
+output_html = True
+output_html_file = "./hotcode.html"
+show_line_number_default = 20
+show_line_number = show_line_number_default
+
+#--------------------------------------------------------------------------------------------------
+#For signal handler
+
+from operator import itemgetter
+def dict_sort(d, reverse=False):
+	#proposed in PEP 265, using  the itemgetter
+	return sorted(d.iteritems(), key=itemgetter(1), reverse=True)
+
+def hotcode_show_code_list(string, code_list):
+	if len(code_list) > 0:
+		print "\t", string
+		i = 1
+		for c in dict_sort(code_list):
+			print "\t", c[0], "\t\t", c[1]
+			i += 1
+			if i > show_line_number:
+				break
+		print
+
+def hotcode_show():
+	if no_task:
+		hotcode_show_code_list("Hotest function", kernel_hotcode_list.function_list)
+		hotcode_show_code_list("Hotest file", kernel_hotcode_list.file_list)
+		hotcode_show_code_list("Hotest line", kernel_hotcode_list.line_list)
+	else:
+		for pid in task_list:
+			print "task", str(pid), task_list[pid].user_dir
+			print "Kernel hotcode:"
+			hotcode_show_code_list("Hotest function", task_list[pid].kernel.function_list)
+			hotcode_show_code_list("Hotest file", task_list[pid].kernel.file_list)
+			hotcode_show_code_list("Hotest line", task_list[pid].kernel.line_list)
+			print "User hotcode:"
+			hotcode_show_code_list("Hotest function", task_list[pid].user.function_list)
+			hotcode_show_code_list("Hotest file", task_list[pid].user.file_list)
+			hotcode_show_code_list("Hotest line", task_list[pid].user.line_list)
+			print
+
+html_id = 0
+
+def hotcode_list_to_output_html_fd_1(llist, tlist, fd):
+	global html_id
+	i = 1
+	for c in dict_sort(llist):
+		if tlist != None:
+			fd.write('''<tr><td onclick='sh("'''+str(html_id)+'''");'>'''+str(c[0])+'''</td><td style=" width: 10%; text-align: right;">'''+str(c[1])+'''</td></tr>''')
+			fd.write('''<tr><td style="text-align: center; display: none;" colspan="2" id="''' + str(html_id) + '''"><table style="width: 100%;" border="1" cellpadding="0" cellspacing="0"><tbody>''')
+			for d in dict_sort(tlist[c[0]]):
+				fd.write("<tr><td>" + str(d[0]) + '''</td><td style=" width: 10%; text-align: right;">''' + str(d[1]) + "</td></tr>")
+			fd.write('</tbody></table>')
+		else:
+			fd.write('<tr><td>'+str(c[0])+'''</td><td style=" width: 10%; text-align: right;">'''+str(c[1])+'''</td></tr>''')
+		i += 1
+		html_id += 1
+		if i > show_line_number:
+			break
+
+def hotcode_list_to_output_html_fd(hlist, fd):
+	global html_id
+	fd.write('''<tr><td style="text-align: center;" colspan="2">Hot functions list</td></tr>''')
+	hotcode_list_to_output_html_fd_1(hlist.function_list, hlist.function_list_line, fd)
+
+	fd.write('''<tr><td style="text-align: center;" colspan="2">Hot file list</td></tr>''')
+	hotcode_list_to_output_html_fd_1(hlist.file_list, hlist.file_list_line, fd)
+
+	fd.write('''<tr><td style="text-align: center;" colspan="2">Hot line list</td></tr>''')
+	hotcode_list_to_output_html_fd_1(hlist.line_list, None, fd)
+
+def hotcode_to_output_html_file():
+	global html_id
+	html_id = 0
+	fd = open(output_html_file, "w")
+	fd.write('''
+<html><head><title>Hotcode</title>
+<script>
+<!--
+function sh(id)
+{
+	if(document.getElementById(id).style.display=='none') {
+		document.getElementById(id).style.display='block';
+	}
+	else {
+		document.getElementById(id).style.display='none';
+	}
+}
+-->
+</script></head>
+<body>
+<div style="text-align: center;">This file is generated by KGTP (<a href="http://code.google.com/p/kgtp/">http://code.google.com/p/kgtp/</a>) in ''' + time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) + '''.</div>
+<div style="text-align: center;">Click the function name or file name to see the detailed info.</div>''')
+	if show_line_number > 0:
+		fd.write('''<div style="text-align: center;">Just show top 20 of each list.</div>''')
+	if no_task:
+		fd.write('<br><br>')
+		fd.write('''<table style="margin-left: auto; margin-right: auto;" border="1" cellpadding="2" cellspacing="0"><tbody>''')
+		fd.write('''<tr><td><strong>Kernel space hotcode list</strong></td><td style=" width: 10%; text-align: right;">'''+str(kernel_hotcode_list.num)+'''</td></tr>''')
+		hotcode_list_to_output_html_fd(kernel_hotcode_list, fd)
+		fd.write('</tbody></table>')
+	else:
+		for pid in task_list:
+			fd.write('<br><br>')
+			fd.write('''<table style="margin-left: auto; margin-right: auto;" border="1" cellpadding="2" cellspacing="0"><tbody>''')
+			fd.write('''<tr><td style="text-align: center;" colspan="2">pid:''' + str(pid) + " " + task_list[pid].user_dir + "</td></tr>")
+			if trace_user:
+				fd.write('''<tr><td style="text-align: center;" colspan="2">User space hotcode list </td></tr>''')
+				fd.write('''<tr><td><strong>User space hotcode list</strong></td><td style=" width: 10%; text-align: right;">'''+str(task_list[pid].user.num)+'''</td></tr>''')
+				hotcode_list_to_output_html_fd(task_list[pid].user, fd)
+			if trace_kernel:
+				if trace_user:
+					fd.write('''<tr><td style="text-align: center;" colspan="2"></td></tr>''')
+				fd.write('''<tr><td><strong>Kernel space hotcode list</strong></td><td style=" width: 10%; text-align: right;">'''+str(task_list[pid].kernel.num)+'''</td></tr>''')
+				hotcode_list_to_output_html_fd(task_list[pid].kernel, fd)
+			fd.write('</tbody></table>')
+	fd.write('</body></html>')
+	fd.close()
+	print "Save", html_id, "entries."
+
+def sigint_handler(num, e):
+	if output_html:
+		hotcode_to_output_html_file()
+	else:
+		hotcode_show()
+	try:
+		s = raw_input('Conitnue? [(y)es], (n)o:')
+	except:
+		s = 'y'
+	finally:
+		if s[0:1] != 'n' and s[0:1] != 'N':
+			return;
+	#gdb.execute("inferior 1")
+	try:
+		gdb.execute("tfind -1", True, False)
+		gdb.execute("target remote /sys/kernel/debug/gtp", True, False)
+		gdb.execute("set disconnected-tracing off", True, False)
+	except:
+		print "Try to stop GTP got error, please use command \"sudo rmmod gtp.ko\" stop it."
+	exit(1);
+#--------------------------------------------------------------------------------------------------
+#init
+
+def add_inferior():
+	fid = gdb.execute("add-inferior", False, True)
+	if fid.find("Added inferior ") != 0:
+		return -1
+	fid = int(fid[len("Added inferior "):])
+	return fid
+
+gdb.execute("set target-async on", True, False)
+gdb.execute("set pagination off", True, False)
+gdb.execute("set confirm off", True, False)
+gdb.execute("set circular-trace-buffer on", True, False)
+gdb.execute("set debug-file-directory "+debug_dir, True, False)
+try:
+	gdb.execute("kill", True, False)
+except:
+	pass
+
+trace_user = True
+trace_kernel = True
+while 1:
+	tmp = "both"
+	try:
+		tmp = raw_input('Which part of code you want trace? [(b)oth], (u)ser, (k)ernel:')
+	except:
+		continue
+	if tmp[0:1] == 'U' or tmp[0:1] == 'u':
+		trace_kernel = False
+	elif tmp[0:1] == 'K' or tmp[0:1] == 'k':
+		trace_user = False
+	break
+
+#Get which task pid why want to trace
+print("Please input the pid of task that you want to trace - one per line.")
+print("If not set any task, will trace all code in the Linux kernel.")
+while 1:
+	pid = -1
+	try:
+		pid = input('task pid (use empty to stop pid input):')
+	except:
+		pass
+	if pid <= 0:
+		break
+	if pid in task_list:
+		print("This pid already in the list.")
+		continue
+	user_dir = ""
+	fid = 0
+	if trace_user:
+		try:
+			orig_user_dir = user_dir = os.path.realpath("/proc/"+str(pid)+"/exe")
+		except:
+			#maybe this is the kernel task
+			print "Cannot get the user code info of this pid, will not parse the user level code symbol"
+			task_list[pid] = task(fid, user_dir)
+			continue
+		if os.path.exists(debug_dir+user_dir):
+			user_dir = debug_dir+user_dir
+		while 1:
+			tmp = ""
+			try:
+				tmp = raw_input('Please input the debug binary of task if you want to change it ['+user_dir+']:')
+			except:
+				continue
+			if tmp != "":
+				user_dir = os.path.realpath(tmp)
+			break
+		if not os.path.exists(user_dir):
+			print "Cannot get the user code info of this pid, will not parse the user level code symbol"
+			task_list[pid] = task(fid, user_dir)
+			continue
+		print "Use "+user_dir+" as debug binary."
+		fid = add_inferior()
+		if fid < 0:
+			print "Try to load task got error."
+			continue
+		gdb.execute("inferior "+str(fid))
+		pfile = open("/proc/"+str(pid)+"/maps", "r")
+		tmplist = pfile.read().split(os.linesep)
+		pfile.close()
+		for c in tmplist:
+			c_list = c.split(" ")
+			filename = c_list[-1].strip()
+			if filename != orig_user_dir and os.path.exists(filename) and len(c_list) > 2 and len(c_list[1]) > 3 and c_list[1][2] == 'x':
+				addr = "0x"+c_list[0][0:c.find('-')]
+				gdb.execute("file "+filename)
+				info_files = gdb.execute("info files", True, True)
+				info_files_list = info_files.split(os.linesep)
+				text_offset = "0x0"
+				for line in info_files_list:
+					line_list = line.split(" is ")
+					if len(line_list) == 2 and line_list[1].strip() == ".text":
+						line_list[0] = line_list[0].strip()
+						text_offset = line_list[0][0:line_list[0].find(' - ')]
+				print ("add-symbol-file "+filename+" ("+addr+"+"+text_offset+")")
+				gdb.execute("add-symbol-file "+filename+" ("+addr+"+"+text_offset+")")
+		gdb.execute("file "+user_dir)
+		gdb.execute("inferior 1")
+	task_list[pid] = task(fid, user_dir)
+
+def get_addr_range_list(fun):
+	buf = gdb.execute("info line "+fun, False, True)
+	line_list = buf.split(os.linesep)
+	ret = []
+	begin = -1
+	end = -1
+	for line in line_list:
+		addr_begin = line.find("starts at address ")
+		if addr_begin >= 0:
+			line = line[addr_begin + len("starts at address "):]
+			addr_end = line.find(" <"+fun)
+			if addr_end >= 0:
+				begin = int(line[:addr_end], 0)
+				line = line[addr_end + len(" <"+fun):]
+		addr_begin = line.find("ends at ")
+		if addr_begin >= 0:
+			line = line[addr_begin + len("ends at "):]
+			addr_end = line.find(" <"+fun)
+			if addr_end > 0:
+				end = int(line[:addr_end], 0)
+				if begin != -1:
+					ret.append([begin, end])
+				begin = -1
+				end = -1
+
+	if len(ret) > 0:
+		buf = gdb.execute("disassemble "+fun, False, True)
+		line_list = buf.split(os.linesep)
+		line_list.reverse()
+		end = 0
+		for line in line_list:
+			addr_begin = line.find("0x")
+			if addr_begin >= 0:
+				line = line[addr_begin:]
+				addr_end = line.find(" <+")
+				if addr_end > 0:
+					end = int(line[:addr_end], 0) + 1
+					break
+		if end != 0:
+			offset = 0
+			for c in ret:
+				if c[1] < end:
+					if offset == 0 or offset > (end - c[1]):
+						offset = end - c[1]
+			for c in ret:
+				c[1] += offset
+
+	return ret
+
+def get_ignore_str(function):
+	ret = ""
+	try:
+		s = raw_input('Do you want to ignore function \"'+function+'\"? [(y)es], (n)o:')
+	except:
+		s = 'y'
+	if s[0:1] != 'n' and s[0:1] != 'N':
+		r_list = get_addr_range_list(function)
+		for r in r_list:
+			if ret != "":
+				ret += " && "
+			else:
+				ret += "&& ("
+			#(regs->ip < r[0] || regs->ip > r[1])
+			ret += "($p_ip < "+str(r[0])+" || $p_ip > "+str(r[1])+")"
+		if ret != "":
+			ret += ")"
+	return ret
+
+if len(task_list) == 0:
+	trace_user = False
+	trace_kernel = True
+	no_task = True
+
+try:
+	s = raw_input('Which way you want to output hotcode info when ctrl-c? [(h)tml], (t)ty:')
+except:
+	s = 'h'
+if s[0:1] == 't' or s[0:1] == 'T':
+	output_html = False
+else:
+	output_html = True
+
+if output_html:
+	while 1:
+		try:
+			s = raw_input('Which file you want to save the html output? [' + output_html_file + ']:')
+			if os.path.exists(s):
+				if os.path.isfile(s):
+					s = raw_input('File ' + s +' exist, do you want to over write it? (y)es, [(n)o]:')
+					if s[0:1] != 'y' and s[0:1] != 'Y':
+						continue
+				else:
+					print 'File ' + s +' exist, but it cannot be written.  Please choice another file.'
+					continue
+		except:
+			continue
+		if len(s) > 0:
+			output_html_file = s
+		break
+
+try:
+	show_line_number = input('Show line number (0 meas all)? ['+str(show_line_number)+']:')
+except:
+	show_line_number = show_line_number_default
+
+#Set tracepoint
+gdb.execute("target remote /sys/kernel/debug/gtp", True, False)
+
+try:
+	gdb.execute("tstop", True, False)
+	gdb.execute("delete", True, False)
+except:
+	pass
+
+
+def getmod():
+	#following code is get from ../getmod.py
+	#use the code directly because sys.argv = [''] inside GDB
+	def format_file(name):
+		tmp = ""
+		for c in name:
+			if c == "_":
+				c = "-"
+			tmp += c
+		return tmp
+
+	#Check if the target is available
+	if str(gdb.selected_thread()) == "None":
+		raise gdb.error("Please connect to Linux Kernel before use the script.")
+
+	#Output the help
+	print "Use GDB command \"set $mod_search_dir=dir\" to set an directory for search the modules."
+
+	ignore_gtp_ko = gdb.parse_and_eval("$ignore_gtp_ko")
+	if ignore_gtp_ko.type.code == gdb.TYPE_CODE_INT:
+		ignore_gtp_ko = int(ignore_gtp_ko)
+	else:
+		ignore_gtp_ko = 1
+
+	#Get the mod_search_dir
+	mod_search_dir_list = []
+	#Get dir from $mod_search_dir
+	tmp_dir = gdb.parse_and_eval("$mod_search_dir")
+	if tmp_dir.type.code == gdb.TYPE_CODE_ARRAY:
+		tmp_dir = str(tmp_dir)
+		tmp_dir = tmp_dir[1:len(tmp_dir)]
+		tmp_dir = tmp_dir[0:tmp_dir.index("\"")]
+		mod_search_dir_list.append(tmp_dir)
+	#Get dir that same with current vmlinux
+	tmp_dir = str(gdb.execute("info files", False, True))
+	tmp_dir = tmp_dir[tmp_dir.index("Symbols from \"")+len("Symbols from \""):len(tmp_dir)]
+	tmp_dir = tmp_dir[0:tmp_dir.index("\"")]
+	tmp_dir = tmp_dir[0:tmp_dir.rindex("/")]
+	mod_search_dir_list.append(tmp_dir)
+	#Get the dir of current Kernel
+	tmp_dir = "/lib/modules/" + str(os.uname()[2])
+	if os.path.isdir(tmp_dir):
+		mod_search_dir_list.append(tmp_dir)
+	#Let user choice dir
+	mod_search_dir = ""
+	while mod_search_dir == "":
+		for i in range(0, len(mod_search_dir_list)):
+			print str(i)+". "+mod_search_dir_list[i]
+		try:
+			s = input('Select a directory for search the modules [0]:')
+		except SyntaxError:
+			s = 0
+		except:
+			continue
+		if s < 0 or s >= len(mod_search_dir_list):
+			continue
+		mod_search_dir = mod_search_dir_list[s]
+
+	mod_list_offset = long(gdb.parse_and_eval("((size_t) &(((struct module *)0)->list))"))
+	mod_list = long(gdb.parse_and_eval("(&modules)"))
+	mod_list_current = mod_list
+
+	while 1:
+		mod_list_current = long(gdb.parse_and_eval("((struct list_head *) "+str(mod_list_current)+")->next"))
+
+		#check if need break the loop
+		if mod_list == mod_list_current:
+			break
+
+		mod = mod_list_current - mod_list_offset
+
+		#get mod_name
+		mod_name = str(gdb.parse_and_eval("((struct module *)"+str(mod)+")->name"))
+		mod_name = mod_name[mod_name.index("\"")+1:len(mod_name)]
+		mod_name = mod_name[0:mod_name.index("\"")]
+		if mod_name == "fglrx":
+			contiue
+		mod_name += ".ko"
+		mod_name = format_file(mod_name)
+
+		#get mod_dir_name
+		mod_dir_name = ""
+		for root, dirs, files in os.walk(mod_search_dir):
+			for afile in files:
+				tmp_file = format_file(afile)
+				if tmp_file == mod_name:
+					mod_dir_name = os.path.join(root,afile)
+					break
+			if mod_dir_name != "":
+				break
+
+		command = " "
+
+		#Add module_core to command
+		command += str(gdb.parse_and_eval("((struct module *)"+str(mod)+")->module_core"))
+
+		#Add each sect_attrs->attrs to command
+		#get nsections
+		nsections = int(gdb.parse_and_eval("((struct module *)"+str(mod)+")->sect_attrs->nsections"))
+		sect_attrs = long(gdb.parse_and_eval("(u64)((struct module *)"+str(mod)+")->sect_attrs"))
+		for i in range(0, nsections):
+			command += " -s"
+			tmp = str(gdb.parse_and_eval("((struct module_sect_attrs *)"+str(sect_attrs)+")->attrs["+str(i)+"].name"))
+			tmp = tmp[tmp.index("\"")+1:len(tmp)]
+			tmp = tmp[0:tmp.index("\"")]
+			command += " "+tmp
+			tmp = str(gdb.parse_and_eval("((struct module_sect_attrs *)"+str(sect_attrs)+")->attrs["+str(i)+"].address"))
+			command += " "+tmp
+
+		if mod_dir_name == "":
+			print "Cannot find out",mod_name,"from directory."
+			print "Please use following command load the symbols from it:"
+			print "add-symbol-file some_dir/"+mod_name+command
+		else:
+			if ignore_gtp_ko and mod_name == "gtp.ko":
+				pass
+			else:
+				#print "add-symbol-file "+mod_dir_name+command
+				gdb.execute("add-symbol-file "+mod_dir_name+command, False, False)
+
+if trace_kernel:
+	try:
+		s = raw_input('Do you load the symbol from LKM? (y)es, [(n)o]:')
+	except:
+		s = 'n'
+	if s[0:1] == 'y' or s[0:1] == 'Y':
+		getmod()
+
+cpu_number = int(gdb.parse_and_eval("$cpu_number"))
+tempfilename = tempfile.mktemp()
+tempfile = open(tempfilename, "w")
+if no_task:
+	ignore_str = ""
+	#Setup first tracepoint
+	ignore_str += get_ignore_str("arch_local_irq_enable")
+	ignore_str += get_ignore_str("intel_idle")
+	# GDB have bug with long conditon so close them
+	#ignore_str += get_ignore_str("__do_softirq")
+	#ignore_str += get_ignore_str("_raw_spin_unlock_irqrestore")
+
+	tempfile.write("tvariable $p_ip\n")
+	tempfile.write("tvariable $p_cs\n")
+	tempfile.write("trace handle_irq\n")
+	tempfile.write("commands\n")
+	tempfile.write("teval $p_ip=(u64)regs->ip\n")
+	tempfile.write("teval $p_cs=(u64)regs->cs\n")
+	tempfile.write("end\n")
+	#Setup second tracepoint
+	tempfile.write("trace handle_irq\n")
+	cond_str = " (($p_cs & 3) == 0)"
+	tempfile.write("condition $bpnum "+cond_str+ignore_str+"\n")
+	tempfile.write("commands\n")
+	tempfile.write("collect $no_self_trace\n")
+	tempfile.write("collect $p_ip\n")
+	tempfile.write("end\n")
+	tempfile.write("trace smp_apic_timer_interrupt\n")
+	tempfile.write("commands\n")
+	tempfile.write("teval $p_ip=(u64)regs->ip\n")
+	tempfile.write("teval $p_cs=(u64)regs->cs\n")
+	tempfile.write("end\n")
+	#Setup second tracepoint
+	tempfile.write("trace smp_apic_timer_interrupt\n")
+	cond_str = " (($p_cs & 3) == 0)"
+	tempfile.write("condition $bpnum "+cond_str+ignore_str+"\n")
+	tempfile.write("commands\n")
+	tempfile.write("collect $no_self_trace\n")
+	tempfile.write("collect $p_ip\n")
+	tempfile.write("end\n")
+else:
+	pid_str = ""
+	for pid in task_list:
+		if pid_str != "":
+			pid_str += " || "
+		else:
+			pid_str += "("
+		pid_str += "($current_task_pid == "+str(pid)+") "
+	if pid_str != "":
+		pid_str += ")"
+	cond_str = ""
+	if not trace_user:
+		if pid_str != "":
+			cond_str += " && "
+		cond_str += " ((regs->cs & 3) == 0)"
+	elif not trace_kernel:
+		if pid_str != "":
+			cond_str += "&&"
+		cond_str += " ((regs->cs & 3) == 3)"
+	tempfile.write("trace handle_irq\n")
+	tempfile.write("condition $bpnum "+pid_str+cond_str+"\n")
+	tempfile.write("commands\n")
+	tempfile.write("collect regs->ip\n")
+	if trace_user and trace_kernel:
+		tempfile.write("collect regs->cs\n")
+	tempfile.write("collect $current_task_pid\n")
+	tempfile.write("end\n")
+	tempfile.write("trace smp_apic_timer_interrupt\n")
+	tempfile.write("condition $bpnum "+pid_str+cond_str+"\n")
+	tempfile.write("commands\n")
+	tempfile.write("collect regs->ip\n")
+	if trace_user and trace_kernel:
+		tempfile.write("collect regs->cs\n")
+	tempfile.write("collect $current_task_pid\n")
+	tempfile.write("end\n")
+tempfile.close()
+tempfile = open(tempfilename, "r")
+print "Tracepoint command:"
+print tempfile.read()
+tempfile.close()
+gdb.execute("source "+tempfilename, True, False)
+os.remove(tempfilename)
+gdb.execute("set disconnected-tracing on", True, False)
+gdb.execute("tstart")
+gdb.execute("kill", True, False)
+
+signal.signal(signal.SIGINT, sigint_handler);
+signal.siginterrupt(signal.SIGINT, False);
+
+#Connect to pipe
+gdb.execute("target tfile /sys/kernel/debug/gtpframe_pipe")
+
+#--------------------------------------------------------------------------------------------------
+#cycle
+
+def add_line_to_list(line, line_list):
+	if line in line_list:
+		line_list[line] += 1
+	else:
+		line_list[line] = 1
+
+#info[0] line_num, info[1] file_name, info[2] function_name
+def add_info_to_code_list(info, code_list):
+	line = str(info[1]) + ":" + str(info[0])
+	#function_list
+	if info[2] in code_list.function_list:
+		code_list.function_list[info[2]] += 1
+	else:
+		code_list.function_list[info[2]] = 1
+		code_list.function_list_line[info[2]] = {}
+	add_line_to_list(line, code_list.function_list_line[info[2]])
+	#file_list
+	if info[1] in code_list.file_list:
+		code_list.file_list[info[1]] += 1
+	else:
+		code_list.file_list[info[1]] = 1
+		code_list.file_list_line[info[1]] = {}
+	add_line_to_list(line, code_list.file_list_line[info[1]])
+	#line_list
+	add_line_to_list(line, code_list.line_list)
+	#num
+	code_list.num += 1
+
+def task_list_add_line(is_user, pid, info):
+	global task_list
+	if no_task:
+		add_info_to_code_list (info, kernel_hotcode_list)
+	else:
+		if is_user:
+			add_info_to_code_list (info, task_list[pid].user)
+		else:
+			add_info_to_code_list (info, task_list[pid].kernel)
+
+def get_line_from_sym(sym):
+	sym = sym.rstrip(os.linesep)
+
+	#Get line_num and file_name
+	begin = sym.find("Line ")
+	end = sym.find("\" starts at address")
+	line_num = None
+	file_name = None
+	if begin >= 0 and end > 0 and begin + len("Line ") < end:
+		line = sym[begin + len("Line "):end]
+		line = line.split(" of \"")
+		if len(line) == 2:
+			line_num = line[0]
+			file_name = line[1]
+		sym = sym[end:]
+
+	#Get function_name
+	begin = sym.find("<")
+	end = sym.find(">")
+	if begin >= 0 and end > 0 and begin + 1 < end:
+		function_name = sym[begin + 1:end]
+		end = function_name.rfind("+")
+		if end > 0:
+			function_name = function_name[:end]
+		sym = gdb.execute("info symbol "+function_name, True, True).rstrip(os.linesep)
+		begin = sym.rfind(" of ")
+		if begin > 0:
+			begin += len(" of ")
+			function_name = sym[begin:] + ":" + function_name
+	else:
+		function_name = None
+	return (line_num, file_name, function_name)
+
+if no_task:
+	while 1:
+		try:
+			gdb.execute("tfind 0", False, True)
+			sym = gdb.execute("info line *($p_ip - 1)", True, True)
+			line = get_line_from_sym(sym)
+			task_list_add_line(False, 0, line)
+		except gdb.error, x:
+			print("Drop one entry because:")
+			for file, lineno, function, text in traceback.extract_tb(sys.exc_info()[2]):
+				print file, lineno, function, text
+		except gdb.MemoryError, x:
+			print("Drop one entry because:")
+			for file, lineno, function, text in traceback.extract_tb(sys.exc_info()[2]):
+				print file, lineno, function, text
+		try:
+			gdb.execute("tfind 1", False, True)
+		except:
+			pass
+else:
+	while 1:
+		try:
+			gdb.execute("tfind 0", False, True)
+			is_user = False
+			pid = long(gdb.parse_and_eval("$current_task_pid"))
+			if not pid in task_list:
+				raise gdb.error ("Cannot find inferior for pid "+ str(pid) +", drop one entry.")
+			if trace_user and (not trace_kernel or long(gdb.parse_and_eval("regs->cs & 3")) == 3):
+				is_user = True
+				ip = long(gdb.parse_and_eval("regs->ip - 1"))
+				gdb.execute("inferior "+str(task_list[pid].fid), False, True)
+				sym = gdb.execute("info line *"+str(ip), True, True)
+			else:
+				sym = gdb.execute("info line *(regs->ip - 1)", True, True)
+			line = get_line_from_sym(sym)
+			if is_user:
+				gdb.execute("inferior 1", False, True)
+			task_list_add_line(is_user, pid, line)
+		except gdb.error, x:
+			print("Drop one entry because:")
+			for file, lineno, function, text in traceback.extract_tb(sys.exc_info()[2]):
+				print file, lineno, function, text
+			try:
+				gdb.execute("inferior 1", False, True)
+			except:
+				pass
+		except gdb.MemoryError, x:
+			print("Drop one entry because:")
+			for file, lineno, function, text in traceback.extract_tb(sys.exc_info()[2]):
+				print file, lineno, function, text
+			try:
+				gdb.execute("inferior 1", False, True)
+			except:
+				pass
+		try:
+			gdb.execute("tfind 1", False, True)
+		except:
+			pass
--- /dev/null
+++ b/scripts/gtp/add-ons/pe.py
@@ -0,0 +1,729 @@
+#!/usr/bin/python
+
+# This script is used to show the performance counters in graph mode
+# GPL
+# Copyright(C) Hui Zhu (teawater@gmail.com), 2011
+
+
+pe_list = []
+#0 type, 1 config, 2 name
+#typt and config can get from https://code.google.com/p/kgtp/wiki/HOWTO#How_to_use_performance_counters
+pe_list.append(["0","0", "CPU_CYCLES"])
+pe_list.append(["0","1", "INSTRUCTIONS"])
+pe_list.append(["0","2", "CACHE_REFERENCES"])
+pe_list.append(["0","3", "CACHE_MISSES"])
+pe_list.append(["0","4", "BRANCH_INSTRUCTIONS"])
+pe_list.append(["0","5", "BRANCH_MISSES"])
+pe_list.append(["0","6", "BUS_CYCLES"])
+#pe_list.append(["3","0", "L1D_READ_ACCESS"])
+#pe_list.append(["3","1", "L1I_READ_ACCESS"])
+
+#sleep time
+sleep_sec = 1
+
+#0 text 1 gtk
+gui_type = 1
+
+in_gdb = False
+
+
+pe_list_type = 0
+pe_list_config = 1
+pe_list_name = 2
+pe_list_prev = 3
+pe_list_qtv = 4
+
+if in_gdb:
+	import gdb
+else:
+	import os
+
+
+class kgtp:
+	fd = -1
+	retry_count = 3
+	buf_max = 1024
+	tvariable = {}
+	tvariable_next_number = 0
+
+	def __init__(self):
+		#Open fd
+		try:
+			self.fd = os.open("/sys/kernel/debug/gtp", os.O_RDWR)
+		except:
+			print "Please do not forget insmod and sudo."
+			exit(0)
+
+	def __del__(self):
+		if self.fd >= 0:
+			os.close(self.fd)
+
+	def read_fd(self):
+		try:
+			buf = os.read(self.fd, self.buf_max)
+		except:
+			return False
+		return buf
+
+	def write_fd(self, msg):
+		try:
+			buf = os.write(self.fd, msg)
+		except:
+			return False
+		return True
+
+	def read(self):
+		for i in range(0, self.retry_count):
+			if i != 0:
+				self.write_fd("-")
+
+			buf = self.read_fd()
+			if buf == False:
+				continue
+			buf_len = len(buf)
+			if buf_len < 4:
+				continue
+
+			csum = 0
+			for i in range(0, buf_len - 2):
+				if i == 0:
+					if buf[i] != "$":
+						retry = True
+						break
+				elif buf[i] == '#':
+					break
+				else:
+					csum += ord(buf[i])
+			if i == 0 or buf[i] != "#":
+				continue
+			if int("0x"+buf[i+1:i+3], 16) != (csum & 0xff):
+				continue
+			buf = buf[1:i]
+			self.write_fd("+")
+
+			#print "KGTP read: "+buf
+			return buf
+
+		print "KGTP read got error"
+		return False
+
+	def write(self, msg):
+		for i in range(0, self.retry_count):
+			if i != 0:
+				self.write_fd("-")
+
+			csum = 0
+			for c in msg:
+				csum += ord(c)
+			msg = "$"+msg+"#"+"%02x" % (csum & 0xff)
+
+			if self.write_fd(msg) == False:
+				continue
+			if self.read_fd() != "+":
+				continue
+
+			#print "KGTP write: "+msg
+			return True
+
+		print "KGTP write got error"
+		return False
+
+	def simple_cmd(self, cmd):
+		if gtp.write(cmd) == False:
+			return False
+		if gtp.read() != "OK":
+			return False
+		return True
+
+	def tvariable_init(self):
+		tvariable = {}
+		tvariable_next_number = 0
+
+		if gtp.write("qTfV") == False:
+			return False
+		ret = gtp.read()
+		while 1:
+			if ret == False:
+				return False
+			if ret == "l":
+				return True
+			ret = ret.split(":")
+			if len(ret) < 4:
+				print "KGTP GDBRSP package format error"
+				return False
+			if len(ret[3]) % 2 != 0:
+				print "KGTP GDBRSP package format error"
+				return False
+
+			#Get name
+			letter = ""
+			name = ""
+			for c in ret[3]:
+				letter += c
+				if len(letter) == 2:
+					name += chr(int("0x"+letter, 16))
+					letter = ""
+
+			number = int("0x"+ret[0], 16)
+			self.tvariable[name] = number
+			if (number >= self.tvariable_next_number):
+				self.tvariable_next_number = number + 1
+
+			if gtp.write("qTsV") == False:
+				return False
+			ret = gtp.read()
+
+	def tvariable_val(self, number):
+		return self.tvariable_val_raw("qTV:"+"%x" % number)
+
+	def tvariable_val_raw(self, buf):
+		if gtp.write(buf) == False:
+			return
+		ret = gtp.read()
+		if ret == False:
+			return
+		if ret[0] != "V":
+			return
+
+		return long("0x"+ret[1:], 16)
+
+	def tvariable_add(self, name, val):
+		if self.tvariable_next_number == 0:
+			print "Must call tvariable_init before add tvariable"
+			return
+
+		buf = "QTDV:" + "%x" % self.tvariable_next_number + ":" + "%x" % val + ":0:"
+		for c in name:
+			buf += "%02x" % ord(c)
+		if gtp.write(buf) == False:
+			return
+		if gtp.read() != "OK":
+			print "Get something wrong when add tvariable to KGTP"
+			return
+
+		self.tvariable_next_number += 1
+		return (self.tvariable_next_number - 1)
+
+	def qtinit(self):
+		return self.simple_cmd("QTinit")
+
+	def tstart(self):
+		return self.simple_cmd("QTStart")
+
+	def tstop(self):
+		return self.simple_cmd("QTStop")
+
+
+def each_entry(callback):
+	global pe_list, cpu_number
+	for i in range(0, cpu_number):
+		for e in pe_list:
+			callback(i, e)
+
+
+def init_pe(i, e):
+	if (len(e) < pe_list_prev + 1):
+		e.append([])
+	e[pe_list_prev].append(0)
+	if (len(e) < pe_list_qtv + 1):
+		e.append([])
+
+	if in_gdb:
+		gdb.execute("tvariable $p_pe_type_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)+"="+e[pe_list_type], True, False)
+		gdb.execute("tvariable $p_pe_config_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)+"="+e[pe_list_config], True, False)
+		gdb.execute("tvariable $p_pe_val_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)+"=0", True, False)
+		gdb.execute("tvariable $p_pe_en_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)+"=1", True, False)
+	else:
+		if gtp.tvariable_add("p_pe_type_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i), int(e[pe_list_type])) == None:
+			exit(0)
+		if gtp.tvariable_add("p_pe_config_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i), int(e[pe_list_config])) == None:
+			exit(0)
+		number = gtp.tvariable_add("p_pe_val_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i), 0)
+		if number == None:
+			exit(0)
+		if gtp.tvariable_add("p_pe_en_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i), 1) == None:
+			exit(0)
+		e[pe_list_qtv].append("qTV:"+"%x" % number)
+
+def init_kgtp():
+	global cpu_number
+
+	if in_gdb:
+		cpu_number = int(gdb.parse_and_eval("$cpu_number"))
+		#Set the empty tracepoint
+		gdb.execute("delete tracepoints", False, False)
+		gdb.execute("trace *0", True, False)
+	else:
+		cpu_number = gtp.tvariable_val(gtp.tvariable["cpu_number"])
+		if cpu_number == None:
+			exit(0)
+
+	#Set the pe
+	each_entry(init_pe)
+
+import signal
+def sigint_handler(num, e):
+	if in_gdb:
+		gdb.execute("tstop", True, False)
+	else:
+		gtp.tstop()
+	exit(0)
+
+
+if in_gdb:
+	#close pagination
+	gdb.execute("set pagination off", True, False);
+	#Connect to KGTP if need
+	if str(gdb.selected_thread()) == "None":
+		gdb.execute("target remote /sys/kernel/debug/gtp", True, False)
+else:
+	gtp = kgtp()
+	if gtp.qtinit == False:
+		exit(0)
+	if gtp.tvariable_init() == False:
+		exit(0)
+
+#Init the status to KGTP
+cpu_number = 0
+init_kgtp()
+signal.signal(signal.SIGINT, sigint_handler)
+
+
+#start
+if in_gdb:
+	gdb.execute("tstart", True, False)
+else:
+	gtp.tstart()
+
+
+#text gui ---------------------------------------------------------------------
+#pe_list will be set to:type, config, name, prev_value_list
+if gui_type == 0:
+	import time
+	def output_pe(i, e):
+		if in_gdb:
+			current_value = long(gdb.parse_and_eval("$p_pe_val_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)))
+		else:
+			current_value = gtp.tvariable_val_raw(e[pe_list_qtv][i])
+			if current_value == None:
+				print "Fail when get val from KGTP"
+				exit(0)
+		print "cpu"+str(i),e[pe_list_name],current_value-e[pe_list_prev][i]
+		e[pe_list_prev][i] = current_value
+
+	while 1:
+		each_entry(output_pe)
+		print
+		time.sleep(sleep_sec)
+
+
+#gtk gui ----------------------------------------------------------------------
+#pe_list will be set to:0 type, 1 config, 2 name, 3 prev_value_list,
+#			4 value_list, 5 x_list, 6 button_list,
+#			7 button_color_list, 8 line_color_list
+if gui_type == 1:
+	#This script need python-gtk2
+	import gtk
+	import glib
+
+	pe_list_value = 5
+	pe_list_x = 6
+	pe_list_button = 7
+	pe_list_bcolor = 8
+	pe_list_lcolor = 9
+
+	pe_color = (0xffb0ff, 0x006000)
+
+	class PyApp(gtk.Window):
+		#Init ----------------------------------------------------------
+		def __init__(self):
+			global pe_list, cpu_number
+
+			super(PyApp, self).__init__()
+
+			self.max_value = 0
+			self.prev_width = 0
+			self.prev_height = 0
+			self.y_ratio = 0
+			self.entry_width = 10
+			self.logfd = False
+
+			#Set the pe
+			each_entry(self.pe_init_callback)
+
+			#Set the color
+			num = len(pe_list) * cpu_number
+			block = (pe_color[0] - pe_color[1]) / float(num)
+			color = pe_color[1]
+			for i in range(0, cpu_number):
+				for e in pe_list:
+					e[pe_list_bcolor].append(gtk.gdk.Color("#"+ "%06x" % int(color)))
+					e[pe_list_lcolor].append((((int(color) >> 16) / float(0xff) * 1), ((int(color) >> 8 & 0xff) / float(0xff) * 1), ((int(color) & 0xff) / float(0xff) * 1)))
+					color += block
+
+			#Set window
+			self.set_title("KGTP")
+			self.connect("destroy", gtk.main_quit)
+			gtk.Window.maximize(self)
+
+			#menubar
+			mb = gtk.MenuBar()
+			#file
+			filemenu = gtk.Menu()
+			filem = gtk.MenuItem("File")
+			filem.set_submenu(filemenu)
+			save = gtk.CheckMenuItem("Save log to a CSV file")
+			save.connect("activate", self.mb_save)
+			save.set_active(False)
+			exit = gtk.MenuItem("Exit")
+			exit.connect("activate", gtk.main_quit)
+			filemenu.append(save)
+			filemenu.append(gtk.SeparatorMenuItem())
+			filemenu.append(exit)
+			mb.append(filem)
+			#set
+			setmenu = gtk.Menu()
+			setm = gtk.MenuItem("Settings")
+			setm.set_submenu(setmenu)
+			show_buttons = gtk.CheckMenuItem("Show buttons")
+			show_buttons.set_active(True)
+			show_buttons.connect("activate", self.show_buttons)
+			setmenu.append(show_buttons)
+			mb.append(setm)
+
+			#Widget
+			#Creat self.darea
+			self.darea = gtk.DrawingArea()
+			self.darea.connect("expose-event", self.expose)
+			self.darea.modify_bg(gtk.STATE_NORMAL, gtk.gdk.Color("#FFFFFF"))
+			#Creat all ToggleButton for each pe
+			each_entry(self.pe_gtk_creat_button)
+			#Creat button_hboxes
+			self.button_hboxes = self.pe_gtk_creat_button_hboxes_first()
+
+			#Add mb and widget to window
+			self.vbox = gtk.VBox(False, 0)
+			self.vbox.pack_start(mb, False, False, 0)
+			self.vbox.pack_start(self.darea, True, True, 0)
+			for e in self.button_hboxes:
+				self.vbox.pack_start(e, False, False, 0)
+			self.add(self.vbox)
+
+			#First show to get the right size
+			self.show_all()
+			size = self.pe_gtk_get_size()
+
+			#Reset the button_hboxes
+			each_entry(self.pe_gtk_remove_creat_button_hboxes)
+			for e in self.button_hboxes:
+				self.vbox.remove(e)
+			self.button_hboxes = self.pe_gtk_creat_button_hboxes_second(size)
+			for e in self.button_hboxes:
+				self.vbox.pack_start(e, False, False, 0)
+			self.show_all()
+
+			#Reset the value of each button
+			each_entry(self.button_reset)
+
+			#Add timer
+			glib.timeout_add(int(sleep_sec * 1000), self.timer_cb)
+			#Remove the first entry because it already record a big value
+			glib.timeout_add(int(sleep_sec * 1100), self.timer_remove_first_record)
+
+		def __del__(self):
+			if self.logfd:
+				self.logfd.close()
+				self.logfd = False
+
+		def pe_init_callback(self, i, e):
+			if (len(e) < pe_list_value + 1):
+				e.append([])
+			e[pe_list_value].append([])
+			if (len(e) < pe_list_x + 1):
+				e.append([])
+			e[pe_list_x].append([])
+			if (len(e) < pe_list_button + 1):
+				e.append([])
+			if (len(e) < pe_list_button + 1):
+				e.append([])
+			if (len(e) < pe_list_bcolor + 1):
+				e.append([])
+			if (len(e) < pe_list_lcolor + 1):
+				e.append([])
+
+		def pe_gtk_creat_button(self, i, e):
+			e[pe_list_button].append(gtk.ToggleButton(e[pe_list_name]+":"+str(18446744073709551615)))
+			self.set_button_color(e[pe_list_button][i], e[pe_list_bcolor][i])
+			e[pe_list_button][i].connect("clicked", self.button_click)
+
+		def pe_gtk_creat_button_hboxes_first(self):
+			global pe_list, cpu_number
+
+			hboxes = []
+			self.label_list = []
+			for i in range(0, cpu_number):
+				hboxes.append(gtk.HBox(False, 0))
+				self.label_list.append(gtk.Label("CPU"+str(i)))
+				hboxes[i].pack_start(self.label_list[i], False, False, 0)
+				for e in pe_list:
+					hboxes[i].pack_start(e[pe_list_button][i], False, False, 0)
+
+			return hboxes
+
+		def pe_gtk_get_size(self):
+			global pe_list, cpu_number
+
+			#0 label size 1 button size
+			size = ([],[])
+			for i in range(0, cpu_number):
+				size[0].append(self.label_list[i].allocation.width)
+				size[1].append([])
+				for e in pe_list:
+					size[1][i].append(e[pe_list_button][i].allocation.width)
+
+			return size
+
+		def pe_gtk_remove_creat_button_hboxes(self, i, e):
+			self.button_hboxes[i].remove(e[pe_list_button][i])
+
+		def pe_gtk_creat_button_hboxes_second(self, size):
+			global pe_list, cpu_number
+
+			hboxes = []
+			hbox_id = -1
+			for i in range(0, cpu_number):
+				keep_going = True
+				prev_entry_id = 0
+				while keep_going == True:
+					width = self.allocation.width
+					keep_going = False
+					hbox_id += 1
+					hboxes.append(gtk.HBox(False, 0))
+					width -= size[0][i]
+					hboxes[hbox_id].pack_start(gtk.Label("CPU"+str(i)), False, False, 0)
+					for j in range(prev_entry_id, len(pe_list)):
+						if width - size[1][i][j] <= 0:
+							prev_entry_id = j
+							keep_going = True
+							break
+						width -= size[1][i][j] + 200
+						hboxes[hbox_id].pack_start(pe_list[j][pe_list_button][i], False, False, 0)
+
+			return hboxes
+
+		def button_reset(self, i, e):
+			e[pe_list_button][i].set_label(e[pe_list_name]+":0")
+
+		#Dialog -------------------------------------------------------
+		def dialog_error(self, msg):
+			md = gtk.MessageDialog(self,gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_CLOSE, msg)
+			md.run()
+			md.destroy()
+
+		#Menubar -------------------------------------------------------
+		def show_buttons(self, widget):
+			if widget.active:
+				for e in self.button_hboxes:
+					e.show()
+			else:
+				for e in self.button_hboxes:
+					e.hide()
+
+		def log_write_name(self, i, e):
+			self.logfd.write("CPU"+str(i)+" "+e[pe_list_name]+",")
+
+		def mb_save(self, widget):
+			if widget.active:
+				md = gtk.FileChooserDialog(title="Save log to a CSV file", action=gtk.FILE_CHOOSER_ACTION_SAVE, buttons = (gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OK, gtk.RESPONSE_OK))
+				md.set_do_overwrite_confirmation(True)
+				md.set_current_name("pe.csv")
+				if md.run() == gtk.RESPONSE_OK:
+					try:
+						self.logfd = open(md.get_filename(), "w")
+						each_entry(self.log_write_name)
+						self.logfd.write("\n")
+					except:
+						self.dialog_error("Try to open file "+md.get_filename()+" got error")
+						widget.set_active(False)
+						if self.logfd:
+							self.logfd.close()
+							self.logfd = False
+				else:
+					widget.set_active(False)
+				md.destroy()
+			else:
+				if self.logfd:
+					self.logfd.close()
+					self.logfd = False
+
+		#Button --------------------------------------------------------
+		def refind_max_value(self, i, e):
+			if e[pe_list_button][i].get_active():
+				return
+			for i in e[pe_list_value][i]:
+				if i > self.max_value:
+					self.max_value = i
+					self.y_ratio = 0
+
+		def set_button_color(self, button, color):
+			style = button.get_style().copy()
+			style.bg[gtk.STATE_NORMAL] = color
+			style.bg[gtk.STATE_ACTIVE] = color
+			style.bg[gtk.STATE_PRELIGHT] = color
+			style.bg[gtk.STATE_SELECTED] = color
+			style.bg[gtk.STATE_INSENSITIVE] = color
+			button.set_style(style)
+
+		def button_click(self, widget):
+			if widget.get_active():
+				self.set_button_color(widget, gtk.gdk.Color("#FFFFFF"))
+			else:
+				color = False
+				for i in range(0, cpu_number):
+					for e in pe_list:
+						if e[pe_list_button][i] == widget:
+							color = e[pe_list_bcolor][i]
+							break
+					if color:
+						break
+				if color:
+					self.set_button_color(widget, color)
+				each_entry(self.refind_max_value)
+			self.darea.queue_draw()
+
+		#Timer ---------------------------------------------------------
+		def write_csv(self, msg):
+			try:
+				self.logfd.write(msg)
+			except:
+				self.dialog_error("Writ CSV file got error")
+				widget.set_active(False)
+				self.logfd.close()
+				self.logfd = False
+
+		def pe_gtk_add(self, i, e):
+			if in_gdb:
+				current_value = long(gdb.parse_and_eval("$p_pe_val_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)))
+			else:
+				current_value = gtp.tvariable_val_raw(e[pe_list_qtv][i])
+				if current_value == None:
+					print "Fail when get val from KGTP"
+					exit(0)
+			this_value = current_value-e[pe_list_prev][i]
+			e[pe_list_value][i].append(this_value)
+			if this_value > self.max_value and not e[pe_list_button][i].get_active():
+				self.max_value = this_value
+				self.y_ratio = 0
+			e[pe_list_x][i].append(-1)
+			e[pe_list_prev][i] = current_value
+			e[pe_list_button][i].set_label(e[pe_list_name]+":"+str(this_value))
+			if self.logfd:
+				write_csv(str(this_value)+",")
+
+		def timer_cb(self):
+			each_entry(self.pe_gtk_add)
+			if self.logfd:
+				write_csv("\n")
+			self.darea.queue_draw()
+			return True
+
+		def timer_remove_first_record(self):
+			if len(pe_list[0][pe_list_value][0]) >= 1:
+				self.pe_remove_entry_num = 1
+				each_entry(self.pe_remove_entry)
+				return False
+			else:
+				return True
+
+		#DrawingArea ---------------------------------------------------
+		def pe_gtk_line(self, i, e):
+			if len(e[pe_list_value][i]) < 2:
+				return
+			if e[pe_list_button][i].get_active():
+				return
+
+			self.cr.set_source_rgb(e[pe_list_lcolor][i][0], e[pe_list_lcolor][i][1], e[pe_list_lcolor][i][2])
+			x = 0
+			for num in range(0, len(e[pe_list_value][i])):
+				if e[pe_list_value][i][num] > self.line_max:
+					self.line_max = e[pe_list_value][i][num]
+				if self.height_change or e[pe_list_x][i][num] < 0:
+					e[pe_list_x][i][num] = self.prev_height - e[pe_list_value][i][num] * self.y_ratio
+				if num == 0:
+					self.cr.move_to(x, e[pe_list_x][i][num])
+				else:
+					self.cr.line_to(x, e[pe_list_x][i][num])
+				x += self.entry_width
+			self.cr.stroke()
+
+		def pe_remove_entry(self, i, e):
+			del(e[pe_list_value][i][0:self.pe_remove_entry_num])
+			del(e[pe_list_x][i][0:self.pe_remove_entry_num])
+
+		def expose(self, widget, event):
+			self.cr = widget.window.cairo_create()
+
+			#y
+			if self.prev_height != self.darea.allocation.height:
+				self.height_change = True
+				self.prev_height = self.darea.allocation.height
+			else:
+				self.height_change = False
+			if self.max_value > 0 and (self.height_change or self.y_ratio == 0):
+				self.max_value += 100 - self.max_value % 100
+				self.y_ratio = float(self.prev_height)/self.max_value
+				self.height_change = True
+
+			#x
+			x_size = len(pe_list[0][pe_list_value][0])
+			entry_number = 0
+			if self.entry_width * x_size > self.darea.allocation.width:
+				entry_number = self.darea.allocation.width // self.entry_width
+				self.pe_remove_entry_num = x_size - entry_number
+				each_entry(self.pe_remove_entry)
+
+			#dash
+			self.cr.set_source_rgb(0, 0, 0)
+			self.cr.set_dash((1, 5))
+			#dash line for x
+			if entry_number == 0:
+				entry_number = self.darea.allocation.width // self.entry_width
+			x = 0
+			while x < self.darea.allocation.width:
+				x += self.entry_width * 10
+				self.cr.move_to(x, 0)
+				self.cr.line_to(x, self.prev_height)
+			#dash line for y
+			self.cr.move_to(0, 10)
+			self.cr.show_text(str(self.max_value))
+
+			self.cr.move_to(0, self.darea.allocation.height/4*3)
+			self.cr.show_text(str(self.max_value/4*3))
+			self.cr.line_to(self.darea.allocation.width, self.darea.allocation.height/4*3)
+
+			self.cr.move_to(0, self.darea.allocation.height/2)
+			self.cr.show_text(str(self.max_value/2))
+			self.cr.line_to(self.darea.allocation.width, self.darea.allocation.height/2)
+
+			self.cr.move_to(0, self.darea.allocation.height/4)
+			self.cr.show_text(str(self.max_value/4))
+			self.cr.line_to(self.darea.allocation.width, self.darea.allocation.height/4)
+
+			self.cr.stroke()
+			self.cr.set_dash(())
+
+			self.line_max = 0
+			each_entry(self.pe_gtk_line)
+			if self.line_max > 0 and self.line_max * 2 < self.max_value:
+				self.max_value = self.line_max
+				self.y_ratio = 0
+
+			self.height_change = False
+
+	PyApp()
+	gtk.main()
+	if in_gdb:
+		gdb.execute("tstop", True, False)
+	else:
+		gtp.tstop()
+	exit(0)
--- /dev/null
+++ b/scripts/gtp/getgtprsp.pl
@@ -0,0 +1,182 @@
+#!/usr/bin/perl
+
+# This script to get the GDB tracepoint RSP package and save it
+# to ./gtpstart and ./gtpstop file.
+# GPL
+# Copyright(C) KGTP team (https://code.google.com/p/kgtp/), 2010-2013
+
+binmode STDIN, ":raw";
+$| = 1;
+
+$status = 0;
+$circular = 0;
+$var_count = 0;
+
+while (1) {
+	sysread STDIN, $c, 1 or next;
+	if ($c eq '') {
+		next;
+	} elsif ($c eq '+' || $c eq '-') {
+		$c = '';
+	}
+
+	sysread STDIN, $line, 1024 or next;
+	print '+';
+	$line = $c.$line;
+
+	open(LOG, ">>./log");
+	print LOG $line."\n";
+	close (LOG);
+
+	if ($status == 0) {
+		if ($line eq '$?#3f') {
+			print '$S05#b8';
+		} elsif ($line eq '$g#67') {
+			print '$00000000#80';
+		} elsif ($line eq '$k#6b') {
+			exit;
+		} elsif ($line =~ /^\$m/ || $line =~ /^\$p/) {
+			print '$00000000#80';
+		} elsif ($line eq '$qTStatus#49') {
+			print '$T0;tnotrun:0;tframes:0;tcreated:0;tsize:';
+			print '500000;tfree:500000;circular:0;disconn:0#d1';
+		} elsif ($line eq '$QTBuffer:circular:1#f9') {
+			print '$OK#9a';
+			$circular = 1;
+		} elsif ($line eq '$QTBuffer:circular:0#f8') {
+			print '$OK#9a';
+			$circular = 0;
+		} elsif ($line eq '$QTStop#4b') {
+			print '$OK#9a';
+		} elsif ($line =~ /^\$qSupported/) {
+			print '$ConditionalTracepoints+;TracepointSource+#1b';
+		} elsif ($line eq '$QTinit#59') {
+			$status = 1;
+			open(STARTFILE, ">./gtpstart");
+			print STARTFILE '$QTDisconnected:1#e3'."\n";
+			if ($circular) {
+				print STARTFILE '$QTBuffer:circular:1#f9';
+			} else {
+				print STARTFILE '$QTBuffer:circular:0#f8';
+			}
+		} elsif ($line eq '$qTfV#81') {
+			print '$18:0:1:6972715f636f756e74#ca';
+		} elsif ($line eq '$qTsV#8e') {
+			#Support from GTP_VAR_VERSION_ID(0x1) to GTP_STEP_ID_ID(0x2d)
+			if ($var_count == 0) {
+				print '$17:0:1:736f66746972715f636f756e74#a6';
+			} elsif ($var_count == 1) {
+				print '$16:0:1:686172646972715f636f756e74#70';
+			} elsif ($var_count == 2) {
+				print '$15:0:1:6c6173745f6572726e6f#59';
+			} elsif ($var_count == 3) {
+				print '$14:0:1:69676e6f72655f6572726f72#38';
+			} elsif ($var_count == 4) {
+				print '$13:0:1:7874696d655f6e736563#35';
+			} elsif ($var_count == 5) {
+				print '$12:0:1:7874696d655f736563#99';
+			} elsif ($var_count == 6) {
+				print '$11:0:1:6b726574#48';
+			} elsif ($var_count == 7) {
+				print '$10:0:1:705f70655f656e#e5';
+			} elsif ($var_count == 8) {
+				print '$f:0:1:6370755f6e756d626572#29';
+			} elsif ($var_count == 9) {
+				print '$e:0:1:73656c665f7472616365#f8';
+			} elsif ($var_count == 10) {
+				print '$d:0:1:64756d705f737461636b#22';
+			} elsif ($var_count == 11) {
+				print '$c:0:1:7072696e746b5f666f726d6174#c7';
+			} elsif ($var_count == 12) {
+				print '$b:8:1:7072696e746b5f6c6576656c#66';
+			} elsif ($var_count == 13) {
+				print '$a:0:1:7072696e746b5f746d70#54';
+			} elsif ($var_count == 14) {
+				print '$9:0:1:6774705f72625f646973636172645f706167655f6e756d626572#2d';
+			} elsif ($var_count == 15) {
+				print '$8:0:1:636f6f6b65645f7264747363#01';
+			} elsif ($var_count == 16) {
+				print '$7:0:1:7264747363#57';
+			} elsif ($var_count == 17) {
+				print '$6:0:1:636f6f6b65645f636c6f636b#8d';
+			} elsif ($var_count == 18) {
+				print '$5:0:1:636c6f636b#e3';
+			} elsif ($var_count == 19) {
+				print '$4:0:1:63757272656e745f7468726561645f696e666f#21';
+			} elsif ($var_count == 20) {
+				print '$3:0:1:63757272656e745f7461736b#c9';
+			} elsif ($var_count == 21) {
+				print '$2:0:1:6370755f6964#f1';
+			} elsif ($var_count == 22) {
+				print '$1:bfe30fc:1:6774705f76657273696f6e#94';
+			} elsif ($var_count == 23) {
+				print '$19:0:1:706970655f7472616365#cb';
+			} elsif ($var_count == 24) {
+				print '$1a:0:1:63757272656e745f7461736b5f706964#03';
+			} elsif ($var_count == 25) {
+				print '$1d:200:1:6274#d9';
+			} elsif ($var_count == 26) {
+				print '$1b:0:1:63757272656e745f7461736b5f75736572#6e';
+			} elsif ($var_count == 27) {
+				print '$1c:0:1:63757272656e74#bb';
+			} elsif ($var_count == 28) {
+				print '$1f:0:1:64697361626c65#bc';
+			} elsif ($var_count == 29) {
+				print '$1e:0:1:656e61626c65#7e';
+			} elsif ($var_count == 30) {
+				print '$18:0:1:6972715f636f756e74#ca';
+			} elsif ($var_count == 31) {
+				print '$20:0:1:77617463685f737461746963#a2';
+			} elsif ($var_count == 32) {
+				print '$21:0:1:77617463685f74797065#d1';
+			} elsif ($var_count == 33) {
+				print '$22:1:1:77617463685f73697a65#02';
+			} elsif ($var_count == 34) {
+				print '$23:0:1:77617463685f7365745f6964#da';
+			} elsif ($var_count == 35) {
+				print '$24:0:1:77617463685f7365745f61646472#a6';
+			} elsif ($var_count == 36) {
+				print '$25:0:1:77617463685f7374617274#38';
+			} elsif ($var_count == 37) {
+				print '$26:0:1:77617463685f73746f70#01';
+			} elsif ($var_count == 38) {
+				print '$27:0:1:77617463685f74726163655f6e756d#75';
+			} elsif ($var_count == 39) {
+				print '$28:0:1:77617463685f74726163655f61646472#79';
+			} elsif ($var_count == 40) {
+				print '$29:0:1:77617463685f61646472#d0';
+			} elsif ($var_count == 41) {
+				print '$2a:0:1:77617463685f76616c#c1';
+			} elsif ($var_count == 42) {
+				print '$2b:0:1:77617463685f636f756e74#cc';
+			} elsif ($var_count == 43) {
+				print '$2c:0:1:737465705f636f756e74#5d';
+			} elsif ($var_count == 44) {
+				print '$2d:0:1:737465705f6964#c0';
+			} else {
+				print '$l#6c';
+			}
+			$var_count++;
+		} else {
+			print '$#00';
+		}
+	}
+
+	if ($status == 1) {
+		print '$OK#9a';
+
+		if (length($line) > 0) {
+			print STARTFILE "\n".$line;
+		}
+
+		if ($line eq '$QTStart#b3') {
+			$status = 0;
+
+			close(STARTFILE);
+
+			open(STOPFILE, ">./gtpstop");
+			print STOPFILE '$QTStop#4b';
+			close(STOPFILE);
+		}
+	}
+}
--- /dev/null
+++ b/scripts/gtp/getmod.py
@@ -0,0 +1,151 @@
+#!/usr/bin/python
+
+# This script is used by GDB to load the symbols from Linux kernel modules
+# GPL
+# Copyright(C) KGTP team (https://code.google.com/p/kgtp/), 2011, 2012
+
+#Set special mod_search_dir
+#set $mod_search_dir="dir"
+#Clear special mod_search_dir
+#set $mod_search_dir=(void)1
+#Not ignore gtp.ko
+#set $ignore_gtp_ko=0
+
+import gdb
+import os
+
+def get_pagination():
+	buf = gdb.execute("show pagination", False, True)
+	begin = buf.find("State of pagination is ") + len("State of pagination is ")
+	if begin < 0:
+		raise NotImplementedError("Cannot get pagination")
+	buf = buf[begin:]
+	end = buf.rfind(".")
+	buf = buf[:end]
+
+	return buf
+
+pagination = get_pagination()
+gdb.execute("set pagination off", False, False)
+
+def format_file(name):
+	tmp = ""
+	for c in name:
+		if c == "_":
+			c = "-"
+		tmp += c
+	return tmp
+
+#Check if the target is available
+if str(gdb.selected_thread()) == "None":
+	raise gdb.error("Please connect to Linux Kernel before use the script.")
+
+#Output the help
+print "Use GDB command \"set $mod_search_dir=dir\" to set an directory for search the modules."
+
+ignore_gtp_ko = gdb.parse_and_eval("$ignore_gtp_ko")
+if ignore_gtp_ko.type.code == gdb.TYPE_CODE_INT:
+	ignore_gtp_ko = int(ignore_gtp_ko)
+else:
+	ignore_gtp_ko = 1
+
+#Get the mod_search_dir
+mod_search_dir_list = []
+#Get dir from $mod_search_dir
+tmp_dir = gdb.parse_and_eval("$mod_search_dir")
+if tmp_dir.type.code == gdb.TYPE_CODE_ARRAY:
+	tmp_dir = str(tmp_dir)
+	tmp_dir = tmp_dir[1:len(tmp_dir)]
+	tmp_dir = tmp_dir[0:tmp_dir.index("\"")]
+	mod_search_dir_list.append(tmp_dir)
+#Get dir that same with current vmlinux
+tmp_dir = str(gdb.execute("info files", False, True))
+tmp_dir = tmp_dir[tmp_dir.index("Symbols from \"")+len("Symbols from \""):len(tmp_dir)]
+tmp_dir = tmp_dir[0:tmp_dir.index("\"")]
+tmp_dir = tmp_dir[0:tmp_dir.rindex("/")]
+mod_search_dir_list.append(tmp_dir)
+#Get the dir of current Kernel
+tmp_dir = "/lib/modules/" + str(os.uname()[2])
+if os.path.isdir(tmp_dir):
+	mod_search_dir_list.append(tmp_dir)
+#Let user choice dir
+mod_search_dir = ""
+while mod_search_dir == "":
+	for i in range(0, len(mod_search_dir_list)):
+		print str(i)+". "+mod_search_dir_list[i]
+	try:
+		s = input('Select a directory for search the modules [0]:')
+	except SyntaxError:
+		s = 0
+	except:
+		continue
+	if s < 0 or s >= len(mod_search_dir_list):
+		continue
+	mod_search_dir = mod_search_dir_list[s]
+
+mod_list_offset = long(gdb.parse_and_eval("((size_t) &(((struct module *)0)->list))"))
+mod_list = long(gdb.parse_and_eval("(&modules)"))
+mod_list_current = mod_list
+
+while 1:
+	mod_list_current = long(gdb.parse_and_eval("((struct list_head *) "+str(mod_list_current)+")->next"))
+
+	#check if need break the loop
+	if mod_list == mod_list_current:
+		break
+
+	mod = mod_list_current - mod_list_offset
+
+	#get mod_name
+	mod_name = str(gdb.parse_and_eval("((struct module *)"+str(mod)+")->name"))
+	mod_name = mod_name[mod_name.index("\"")+1:len(mod_name)]
+	mod_name = mod_name[0:mod_name.index("\"")]
+	mod_name += ".ko"
+	mod_name = format_file(mod_name)
+
+	#get mod_dir_name
+	mod_dir_name = ""
+	for root, dirs, files in os.walk(mod_search_dir):
+		for afile in files:
+			tmp_file = format_file(afile)
+			if tmp_file == mod_name:
+				mod_dir_name = os.path.join(root,afile)
+				break
+		if mod_dir_name != "":
+			break
+
+	command = " "
+
+	#Add module_core to command
+	tmp = str(gdb.parse_and_eval("((struct module *)"+str(mod)+")->module_core"))
+	if tmp.find('<') >= 0:
+		tmp = tmp[:tmp.index('<')]
+	command += tmp
+
+	#Add each sect_attrs->attrs to command
+	#get nsections
+	nsections = int(gdb.parse_and_eval("((struct module *)"+str(mod)+")->sect_attrs->nsections"))
+	sect_attrs = long(gdb.parse_and_eval("(u64)((struct module *)"+str(mod)+")->sect_attrs"))
+	for i in range(0, nsections):
+		command += " -s"
+		tmp = str(gdb.parse_and_eval("((struct module_sect_attrs *)"+str(sect_attrs)+")->attrs["+str(i)+"].name"))
+		tmp = tmp[tmp.index("\"")+1:len(tmp)]
+		tmp = tmp[0:tmp.index("\"")]
+		command += " "+tmp
+		tmp = str(gdb.parse_and_eval("((struct module_sect_attrs *)"+str(sect_attrs)+")->attrs["+str(i)+"].address"))
+		command += " "+tmp
+
+	if mod_dir_name == "":
+		print "Cannot find out",mod_name,"from directory."
+		print "Please use following command load the symbols from it:"
+		print "add-symbol-file some_dir/"+mod_name+command
+	else:
+		if ignore_gtp_ko and mod_name == "gtp.ko":
+			print "gtp.ko is ignored.  You can use command \"set $ignore_gtp_ko=0\" to close this ignore."
+			print "Or you can use following command load the symbols from it:"
+			print "add-symbol-file "+mod_dir_name+command
+		else:
+			#print "add-symbol-file "+mod_dir_name+command
+			gdb.execute("add-symbol-file "+mod_dir_name+command, False, False)
+
+gdb.execute("set pagination " + pagination, False, False)
